<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-27T19:18:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LeeJellan</title><subtitle>안녕하세요!🙂 IT,여행,기타 등 기록을 남기기위한 블로그 입니다 !</subtitle><author><name>LEE JAEHYEOK</name></author><entry><title type="html">macOs) Apache 웹 서버 AH00558 Could not reliable determine the server’s fully qualified domain name ..</title><link href="http://localhost:4000/macos/2022/11/27/OS-macOs-4.html" rel="alternate" type="text/html" title="macOs) Apache 웹 서버 AH00558 Could not reliable determine the server’s fully qualified domain name .." /><published>2022-11-27T00:00:00+09:00</published><updated>2022-11-27T00:00:00+09:00</updated><id>http://localhost:4000/macos/2022/11/27/OS-macOs-4</id><content type="html" xml:base="http://localhost:4000/macos/2022/11/27/OS-macOs-4.html"><![CDATA[<p>오늘 공부하다가 막혔던 부분이 있어서 <br />
도움이 될까 싶어 적어본다.</p>

<h3 id="apache-웹-서버">APACHE 웹 서버</h3>

<p>아파치 HTTP 서버(Apache HTTP Server)는 <br />
아파치 소프트웨어 재단에서 관리하는 오픈 소스, 크로스 플랫폼 HTTP 웹 서버 소프트웨어다. <br />
BSD, 리눅스 등 유닉스 계열 뿐 아니라 마이크로소프트 윈도우나 노벨 넷웨어 <br />
같은 기종에서도 무료로 운용할 수 있다고 한다. <strong>[<a href="https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_HTTP_%EC%84%9C%EB%B2%84">출처 - 위키백과</a>]</strong></p>

<p>Mac 환경에서 Apache 웹서버를 사용해보려하다 오류가 발생했다.<br />
오류를 얘기하기전 우선 설치 과정을 아래의 사이트를 참고했다.<br />
<strong>[<a href="https://www.javatpoint.com/how-to-install-apache-on-mac">Apache 설치 방법 - 참고사이트</a>]</strong></p>

<p><br /></p>

<p>homebrew를 이용한 설치방법이고<br />
Mac 사용 유저라면 익히 알고 있을 것이다.</p>

<p>설치를 완료한다음 <br />
문제는 아파치 서버를 실행/종료 시키기위해서<br />
<code class="language-plaintext highlighter-rouge">sudo apachectl start</code> 명령어와 <code class="language-plaintext highlighter-rouge">sudo apachectl stop</code> 명령어를<br />
사용하게 되는데… AH00558 코드로된 알람이 발생했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMPblHp1IrHpidEB8NNOHDrTqEx8Q_JW9oJb7H4iCMDJNIKJUgNoYoQPhx8afmEEUw_UNIczBB2e98aG8ey3dT_HzWk=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AH00558: httpd: Could not reliably determine the server<span class="s1">'s fully qualified domain name, using MacBook-Pro.local. Set the '</span>ServerName<span class="s1">' directive globally to suppress this message
</span></code></pre></div></div>

<p>오류는 그렇다 쳐도, 기본 적으로 localhost에 접속하면<br />
<code class="language-plaintext highlighter-rouge">It works!</code> 화면이 노출되지 않았다.<br />
localhost:8080에 접속해야지만 화면이 노출되었고<br />
설정을 바꿀 필요가 있다고 느껴졌다.</p>

<p><br /></p>

<p><strong>1). httpd.conf 파일 찾기</strong></p>

<p>설정을 변경하기 위해서는 <code class="language-plaintext highlighter-rouge">httpd.conf</code> 파일을 수정해줘야한다.<br />
해당 파일 경로를 찾기위해 여러가지 블로그를 찾아보았는데</p>

<p>사람마다 여러가지 경로로 수정을 하는걸 보았다.</p>

<p><code class="language-plaintext highlighter-rouge">/etc/apache2/httpd.conf</code><br />
<code class="language-plaintext highlighter-rouge">/private/etc/apache2/httpd.conf</code><br />
와 같은 경로로 수정한 사람들도 있는 것 같다.<br />
하지만 나와 같은 경우는 제대로 반영되지 않았고…</p>

<p>어떠한 차이인지는 아직 불분명하지만 내가 수정했던 경로는 아래와 같다.  <br />
📌<code class="language-plaintext highlighter-rouge">/opt/homebrew/etc/httpd/httpd.conf</code>📌 <br />
아마 homebrew를 통해 실행하는 것이기 때문이지 않을까? 라는 생각을 해본다.</p>

<p><code class="language-plaintext highlighter-rouge">httpd.conf</code> 파일을 찾는데 처음에 애먹어서 시간을 많이 쓴 것 같다.</p>

<p>파일을 찾았으면 이제 shell에서 vi 편집기로 값을 수정해주면된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi /opt/homebrew/etc/httpd/httpd.conf
</code></pre></div></div>

<p><br /></p>

<p><strong>2). Port 80 으로 변경하기</strong></p>

<p>편집기를 열고 아래와 같은 Listen을 찾아준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPzEEFalQYxag6NQ4wOJV1AuBpyHFHn9LwAi4g0PY8YljuKfpiPQY-9H1mOU1Vxqa-0reRKR1itloqQ_nXt8n7xKAh8=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>아마 기본적으로 8080으로 설정되어있을 것이다.<br />
#으로 주석처리를 해준다음, 아래에서 <code class="language-plaintext highlighter-rouge">Listen 80</code>으로 설정해주었다.</p>

<p><br /></p>

<p><strong>3). localhost로 변경 하기</strong></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO9rZHRQQQ0HI4HBe-UBcgFt4ZMl91uomBFpsZLjsruipSi2KrdWjR89J1rptKW4mQSwI7iFSbjmpV5PgPfGLj88BO4yw=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위의 사진과 같이 ServerName을 localhost로 설정해주면 된다.</p>

<p><br /></p>

<p><strong>4). 결과 확인하기</strong></p>

<p>아파치 웹서버 실행 명령어인<br />
<code class="language-plaintext highlighter-rouge">sudo apachectl start</code>,<code class="language-plaintext highlighter-rouge">sudo apachectl stop</code>를 입력해도</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMxycEEiyoGZsXP0ZAh9sdmRXbB9ucK6Ar42OXNGDH3-OZW4FNBlpa68ehMFGULCDXcXODH-iLfmTYgK239LTRz134ZRg=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>더 이상 AH00558 오류가 발생하지 않는 모습이다.</p>

<p><br /></p>

<p>아파치 웹서버를 실행 시켜놓은 상태에서</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMRbasfobijEvOlwe60oFwSiELjJ7dm4RE7huFv2fFxSceyEPbFWQtmJCGSotTjXhbdaHpxJMCUOK2eMNPAneRzzlNyKA=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>localhost를 입력하여 접속할 경우<br />
이제 드디어 <code class="language-plaintext highlighter-rouge">It works</code> 화면을 볼 수 있게 된다 !!</p>

<p>혹시나 싶어 <a href="https://mainia.tistory.com/5490">WindowOS 해결 방법 - 출처 mainia님</a> 찾다가 좋은글인 것 같아 올려본다.<br />
좀 더 자세한 내용을 보고싶다면 <a href="https://velog.io/@diduya/macOS%EC%97%90-Homebrew%EB%A1%9C-Apache-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0">내가 참고한 해결 방법 - 출처 diduya님</a> 포스팅을 봐도<br />
좋은 해결법이될 것 같다.</p>

<hr />]]></content><author><name>LEE JAEHYEOK</name></author><category term="macOs" /><category term="macOs" /><category term="IT" /><summary type="html"><![CDATA[오늘 공부하다가 막혔던 부분이 있어서 도움이 될까 싶어 적어본다.]]></summary></entry><entry><title type="html">Spring) Could not resolve placeholder ‘환경변수명’ in value “${환경변수명}” 오류</title><link href="http://localhost:4000/spring/2022/11/25/spring-environment.html" rel="alternate" type="text/html" title="Spring) Could not resolve placeholder ‘환경변수명’ in value “${환경변수명}” 오류" /><published>2022-11-25T00:00:00+09:00</published><updated>2022-11-25T00:00:00+09:00</updated><id>http://localhost:4000/spring/2022/11/25/spring-environment</id><content type="html" xml:base="http://localhost:4000/spring/2022/11/25/spring-environment.html"><![CDATA[<p>오늘은 내가 겪은 환경변수에 관련된 설정과 오류를 <br />
기록해보려고한다.</p>

<p><br /></p>

<h2 id="문제-내용">문제 내용</h2>

<p>우선 나는 Mac을 사용하고 Shell은 zsh를 사용한다.</p>

<p>문제의 시작은 이러하다. JWT관련 공부중이였고<br />
코드에서 @Value 어노테이션으로 application.yml 파일의 <br />
설정된 값들을 사용하려고하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtTokenizer</span> <span class="o">{</span>

    <span class="nd">@Getter</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${jwt.secret-key}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">secretKey</span><span class="o">;</span>
    
    <span class="o">...</span> <span class="n">이하</span> <span class="n">생략</span>
<span class="o">}</span>
</code></pre></div></div>

<p>사용하려고 하는 대상은 SecretKey이고<br />
중요한 정보이기 때문에 <strong>시스템 환경변수</strong>를 사용해<br />
값을 사용하고 싶어 .yml 파일에 값을 셋팅해두었다.</p>

<p><br /></p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jwt</span><span class="pi">:</span>
  <span class="na">secret-key</span><span class="pi">:</span> <span class="s">${JWT_SECRET_KEY}</span>       <span class="c1"># 환경 변수로 설정했음</span>
  <span class="na">access-token-expiration-minutes</span><span class="pi">:</span> <span class="m">30</span>
  <span class="na">refresh-token-expiration-minutes</span><span class="pi">:</span> <span class="m">420</span>
</code></pre></div></div>

<p>위와 같이 ${환경변수명} 으로 지정을하였고<br />
만약 테스트를 실행한다면 @Value가 .yml의 경로를 찾아<br />
JWT_SECRET_KEY라고 설정된 환경변수를 가져와야한다.</p>

<p>하지만 테스트를 실행했을때</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'jwtTokenizer': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'JWT_SECRET_KEY' in value "${JWT_SECRET_KEY}"
</code></pre></div></div>
<p>위와 같은 에러가 발생했고…. 무언가 환경변수를<br />
제대로 가져오지 못한다고 생각이 들었다.</p>

<p><br /></p>

<h2 id="문제-확인-및-해결">문제 확인 및 해결</h2>

<p>첫번째로 해당 에러가 발생하는 대부분의 이유는</p>
<ol>
  <li>application.yml 혹은 application.properties를 설정하지 않거나 경로를 틀림</li>
  <li>환경변수 설정에 문제가 있었음. (bash shell, zsh shell 등..)</li>
</ol>

<p>하지만 나는 위에 있는 내용을 전부 충족했지만 왜? 도대체 값을 가져오지<br />
못하는지 미쳐버릴 지경에 이르렀었다.</p>

<p>사실 문제 해결은 간단했다.<br />
하지만 문제 해결을 먼저 올리기전에 환경변수 설정에 대해 적어본다.</p>

<p><br /></p>

<h3 id="macos-환경-변수-적용법">MacOS 환경 변수 적용법</h3>

<p><strong>1). 현재 사용하고 있는 Shell을 확인</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$SHELL</span>
</code></pre></div></div>
<p>사용하고 있는 터미널에서 위를 입력해준다.</p>

<p>만약 zsh Shell을 사용하고 있을 경우에는  -&gt; /bin/zsh<br />
bash Shell을 사용하고 있을 경우에는 -&gt; /bin/bash</p>

<p>아마 대부분 맥북유저는 zsh Shell을 사용하고 있을 것 같다.</p>

<p><br /></p>

<p><strong>2). 사용하고 있는 Shell에 따른 등록</strong></p>

<p>vi 편집기 사용법을 알고있다고 가정하겠습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.zshrc
</code></pre></div></div>
<p>만약 zsh를 사용하고 있는 경우에는 .zshrc 파일에 환경 변수를<br />
등록해줘야합니다.</p>

<p><br /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vi ~/.bashrc
</code></pre></div></div>
<p>bash를 사용하고 있는 경우에는 .bashrc 파일에 등록!</p>

<p><br /></p>

<p><strong>3). 환경 변수를 등록합니다.</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span><span class="nv">JWT_SECRET_KEY</span><span class="o">=</span>LeeJaehyeok637637123231231231123
</code></pre></div></div>
<p>현재 내가 등록하려는 환경변수는 <code class="language-plaintext highlighter-rouge">JWT_SECRET_KEY</code> 라는 이름으로<br />
위에서 설정한다고 얘기했었고, 해당 값은 위처럼 <code class="language-plaintext highlighter-rouge">LeeJaehyeok637637123231231231123</code>을<br />
사용하려고 값을 임의로 설정해서 넣어주었다.</p>

<p><br /></p>

<p><strong>4). 환경 변수 확인.</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">printenv</span>
</code></pre></div></div>
<p>printenv 명령어를 입려하면 우선 <br />
전체 적용된 환경변수 목록이 나온다.<br />
그 중에 우리가 적용한 JWT_SECRET_KEY가 있으면<br />
정상적으로 잘 적용되었다고 볼 수 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$JWT_SECRET_KEY</span>
</code></pre></div></div>
<p>echo 명령어를 이용하면 지정해서 확인이 가능하다.<br />
내가 등록한 환경변수는 <code class="language-plaintext highlighter-rouge">JWT_SECRET_KEY</code>로 등록했기에<br />
해당 명령어를 입력하면 아래와 같이 표시된다면 정상이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPJh2n11ERgYKg0d3nAkDTsgg7LPqEe2CpPKYPF1Z_QrHIuceZwiBV8Yk3kndJG8x8yQFFPKWCfp-kBFUZAkkOK4WfrBg=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그럼 여기까지 설정하고 조회까지 해보았으면<br />
환경변수 설정에는 문제가 없는 것이다.</p>

<p>혹여나 bash 사용으로 bash_profile에 설정하셨는데<br />
환경변수가 자꾸 리셋된다는 문제를 겪는 분들은<br />
1번 항목에 어떤 Shell을 사용하는지 다시 확인해볼 필요가 있다.</p>

<p><br /></p>

<h3 id="그래서해결-방법">그래서해결 방법?</h3>

<p>문제는 너무 간단했다.<br />
실제로 환경변수는 잘 적용되어있었고<br />
환경변수가 적용되지 않았던 이유는 <span style="color:#F04965"><strong>IDE Restart</strong></span>를 하지 않았던 문제였다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNQCKU6FpLklbn9HwlXNB15z8k77FNAGe0aGtURuUgAQxxwBdQD5RP_qiE5wrluKo6XwD61r9x3JbIxnQlpzdIxb-tl4Q=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Restart 하는 방법은 먼저 상단의 <code class="language-plaintext highlighter-rouge">File</code>에서<br />
<code class="language-plaintext highlighter-rouge">Invaildate Caches</code>를 눌러준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOq9qiFokRYmFR5OoFF3OVqGXqXL1QiRwBXUhE_PPCn1IiFPqGfYuDBF-wnApzQ99xla-dQA1B9WteBeCJ0OUEi3uGhUw=w1512-h864" alt="image" class="align-left" style="max-width: 60%" /></p>

<p>그리고 <code class="language-plaintext highlighter-rouge">INVALIDATE AND RESTART</code> 버튼을 눌러주면 된다.<br />
그러면 IDE가 자동적으로 재시작될 것이고<br />
스프링 부트실행시 해당 에러는 발생하지않고, 정상적으로 <br />
환경변수의 값을 가져오는 것이 확인이 가능하다.</p>

<p>실제로 출력해서 확인해보고 싶을 경우</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtTokenizer</span> <span class="o">{</span>

    <span class="nd">@Getter</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${jwt.secret-key}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">secretKey</span><span class="o">;</span>

    <span class="o">...</span> <span class="n">중간</span> <span class="n">생략</span>
    
    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">secretKey</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span> <span class="n">이하</span> <span class="n">생략</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Spring Boot 실행시 출력으로 값을 확인해 볼 수 있다.</p>

<p>혹은 실제로 환경변수를 클래스를 이용해 가져오고 싶다면</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtTokenizer</span> <span class="o">{</span>
    
    <span class="o">...</span> <span class="n">이상</span> <span class="n">생략</span>
            
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Environment</span> <span class="n">environment</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">JwtTokenizer</span><span class="o">(</span><span class="nc">Environment</span> <span class="n">environment</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"JWT_SECRET_KEY"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="o">...</span> <span class="n">이하</span> <span class="n">생략</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">import org.springframework.core.env.Environment;</code> 패키지를 improt하여<br />
<code class="language-plaintext highlighter-rouge">.getProperty();</code> 메서드로 환경변수를 가져올 수 있다.</p>

<p><br /></p>

<hr />

<p><strong>기타 정보(Shell 변경)</strong></p>

<p>만약 zsh, bash를 변경해보고 싶으신 분은<br />
1). zsh를 기본으로 사용하고 싶은경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chsh <span class="nt">-s</span> /bin/zsh
</code></pre></div></div>

<p>2). bash를 기본으로 사용하고 싶은경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chsh <span class="nt">-s</span> /bin/bash
</code></pre></div></div>
<p>입력후 현재 노트북 비밀번호를 입력해주시면 됩니다.</p>

<hr />]]></content><author><name>LEE JAEHYEOK</name></author><category term="Spring" /><category term="Spring" /><category term="zsh" /><summary type="html"><![CDATA[오늘은 내가 겪은 환경변수에 관련된 설정과 오류를 기록해보려고한다.]]></summary></entry><entry><title type="html">TIL) OAuth 2 인증 기초</title><link href="http://localhost:4000/til/2022/11/25/til.html" rel="alternate" type="text/html" title="TIL) OAuth 2 인증 기초" /><published>2022-11-25T00:00:00+09:00</published><updated>2022-11-25T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/25/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/25/til.html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPDuT8mojlcwDj4isWJwyJvwaEPSsequtCg9insTbysDEVk6R7VRiRwBIm8ta5JK6J4r7ZDnBUypheW5SWHioLCJ0f8=w1920-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이번주는 정말 게으르게 보낸 것 같다.</p>

<p>물론 옛날에 비하면 엄청난 발전이지만… 역시 한번 쉬면<br />
계속 쉬고 싶은 마음이 생겨서,, 조금 게으르게 학습한 느낌을 받았다.</p>

<p>다시한번 각성하여 Spring 세션을 잘 마무리 해보자.</p>

<hr />

<h2 id="oauth-2">OAuth 2</h2>

<h3 id="oauth-2-란">OAuth 2 란?</h3>

<p>흔히 생각해보면, 우리가 웹사이트 로그인을 할때<br />
소셜 로그인(구글,카카오톡 등) 인증방식을 사용해 로그인을 하는데<br />
이런 인증방식들은 OAuth2라는 기술을 바탕으로 구현이 된다.</p>

<p>우리가 알고 있는 일반적인 애플리케이션은<br />
서비스를 이용하는 사용자에 대한 인증처리는 해당 애플리케이션이 직접했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOtOEbcjSRPGtg0QXyV8y1h1SCQegF3vUKPYwVCv7sEcPex_-9W-jvRfU7gcNry-watl1K_E1i57hcZE0mSkiSjOoVg=w1920-h921" alt="image" class="align-left" style="max-width: 80%" /><br />
<strong><em>- 크리덴셜을 저장하지 않는 아키텍처 -</em></strong></p>

<p>OAuth2 인증 프토토콜은 특정 애플리케이션에서 사용자의 인증을 직접<br />
처리하는 것이아니라 사용자 정보를 보유하고 있는 신뢰할 만한 써드 파티<br />
애플리케이션(구글,카카오톡 등)에서 인증을 대신 처리해주고 Resource에 대한<br />
자격 증명용 토큰을 발급한후, Client가 해당토큰을 이용해 써드파티 애플리케이션의<br />
서비스를 사용하게 해주는 방식이다.</p>

<p><br /></p>

<p><strong>*써드 파티(3rd Party)란?</strong><br />
프로그래밍을 도와주는 라이브러리를 만드는 외부 생산자를 뜻한다.</p>

<p>1st 파티 개발자 : 하드웨어 생상자가 ‘직접’ 소프트웨어를 개발하는 경우<br />
2nd 파티 개발자 : 하드웨어 생산지인 기업과 자사간의 관계에 속한 소프트웨어 개발자<br />
3rd 파티 개발자 : 아무 관련없는 제3자 소프트웨어 개발자<br />
이렇게 예를 들어볼 수 있을 것 같다.</p>

<p><br /></p>

<h3 id="oauth-2-인증-컴포넌트-역할">OAuth 2 인증 컴포넌트 역할</h3>

<p>시작에 앞서 OAuth 2 인증을 처리하는 <br />
컴포넌트들이 무엇이 있고 어떠한 역할을하는지 알아보자</p>

<ol>
  <li>Resource Owner<br />
-&gt; 사용하고자 하는 Resource의 소유자를 의미한다.</li>
  <li>Client<br />
-&gt; Resource Owner를 대신해 보호된 Resource에 엑세스하는 애플리케이션</li>
  <li>Resource Server<br />
-&gt; Client의 요청을 수락하고 Resource Owner에 해당하는 Resource를 제공하는 서버</li>
  <li>Authorization Server<br />
-&gt; Clinet가 Resource Server에 접근할 수 있는 권한을 부여하는 서버</li>
</ol>

<p>이렇게 글로만 정리하자면 사실 이해하기 힘들 것이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOuRXi0z_GnyDCCDHETh73m4ATTFc7XkcLLrbwxEbd_Rd71mekz5lc9oxBxt5WGwp-6BLNg3GiMQ4jErSdSRIpCvj3kkw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>대략적인 역할을 보면 이렇게 나눠볼 수 있을 것 같다.<br />
기존에 우리가 불러오던 Client가 웹 애플리케이션 서버로<br />
변경된 모습을 볼 수 있다.</p>

<p>Resource Owner의 대리인으로써 구글에 인증과 Resource를<br />
요청하고 있기때문에 Client라고 부를 수 있다</p>

<p><br /></p>

<h3 id="authorization-grant-유형">Authorization Grant 유형</h3>
<p>Authorization Grant는 Client 애플리케이션이 Access Token을<br />
얻기 위한 Resource Owner의 권한을 표현하는 크리덴셜(Credential)을 의미한다.</p>

<p>즉, Access Token을 얻기 위한 수단이다.</p>

<p><strong><em>*Access Token 이란?<br />
Client가 Resource Server에 보호된 Resource에<br />
엑세스하기 위해 사용하는 자격 증명용 토큰이다.</em></strong></p>

<p><br /></p>

<p>총 4가지의 타입이 있으니 알아보자</p>

<p><strong>1). Authorization Code Grant (권한부여 승인 코드 방식)</strong> <br />
-. 가장 많이 쓰이는 방법이고 기본이 되는 방식이다.<br />
-. 권한 부여 승인을 위해 자체 생성한 Authorization Code를 전달하는 방식이다.<br />
-. Refresh Token을 사용할 수 있다.<br />
-. 권한 부여 승인 요청시 응답 타입을 <code class="language-plaintext highlighter-rouge">code</code>로 지정하여 요청한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPgVHuUuCDajpaRydkqDrMFvzkbLFg3gep5w9RB8biTR9VOow-YfScef_SaV6QJH5cGhGZwcx6giLOKPrAC4ppHoW1TNQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<p><strong>2). Implicit Grant (암묵적 승인 방식)</strong><br />
-. 별도의 Authorization Code 없이 바로 Access Token을 발급받는 방식이다.<br />
-. 자격증명을 안전하게 저장하기 힘든 Client에게 최적화된 방식이다.<br />
-. Refresh Token 사용이 불가능하다.<br />
-. 권한 부여 승인 요청시 응답타입을 <code class="language-plaintext highlighter-rouge">token</code>으로 지정하여 요청한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMa7L3zIQi3fKSZII9kd56k64SdaQpQJjnDrCev_ByGw1cuJYu3r61IXE0Ubx-pNNUJKs9tkNeOeQmBFZnGtOLekTEQCg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<p><strong>3). Resource Owner Password Credential Grant (자원 소유자 자격증명 승인방식)</strong><br />
-. 로그인 시 필요한 정보로 Access Token을 발급 받는 방식이다.<br />
-. 자신의 서비스에서 제공하는 애플리케이션의 경우에만 사용되는 인증 방식이다.<br />
(Authorization Server, Resource Server, Client가 모두 같은 시스템에 속해있을 경우에만 가능)<br />
-. Refresh Token 사용이 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMijQTmGrLYDoKw37n3jPJRqt5i6JjFcp8XeFprwPcptgPdHdPvhscdpyh52SFQHU7ju84XmIWMYyJIR6TYVznjIuPpsw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<p><strong>4). Client Credentials Grant (클라이언트 자격증명 승인방식)</strong><br />
-. Client 자신이 관리하는 Resource, Authorization Server에 해당 Client를 위한<br />
제한된 Resource 접근 권한이 설정되어 있을 경우 사용 가능한 방식이다.<br />
-. Refresh Token의 사용이 불가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOmLKEo6UjsefDdk3MWt5D0fLVXTDfA9dnjjHZibE6A55PjTKLDzqBn-NZTS3WsK-6ojytFXEXqtgqkjvuTIclhg3RH4w=w1299-h921" alt="image" class="align-left" style="max-width: 90%" /></p>

<p><br /></p>

<h3 id="사전-준비">사전 준비</h3>
<p>위에서 얘기했듯이 우리는 써드파티 애플리케이션 중<br />
OAuth 2 인증 프로토콜을 제공하는 벤더(구글, 카카오톡, 페이스북 등)를<br />
선정 한다음 프로그램을 작성해야한다.</p>

<p>그중 위에서 예로든 구글의 OAuth 2 프로토콜을 이용해볼 예정이고<br />
프로그램 작성 전에 먼저 클라이언트 ID와 Secret를 생성해야한다.<br />
<a href="http://yoonbumtae.com/?p=2631">구글 API 콘솔에서의 OAuth 2 설정 - 출처: yoonbumtae님</a>을 보고<br />
클라이언트 ID와 Secret를 생성하면 준비는 끝난다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO3kkRX35q-9PPahcVGwcdd2LGECoC7sez4uGlFClTNsVllR01dQocyQJSuF42Ej0tF7n3FIYHclCxtaNIefADUtJgiJw=w1920-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<hr />

<p>오늘은 OAuth 2 에대한 간단한 지식을 알아봤다.<br />
사실 이론만 보기에는 코드를 보지않아서<br />
느낌이 확 와닿지는 않는다…</p>

<p>하지만 큰그림을 보고 코드를 보면 더 눈에 잘들어오기 때문에<br />
큰 아키텍처를 생각하고 코드를 다움주부터 연습을 해봐야겠다.</p>

<p>오늘 공부는 여기서 끝 !</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김밥, 된장찌개</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL) Spring Security, JWT 사용하여 인증하기</title><link href="http://localhost:4000/til/2022/11/24/til.html" rel="alternate" type="text/html" title="TIL) Spring Security, JWT 사용하여 인증하기" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/24/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/24/til.html"><![CDATA[<p>날씨가 많이 쌀쌀해졌다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOtphG8edbKbbvSASKsJ_-tJ0REdmM2lcBp23tquh_bZGuSnGZt9pJIqpz7InTIiLhjrD7ZaBJzmsPBW69wtFDH28VC=w3024-h1728" alt="image" class="align-left" style="max-width: 60%" /></p>

<p>요즘 학습량이 늘어나 새벽까지 공부하다보니<br />
컨디션 난조가 심하다.. 일찍자려고해도<br />
어떻게 하다보니까 해야할 것들이 밀려 늦게 잠을 청하게된다.</p>

<p>그러다보니 아침,점심에 정신을 못차리고 공부를 제대로 못하는..<br />
악순환의 반복이다. 오늘은 최대한 일찍 공부를 마치고<br />
월드컵도 시작이니 일찍 잠을 자야겠다.</p>

<hr />

<p>어제 <a href="https://mycatlikeschuru.github.io/til/2022/11/23/til.html">JWT 기초</a> 파트에서 JWT에 대해 기초지식을<br />
공부했었고, 실제로 AcessToken, RefreshToken을 만들어보기도 했다.</p>

<p>이제 JWT 토큰을 만드는 방법을 알았으니<br />
이 토큰을 어떻게 Headers로 전송하고<br />
Spring Security를 이용해 인증과정을 거치게 되는지? 에 대한<br />
내용을 오늘 공부해보려 한다.</p>

<h2 id="jwt를-이용한-spring-security-인증">JWT를 이용한 Spring Security 인증</h2>

<h3 id="어떻게-인증을하지">어떻게 인증을하지?</h3>

<p>우선 <a href="https://mycatlikeschuru.github.io/til/2022/11/21/til.html">Spring Security 인증처리</a>에 대한<br />
선수지식을 가지고 있어야 해당 내용을 이해할 수 있다.</p>

<p>JWT를 사용하여 인증을 진행하려면<br />
기존에 인증처리에서 사용하는 <code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code>를<br />
비활성화로 변경한 후에 상속받아 클래스를 구현해 인증을 처리해줄 수 있다.<br />
(구현하는건 이제부터 개발자가 해야하는 영역)</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOQR4FMzSp9LHOptJF9_XBX4UQULmx47cZIefY8NeWpgeh2vTm3_WS04sbLy7xWlLrtlt4FbZfxdTdk501lzUyEOSykZQ=w1299-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그림으로 한번 정리해보자.</p>

<p><code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code>를 상속받는<br />
<code class="language-plaintext highlighter-rouge">JwtAuthenticationFilter</code> 라는 클래스를 만들어 구현할 것이다.<br />
그리고 우리가 구현한 필터는 등록해놓아야하고, 기존의 <br />
<code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code> 필터는 비활성화해줘야한다.</p>

<p>구현할때 유의할점은 인증을 총괄하는 <code class="language-plaintext highlighter-rouge">AuthenticationManager</code>의<br />
<code class="language-plaintext highlighter-rouge">.authenticate();</code>메서드를 이용해 인증 처리를 위임해줘야한다.<br />
그러면 우리가 자주보았던 인증처리 흐름대로 코드가 진행되고</p>

<p>Spring Security에서 구현했던 <code class="language-plaintext highlighter-rouge">UserDetails</code> 객체를 만들어서<br />
<code class="language-plaintext highlighter-rouge">.loadUserByUsername();</code>메서드 호출시 반환만 해주면<br />
구현하는 부분은 끝난다.</p>

<p>그리고 인증완료된 객체가 돌아오면, JWT를 생성 후 클라이언트에<br />
Response Header에 담아 보내주면된다.</p>

<p><br /></p>

<p>다시 한번 정리해보자면 <br />
<code class="language-plaintext highlighter-rouge">JwtAuthenticationFilter</code> 이름으로 JWT Filter를 하나 만들 것이다.<br />
<code class="language-plaintext highlighter-rouge">AbstractAuthenticationProcessingFilter</code>추상 클래스를 에서 filter가 시작된다.<br />
<code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code> 클래스를 상속하면, 위에 추상클래스도<br />
상속관계이기때문에 Overriding하여 구현할 수 있다.</p>

<p>Overriding한 메서드를 구현해야하는데 2가지를 구현해야한다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">attemptAuthentication();</code> 메서드 구현<br />
-&gt; 인증을 위임해주고 인증처리 완료된 객체가 반환되는 메서드이므로<br />
인증과 관련된 정보를 넘겨주는 것을 구현해야함.</li>
  <li><code class="language-plaintext highlighter-rouge">successfulAuthentication();</code> 메서드 구현<br />
-&gt; 인증 완료 후 JWT 토큰을 만들어 Header에 담아주는 클래스를 구현해야함<br />
-&gt; Security Context에 저장하는 부분은 추후 JWT 비교필터에서 추가</li>
</ol>

<p><br /></p>

<h3 id="코드로-한번-확인해-보자-">코드로 한번 확인해 보자 !</h3>

<h4 id="1-jwtauthenticationfilter-구현">1). JwtAuthenticationFilter 구현</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtAuthenticationFilter</span> <span class="kd">extends</span> <span class="nc">UsernamePasswordAuthenticationFilter</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AuthenticationManager</span> <span class="n">authenticationManager</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">JwtAuthenticationFilter</span><span class="o">(</span><span class="nc">AuthenticationManager</span> <span class="n">authenticationManager</span><span class="o">,</span> <span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">authenticationManager</span> <span class="o">=</span> <span class="n">authenticationManager</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">jwtTokenizer</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="nd">@SneakyThrows</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Authentication</span> <span class="nf">attemptAuthentication</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
        <span class="nc">LoginDto</span> <span class="n">loginDto</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">(),</span> <span class="nc">LoginDto</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// ServletInputSteam 을 LoginDto 클래스 객체로 역직렬화</span>

        <span class="nc">UsernamePasswordAuthenticationToken</span> <span class="n">authenticationToken</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UsernamePasswordAuthenticationToken</span><span class="o">(</span><span class="n">loginDto</span><span class="o">.</span><span class="na">getUsername</span><span class="o">(),</span> <span class="n">loginDto</span><span class="o">.</span><span class="na">getPassword</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">authenticationManager</span><span class="o">.</span><span class="na">authenticate</span><span class="o">(</span><span class="n">authenticationToken</span><span class="o">);</span>
    <span class="o">}</span> 
    
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">successfulAuthentication</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">chain</span><span class="o">,</span> <span class="nc">Authentication</span> <span class="n">authResult</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Member</span><span class="o">)</span> <span class="n">authResult</span><span class="o">.</span><span class="na">getPrincipal</span><span class="o">();</span>

        <span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="n">delegateAccessToken</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// accessToken 만들기</span>
        <span class="nc">String</span> <span class="n">refreshToken</span> <span class="o">=</span> <span class="n">delegateRefreshToken</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// refreshToken 만들기</span>

        <span class="nc">String</span> <span class="n">headerValue</span> <span class="o">=</span> <span class="s">"Bearer "</span><span class="o">+</span> <span class="n">accessToken</span><span class="o">;</span>

        <span class="n">response</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Authorization"</span><span class="o">,</span><span class="n">headerValue</span><span class="o">);</span> <span class="c1">// Header에 등록</span>
        <span class="n">response</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Refresh"</span><span class="o">,</span><span class="n">refreshToken</span><span class="o">);</span> <span class="c1">// Header에 등록</span>

        <span class="k">this</span><span class="o">.</span><span class="na">getSuccessHandler</span><span class="o">().</span><span class="na">onAuthenticationSuccess</span><span class="o">(</span><span class="n">request</span><span class="o">,</span><span class="n">response</span><span class="o">,</span><span class="n">authResult</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">delegateAccessToken</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">){</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">claims</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">claims</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span><span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
        <span class="n">claims</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"roles"</span><span class="o">,</span><span class="n">member</span><span class="o">.</span><span class="na">getRoles</span><span class="o">());</span>

        <span class="nc">String</span> <span class="n">subject</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">();</span>
        <span class="nc">Date</span> <span class="n">expiration</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getTokenExpiration</span><span class="o">(</span><span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getAccessTokenExpirationMinutes</span><span class="o">());</span>

        <span class="nc">String</span> <span class="n">base64EncodedSecretKey</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">encodeBase64SecretKey</span><span class="o">(</span><span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getSecretKey</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">generateAccesToken</span><span class="o">(</span><span class="n">claims</span><span class="o">,</span> <span class="n">subject</span><span class="o">,</span> <span class="n">expiration</span><span class="o">,</span> <span class="n">base64EncodedSecretKey</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">accessToken</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">delegateRefreshToken</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">){</span>
        <span class="nc">String</span> <span class="n">subject</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">();</span>
        <span class="nc">Date</span> <span class="n">expiration</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getTokenExpiration</span><span class="o">(</span><span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getRefreshTokenExpirationMinutes</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">base64EncodedSecretKey</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">encodeBase64SecretKey</span><span class="o">(</span><span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getSecretKey</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">refreshToken</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">generateRefreshToken</span><span class="o">(</span><span class="n">subject</span><span class="o">,</span> <span class="n">expiration</span><span class="o">,</span> <span class="n">base64EncodedSecretKey</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">refreshToken</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>해당 코드에서 유의 깊게 봐야할 부분은 <code class="language-plaintext highlighter-rouge">JwtAuthenticationFilter</code>클래스를 만들었고<br />
extend로 <code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code> 클래스를 상속받고<br />
@Overriding 하여 <code class="language-plaintext highlighter-rouge">attemptAuthentication();</code>와 <code class="language-plaintext highlighter-rouge">successfulAuthentication();</code> 메서드를<br />
구현하는 코드를 작성 중이다. 위에서 그림으로 보았던 부분이다.</p>

<p>구현 내용을 살펴보면
<code class="language-plaintext highlighter-rouge">attemptAuthentication();</code> 메서드는 <br />
우리가 기존에 Form Login으로 파라미터를 가져오고 Authentication 객체를 만들어<br />
<code class="language-plaintext highlighter-rouge">authenticate();</code> 메서드로 인증 처리 위임을 시작해주는 부분이다.<br />
Form Login 방식을 쓰지않고, 클라이언트 쪽에서 JSON 객체로</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"username"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"dhfif718@naver.com"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"password"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"1111"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>로그인 인증 정보를 이렇게 보내줄 것이다.<br />
그렇기 때문에 <code class="language-plaintext highlighter-rouge">attemptAuthentication();</code> 메서드를 구현한 것이고<br />
받은 JSON 객체는 <code class="language-plaintext highlighter-rouge">request.getInputStream();</code>으로 꺼낼 수 있다.<br />
위에서는 <code class="language-plaintext highlighter-rouge">ObjectMapper</code> 클래스를 이용해 Dto를 하나 만들어<br />
맵핑하여 값을 저장해 주었다. 그리고 저장해준 데이터를 가지고 Authentication 객체를 만들었다.</p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">successfulAuthentication();</code>메서드는<br />
인증된 객체가 넘어왔을 것이고, 인증된 객체 <code class="language-plaintext highlighter-rouge">authResult</code>는<br />
이전에 Spring Security 사용할 때 <code class="language-plaintext highlighter-rouge">UserDetails</code> 객체를 반환해 구현했었다.<br />
실제 구현할때 <code class="language-plaintext highlighter-rouge">UserDetails</code>를 <code class="language-plaintext highlighter-rouge">Member</code> 클래스를가 상속하도록 구현해서<br />
<code class="language-plaintext highlighter-rouge">authResult.getPrincipal();</code>메서드로 Down Casting하여 Member 객체를<br />
가져올 수 있게되는 것이다.</p>

<p>이렇게 가져온 <code class="language-plaintext highlighter-rouge">Member</code> 객체를 활용해서 AccessToken과 RefreshToken을 만들어<br />
<code class="language-plaintext highlighter-rouge">response.setHeader();</code> 메서드를 활용해 HEADER에 값을 추가할 수 있다.<br />
HEADER에 까지 정상적으로 넣었으면 <code class="language-plaintext highlighter-rouge">.onAuthenticationSuccess();</code>를 호출해<br />
성공적으로 인증된 객체를 만들었다고 알리고, 다음 Filter를 진행하게 된다.</p>

<p>여기까지 보았을때 한가지 의아한 점을 찾을 수 있다.<br />
공부했던 인증 처리흐름에 마지막은 <code class="language-plaintext highlighter-rouge">Security Context</code>에 저장을해야<br />
나중에 권한부여를 할때 <code class="language-plaintext highlighter-rouge">Security Context</code>에서 꺼낼 수 있는데 <br />
이부분을 구현하지 않았던점을 의아해할 수 있다.</p>

<p>해당부분은 다음 Filter에서 처리할 것이다.<br />
그럼 다음 추가할 Filter를 알아보자</p>

<p><br /></p>

<h4 id="2-jwtverificationfilter-구현">2). JwtVerificationFilter 구현</h4>
<p>해당 필터는 이전에 필터 <code class="language-plaintext highlighter-rouge">JwtAuthenticationFilter</code>의 다음 Filter로<br />
우리가 구현하는 새로운 Filter 클래스이다.</p>

<p>해당 필터의 역할은 넘어온 JWT에 대한 검증과<br />
검증이 완료된 Authentication 객체를 <code class="language-plaintext highlighter-rouge">Security Context</code>에<br />
저장하는 역할을 구현해주는 클래스이다.</p>

<p>여기서 한가지 중요한점은 <code class="language-plaintext highlighter-rouge">Security Context</code>에 저장은 하지만<br />
Session 방식을 사용하지 않는 형식으로 <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code>에서 설정할 것이다.<br />
그래야 JWT를 사용하는 목적과 맞기 때문이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtVerificationFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CustomAuthorityUtils</span> <span class="n">authorityUtils</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">JwtVerificationFilter</span><span class="o">(</span><span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">,</span> <span class="nc">CustomAuthorityUtils</span> <span class="n">authorityUtils</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">jwtTokenizer</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">authorityUtils</span> <span class="o">=</span> <span class="n">authorityUtils</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/*
    * 필터 추가, JWT 객체를 꺼내서 비교후 SecurityContext에 저장함
    * */</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 예외처리 추가</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">claims</span> <span class="o">=</span> <span class="n">verifyJws</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
            <span class="n">setAuthenticationToContext</span><span class="o">(</span><span class="n">claims</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SignatureException</span> <span class="n">se</span><span class="o">){</span>
            <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"exception"</span><span class="o">,</span><span class="n">se</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ExpiredJwtException</span> <span class="n">ex</span><span class="o">){</span>
            <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"exception"</span><span class="o">,</span><span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">request</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"exception"</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 다음 Filter 실행</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span><span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>

     <span class="cm">/*
     * 만약 request에 전달받은 authorization이 없으면 해당 필터는 실행안함
     * */</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">shouldNotFilter</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">authorization</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Authorization"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">authorization</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">authorization</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"Bearer"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*
    * request 객체로 claims 객체 꺼내는 메서드
    * */</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">verifyJws</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">){</span>
        <span class="nc">String</span> <span class="n">jws</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getHeader</span><span class="o">(</span><span class="s">"Authorization"</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">"Bearer "</span><span class="o">,</span><span class="s">""</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">base64EncodedSecretKey</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">encodeBase64SecretKey</span><span class="o">(</span><span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getSecretKey</span><span class="o">());</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span> <span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">claims</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">getClaims</span><span class="o">(</span><span class="n">jws</span><span class="o">,</span> <span class="n">base64EncodedSecretKey</span><span class="o">).</span><span class="na">getBody</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">claims</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/*
    * SecurityContext에 저장하는 부분
    * */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setAuthenticationToContext</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">claims</span><span class="o">){</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">claims</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">);</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">GrantedAuthority</span><span class="o">&gt;</span> <span class="n">authorities</span> <span class="o">=</span> <span class="n">authorityUtils</span><span class="o">.</span><span class="na">createAuthorities</span><span class="o">((</span><span class="nc">List</span><span class="o">)</span><span class="n">claims</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"roles"</span><span class="o">));</span>

        <span class="nc">Authentication</span> <span class="n">authentication</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UsernamePasswordAuthenticationToken</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">authorities</span><span class="o">);</span>
        <span class="nc">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">setAuthentication</span><span class="o">(</span><span class="n">authentication</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>해당 클래스는 생각보다 간단하다.<br />
우선 <code class="language-plaintext highlighter-rouge">OncePerRequestFilter</code>를 상속받아 필터로 사용하는 클래스이다.<br />
사용자 한번의 요청에 딱한번만 실행하는 필터이고 <a href="https://minkukjo.github.io/framework/2020/12/18/Spring-142/">minkukjo님의 블로그</a>를 참고하면 좋을 것 같다.</p>

<p>우리는 로그인할때 JWT토큰을 HEADER에 싦어 클라이언트에 발행해 줬다.<br />
이제 만약 클라이언트에서 어떠한 요청이 있다고 가정할때 HEADER Access Token을 보내면<br />
request 객체를 이용해서 HEADER에서 JWT를 가져와서, 우리가 기존에 만들어둔<br />
<code class="language-plaintext highlighter-rouge">.getClamis();</code>메서드를 이용해 비교후 claims 객체를 가져올 수 있다.</p>

<p>만약 토큰이 만료시간이 다되었거나 서명형식이 틀렸다거나하면<br />
예외가 발생하면서 JWT 인증이 되었다고 판단하지않아 <br />
다음 필터를 진행하게 된다. 여기서 다음 필터를 진행하게 되면 <code class="language-plaintext highlighter-rouge">Security Context</code>에는<br />
아무런 객체가 없기때문에 권한확인하는 필터에서 인가가 되지 않는다.</p>

<p>즉, 우리가 발행한 Access Token과 일치하는 지 확인한다음<br />
<code class="language-plaintext highlighter-rouge">Security Context</code>에 인증된 객체를 저장해주는 필터 클래스이다.<br />
만약 일치하지않거나 예외가 발생하면 <code class="language-plaintext highlighter-rouge">Security Context</code>에 객체를<br />
저장하지 않고 다음 Filter로 넘어가는 방식이다.</p>

<p>이렇게 까지만 구현하면 JWT 관련해서 발행과, 인증에 대한<br />
구현 부분은 끝났다. 이제 우리가 마지막으로 해줘야할 부분은<br />
Spring SecurityFilterChain에 설정정보를 설정하는일만 남았다.</p>

<p><br /></p>

<h4 id="3-spring-security-filterchain-설정">3). Spring Security FilterChain 설정</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span><span class="o">(</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfigurationV6</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CustomAuthorityUtils</span> <span class="n">authorityUtils</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">SecurityConfigurationV6</span><span class="o">(</span><span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">,</span> <span class="nc">CustomAuthorityUtils</span> <span class="n">authorityUtils</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">jwtTokenizer</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">authorityUtils</span> <span class="o">=</span> <span class="n">authorityUtils</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">http</span>
                <span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">frameOptions</span><span class="o">().</span><span class="na">sameOrigin</span><span class="o">()</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">csrf</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span>
                <span class="o">.</span><span class="na">cors</span><span class="o">(</span><span class="nc">Customizer</span><span class="o">.</span><span class="na">withDefaults</span><span class="o">())</span> <span class="c1">// corsConfigurationSource라는 이름으로 등록된 Bean을 사용한다고 정의</span>
                <span class="o">.</span><span class="na">sessionManagement</span><span class="o">().</span><span class="na">sessionCreationPolicy</span><span class="o">(</span><span class="nc">SessionCreationPolicy</span><span class="o">.</span><span class="na">STATELESS</span><span class="o">)</span> <span class="c1">// 세션 정책 추가 (JWT사용으로 STATELESS로 설정)</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">formLogin</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span> <span class="c1">// CSR 방식사용으로 formLogin 비활성화</span>
                <span class="o">.</span><span class="na">httpBasic</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span> <span class="c1">// UsernamePasswordAuthenticationFilter 등 비활성화</span>
                <span class="o">.</span><span class="na">exceptionHandling</span><span class="o">()</span> <span class="c1">// 예외처리 기능이 작동</span>
                <span class="o">.</span><span class="na">authenticationEntryPoint</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberAuthenticationEntryPoint</span><span class="o">())</span>  <span class="c1">// 인증 실패시 처리</span>
                <span class="o">.</span><span class="na">accessDeniedHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberAccessDeniedHandler</span><span class="o">())</span> <span class="c1">// 인증 실패시 처리</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">new</span> <span class="nc">CustomFilterConfigurer</span><span class="o">())</span> <span class="c1">// 커스터마이징한 필터를 추가할 수 있음</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">(</span><span class="n">authorize</span> <span class="o">-&gt;</span> <span class="n">authorize</span>
                        <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="nc">HttpMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">,</span> <span class="s">"/*/members"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span>
                        <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="nc">HttpMethod</span><span class="o">.</span><span class="na">PATCH</span><span class="o">,</span> <span class="s">"/*/members/**"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="nc">HttpMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">,</span> <span class="s">"/*/members"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="nc">HttpMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">,</span> <span class="s">"/*/members/**"</span><span class="o">).</span><span class="na">hasAnyRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">,</span> <span class="s">"ADMIN"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="nc">HttpMethod</span><span class="o">.</span><span class="na">DELETE</span><span class="o">,</span> <span class="s">"/*/members/**"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">anyRequest</span><span class="o">().</span><span class="na">permitAll</span><span class="o">()</span>
                <span class="o">);</span>
        <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">PasswordEncoder</span> <span class="nf">passwordEncoder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">PasswordEncoderFactories</span><span class="o">.</span><span class="na">createDelegatingPasswordEncoder</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/*
    * 구체적인 CORS 정책을 설정
    * */</span>
    <span class="nd">@Bean</span>
    <span class="nc">CorsConfigurationSource</span> <span class="nf">corsConfigurationSource</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">CorsConfiguration</span> <span class="n">configuration</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CorsConfiguration</span><span class="o">();</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowedOrigins</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"*"</span><span class="o">));</span> <span class="c1">// 스크림트 기반의 HTTP 통신을 허용</span>
        <span class="n">configuration</span><span class="o">.</span><span class="na">setAllowedMethods</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"GET"</span><span class="o">,</span><span class="s">"POST"</span><span class="o">,</span> <span class="s">"PATCH"</span><span class="o">,</span> <span class="s">"DELETE"</span><span class="o">));</span> <span class="c1">// HTTP Method에 대한 HTTP 통신 허용</span>

        <span class="nc">UrlBasedCorsConfigurationSource</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UrlBasedCorsConfigurationSource</span><span class="o">();</span> <span class="c1">// CorsConfigurationSource 구현체 생성</span>
        <span class="n">source</span><span class="o">.</span><span class="na">registerCorsConfiguration</span><span class="o">(</span><span class="s">"/**"</span><span class="o">,</span> <span class="n">configuration</span><span class="o">);</span> <span class="c1">// 모든 URL에 정책 적용</span>
        <span class="k">return</span> <span class="n">source</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomFilterConfigurer</span> <span class="kd">extends</span> <span class="nc">AbstractHttpConfigurer</span><span class="o">&lt;</span><span class="nc">CustomFilterConfigurer</span><span class="o">,</span><span class="nc">HttpSecurity</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">builder</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
            <span class="nc">AuthenticationManager</span> <span class="n">authenticationManager</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">getSharedObject</span><span class="o">(</span><span class="nc">AuthenticationManager</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// AuthenticationManager 객체얻기</span>

            <span class="nc">JwtAuthenticationFilter</span> <span class="n">jwtAuthenticationFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JwtAuthenticationFilter</span><span class="o">(</span><span class="n">authenticationManager</span><span class="o">,</span> <span class="n">jwtTokenizer</span><span class="o">);</span> <span class="c1">// JwtAuthenticationFilter 객체만들기 (생성하면서 DI하기)</span>

            <span class="c1">// 상속받은 AbstractAuthenticationProcessingFilter 클래스의 FilterProcessesUrl 설정해주기 (설정안할시 default: /Login)</span>
            <span class="c1">// 즉, 로그인 요청할때 이 Url로 요청해야함, 우리가 기존에 UsernamePassword 필터 사용시에는 /process_login 하던부분임</span>
            <span class="n">jwtAuthenticationFilter</span><span class="o">.</span><span class="na">setFilterProcessesUrl</span><span class="o">(</span><span class="s">"/v11/auth/login"</span><span class="o">);</span>
            <span class="c1">// Exception 추가</span>
            <span class="n">jwtAuthenticationFilter</span><span class="o">.</span><span class="na">setAuthenticationSuccessHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberAuthenticationSuccessHandler</span><span class="o">());</span>
            <span class="n">jwtAuthenticationFilter</span><span class="o">.</span><span class="na">setAuthenticationFailureHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberAuthenticationFailureHandler</span><span class="o">());</span>

            <span class="nc">JwtVerificationFilter</span> <span class="n">jwtVerificationFilter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JwtVerificationFilter</span><span class="o">(</span><span class="n">jwtTokenizer</span><span class="o">,</span> <span class="n">authorityUtils</span><span class="o">);</span>

            <span class="c1">// Spring Security FilterChain에 추가</span>
            <span class="n">builder</span><span class="o">.</span><span class="na">addFilter</span><span class="o">(</span><span class="n">jwtAuthenticationFilter</span><span class="o">)</span>  <span class="c1">// 우리가만든 jwtAuthenticationFilter 필터추가</span>
                    <span class="o">.</span><span class="na">addFilterAfter</span><span class="o">(</span><span class="n">jwtVerificationFilter</span><span class="o">,</span> <span class="nc">JwtAuthenticationFilter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">//  jwtVerificationFilter 필터추가, 뒤에 클래스는 어느클래스 다음에 실행할지 설정</span>

        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이전에 Spring Security 설정과 크게 달라진 점은 3가지 정도 있다.</p>

<ol>
  <li>CORS 정책을 추가</li>
  <li>세션 정책 추가</li>
  <li>우리가 만든 Filter 추가</li>
  <li>예외처리에 대한 기능 추가</li>
</ol>

<p>이렇게 3가지에 대한 내용을 추가 설정해 주었다.
자세한 내용은 코드옆에 설명을 적어 놓았다.</p>

<p>여기서 세션정책관련해서는 아까 <code class="language-plaintext highlighter-rouge">SecurityContext</code>에 객체를 저장하지만<br />
STATELESS로 설정하여 서버에서 관리하지 않게 되어진다.<br />
즉, 무상태성으로 서버에서 관리하지 않는 것이다.</p>

<p>또한 예외처리를 위한 우리가 구현한 클래스들도 설정해놓았고<br />
Cors 정책관련해서도 Bean으로 등록해 추가해주었다.</p>

<p>그리고 마지막으로 사용자에 따른 페이지 권한에 대한 <br />
<code class="language-plaintext highlighter-rouge">antMatchers();</code>를 설정한 다음 마무리를 지었다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Security filter chain: [
  DisableEncodeUrlFilter
  WebAsyncManagerIntegrationFilter
  SecurityContextPersistenceFilter
  HeaderWriterFilter
  CorsFilter
  LogoutFilter
  JwtAuthenticationFilter
  JwtVerificationFilter
  RequestCacheAwareFilter
  SecurityContextHolderAwareRequestFilter
  AnonymousAuthenticationFilter
  SessionManagementFilter
  ExceptionTranslationFilter
  AuthorizationFilter
]
</code></pre></div></div>
<p>최종적으로 완성된 SecurityFilterChain 구성은<br />
보이는 것과 같이 <code class="language-plaintext highlighter-rouge">CorsFilter</code> 추가와<br />
<code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code>가 비활성화 되었고<br />
우리가 만들어준 필터 <code class="language-plaintext highlighter-rouge">JwtAuthenticationFilter</code>와 <code class="language-plaintext highlighter-rouge">JwtVerificationFilter</code>가<br />
추가된 모습을 콘솔로 확인이 가능하다. (@EnableWebSecurity(debug = true))</p>

<p><br /></p>

<p>이렇게 JWT 설정관련해서 주요하게 우리가 구현해야하는<br />
클래스를 설명했고 구현한 코드도 적어보았다.</p>

<p>구현했던 클래스 중 가장 중요한 클래스만 정리를 해두었고<br />
해당 클래스를 구현하기위해 보조로 필요한 예외처리 클래스라든가 등등..은<br />
따로 코드를 올리진 않았다는 점은 참고해주실 바란다.</p>

<p><br /></p>

<h3 id="jwt-예외관련">JWT 예외관련</h3>

<p>정상적인 JWT를 하나 만들었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM7CWzAFQjn80N1hvvM9SUK3D93K7v6MKWNbJ73maG_WsDGVAWRlzCA7i2-X3BqaLP0fLkeuY3__aTBsAL3k4TzG2hqqQ=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>해당 JWT를 가지고 값을 변경해보면서<br />
예외가 발생하는지 테스트를 해보았다.</p>

<p><br /></p>

<p><strong>1). ExpiredJwtException 예외</strong></p>

<p>JWT를 생성할 때 지정한 유효기간이 초과할때 발생하는 예외다</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>io.jsonwebtoken.ExpiredJwtException: JWT expired at 2022-11-24T07:28:32Z. Current time: 2022-11-24T07:31:05Z, a difference of 153263 milliseconds.  Allowed clock skew: 0 milliseconds.
</code></pre></div></div>

<p>로그인 요청을 할때, 우리는 JWT 토큰을 Header에 담아서 보내준다.<br />
토큰을 만들때는 만료시간을 설정하는데<br />
설정한 만료시간이 지났는데 리소스에 접근요청을 보내면 g해당 예외가 발생한다.</p>

<p><br /></p>

<p><strong>2). MalformedJwtException 예외</strong></p>

<p>JWT가 올바르게 구성되지 않았을때 발생하는 예외이다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>io.jsonwebtoken.MalformedJwtException: Malformed JWT JSON: 
</code></pre></div></div>
<p>실제로 구성을 바꿨을때 예외가 발생했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPQhIjSnqeeREeIFdpD_a2vMw-E6r_7tu74DY46aqKGtvdcc9GP-PTkbfKyKeUIqpUJJpGuPmCFdHGTJ8wPGEh_A-FrXg=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위의 사진처럼 Header의 맨앞부분을 변경했더니<br />
디코딩이 되지 않아 형식을 확인할 수 없는 문제가 생겼다.</p>

<p>실제로 JWT 홈페이지에서 사진처럼 디코딩을 해보면<br />
인코딩쪽에 형식이 맞지않아 빨간색으로 표시가 되는 것을 볼 수 있다.</p>

<p><br /></p>

<p><strong>3). SignatureException 예외</strong></p>

<p>JWT의 기존 서명을 확인하지 못했을 때 생기는 예외이다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>io.jsonwebtoken.security.SignatureException: Unsupported signature algorithm 'H{256'
</code></pre></div></div>
<p>실제로 서명을 확인하지 못할경우 위와 같이<br />
Exception이 발생한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM-B56_cW6Bvc86vXPTHrYxah_eJccUX-5yCNznSlZds4Ad2wCQ5-06B79zGh14djTNIyyEsiGiZofmUGLsX4T-oiVj=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>정상 JWT에서 Header 부분을 변경해 예외를 터트려보았다.<br />
형식이 깨지지 않는 선에서 서명이 확인되지 않으면<br />
발생하는 예외인 것 같다.</p>

<p>사진에서 볼 수 있는 것처럼 Header의 <code class="language-plaintext highlighter-rouge">'alg' : "H{256"</code>으로<br />
형식은 깨지지 않았으나, Header에 이상한 값이 들어가<br />
서명을 확인하지 못하는 경우가 발생한 것이다.</p>

<p><br /></p>

<hr />
<p>이렇게 오늘은 JWT를 통해 인증까지 해보는 작업을 해보았다.<br />
사실은 내가 정리하면서 맞게 적는지 엄청 코드를 반복적으로 확인하면서<br />
글을 써내려갔다. 조금 덜 정리된 부분이 많아서 아쉽지만<br />
나름 내가 코드를 분석하고 정리를 해보니 어느정도 감은 잡힌 것 같다.</p>

<p>오늘까지해서 JWT에 대한 내용은 끝났고<br />
실제로 내가 어드밴스한 내용을 구현하고 싶다면<br />
인증처리 흐름만 익힐게 아니라 내부의 코드들이 어떻게 구현되있는지<br />
완벽하게 이해하고 있어야 어드밴스한 구현이 가능할 듯 싶다.</p>

<p>오늘까지 공부하면서 많은 소득이 있었고<br />
큰 그림을 배웠고, 세부적인 내용도 어느정도 뜯어보니<br />
코드에 대한 자신감이 조금 더 생긴 주였던 것 같다.</p>

<p>오늘 공부는 여기서 끝!!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 라면, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[날씨가 많이 쌀쌀해졌다.]]></summary></entry><entry><title type="html">TIL) JWT 기초</title><link href="http://localhost:4000/til/2022/11/23/til.html" rel="alternate" type="text/html" title="TIL) JWT 기초" /><published>2022-11-23T00:00:00+09:00</published><updated>2022-11-23T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/23/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/23/til.html"><![CDATA[<p>확실히 Spring 관련된 기술을 사용하면서<br />
프로그래밍을 하고 있다는 느낌이 들때가 많아서 좋다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMWwuYanwzEYSBU97J-DZR9DkAcwyTyZwvas0jVZbla4RaJ-_F28bKYzcWQqOh3iqItCBSFVIUY6GDFl9qgi16AsH2POw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>사용하려는 프레임워크나 기술에 대한<br />
아키텍처 구조를 파악하고, 실제 어떻게 호출과 응답이 이루어지는지<br />
확인하는 과정이 순탄치는 않지만… 조금씩 눈에 들어오니<br />
확실히 재미의 가속도가 붙는 것 같다.</p>

<hr />

<p>3일 동안 Spring Security에 대한 내용을 얼추 마무리했다.<br />
오늘은 JWT에 대한 내용을 공부하는 시간이고<br />
JWT를 사용해 어떻게 Spring Security와 연결을 지어가는지<br />
2일에 걸쳐 공부해볼려고 한다.</p>

<h2 id="jwt-기초">JWT 기초</h2>

<h3 id="jwt란">JWT란?</h3>
<p>Json Web Token의 약자로<br />
Json 포맷으로 사용자에 대한 속성을 저장하는 웹 토큰이다.</p>

<p>기존에는 세션기반 인증으로 서버에 유저정보를 담는 방식으로 인증을 진행했었는데<br />
이렇게 되면 매번 요청을할때마다 DB를 살펴보아야하기 때문에<br />
이러한 부담을 줄이기 위해 토큰기반 인증이 나왔다.</p>

<p>토큰은 유저 정보를 암호화한 상태로 담을 수 있고<br />
암호화했기 때문에 클라이언트에 담을 수 있다.</p>

<p>토큰기반 인증의 장점?</p>
<ol>
  <li>무상태성, 확장성<br />
-&gt; 서버는 클라이언트에 대한 정보를 저장할 필요가 없다.<br />
-&gt; 토큰을 헤더에 추가함으로 인증절차 완료</li>
  <li>안정성<br />
-&gt; 암호화 한 토큰을 사용</li>
  <li>어디서나 생성 가능<br />
-&gt; 토큰을 생성하는 서버가 꼭 토큰을 만들지 않아도됨</li>
  <li>권한 부여에 용이 <br />
-&gt; 토큰의 payload 안에 어떤 정보에 접근이 가능한지 정의</li>
</ol>

<p><br /></p>

<h3 id="jwt-종류">JWT 종류</h3>

<p>JWT는 <code class="language-plaintext highlighter-rouge">Access Token</code>, <code class="language-plaintext highlighter-rouge">Refresh Token</code><br />
이 두가지 종류의 토큰을 사용자의 자격 증명에 이용한다.</p>

<p><strong><span style="color:#0066CC">Access Token</span></strong> : 보호된 정보들에 접근할 수 있는 권한을 부여할때 사용<br />
<strong><span style="color:#0066CC">Refresh Token</span></strong> : Access Token의 유효기간이 만료되면 Refresh Token을 이용해<br />
새로운 Access Token을 발급 받는다. (다시 로그인 인증할 필요 X)</p>

<p>Access Token이 탈취당했을 경우 <br />
탈취한 사람이 해당 사용자인 것 처럼 서버에 여러가지 요청을 보낼 수 있다.<br />
그렇기 때문에 탈취당하더라도 오랫동안 사용할 수 없도록<br />
Refresh Token을 사용해 Access Token을 새로 발급을 받는다.</p>

<p>만약 Refresh Token까지 탈취를 당했을 경우<br />
탈취한 사람이 해당 사용자에 큰 해를 입힐 수 있다.<br />
그렇기 때문에 로그인 인증을 다시할 필요없는 편의 같은 기능보다<br />
정보를 지키는 것이 더 중요한 웹 애플리케이션은 Refresh Token을<br />
사용하지 않는 곳이 많다고 한다.<br />
(즉, Access Token 유효기간이 만료되면 재인증을 해야함)</p>

<p><br /></p>

<h3 id="jwt-구조">JWT 구조</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOYuUIX6V7l7AAL_dwuJ4c8dxSmCnlrTXPYPA2gYVV4MM1qyH7K_aGFmXu_Jkx_GYNgHI1jDmR8sJ09gf0bW7f1U9su=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /><br />
<a href="https://catsbi.oopy.io/26b7f35c-e323-4e75-a9ee-2fe3e57ac641">출처 - Catsbi님 blog</a></p>

<p>JWT는 Header.Payload.Signature 구조로 이루어진다.</p>

<p><strong>1). Header</strong><br />
   -&gt; 어떤 종류의 토큰인지  <br />
   -&gt; 어떤 알고리즘으로 암호화 하는지<br />
   -&gt; Header의 JSON 객체를 base64 방식으로 인코딩한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"alg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"HS256"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"typ"</span><span class="p">:</span><span class="w"> </span><span class="s2">"JWT"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><br /></p>

<p><strong>2). Payload</strong><br />
   -&gt; 유저의 정보 (사용자의 이름 등)  <br />
   -&gt; 민감한 정보는 담지 않는 것이 좋다.<br />
   -&gt; 기타 필요한 정보<br />
   -&gt; Payload의 JSON 객체를 base64 방식으로 인코딩한다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"sub"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Information"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"LeeJaehyeok"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"iat"</span><span class="p">:</span><span class="w"> </span><span class="mi">151623391</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><br /></p>

<p><strong>3). Signature</strong><br />
   -&gt; Header, Payload를 base64 인코딩한 값과 salt값의 조합으로 암호화된 값<br />
   -&gt; 단방향 암호화를 수행한다.<br />
   -&gt; 이렇게 암호화된 메세지는 토큰의 위변조 유무를 검증하는데 사용한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret);
</code></pre></div></div>

<p><br /></p>

<h3 id="세션기반-자격증명-vs-토큰기반-자격-증명">세션기반 자격증명 vs 토큰기반 자격 증명</h3>

<p>✅ 세션기반 자격 증명</p>
<ul>
  <li>인증된 사용자 정보를 서버 측 세션 저장소에서 관리한다.</li>
  <li>생성된 사용자 세션의 고유 ID인 세션 ID는 클라이언트의 쿠키에 저장된다.  <br />
request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용한다.</li>
  <li>세션 ID만 클라이언트 쪽에서 사용해 상대적으로 네트워크 트랙픽을 적게 사용한다.</li>
  <li>서버 측에서 세션 정보를 관리하므로 보안성 측면에서 유리하다.</li>
  <li>서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성이 높다.</li>
  <li>세션 데이터가 많아질수록 서버으 부담이 가중된다.</li>
  <li>SSR 박식의 애플리케이션에 적합한 방식이다.</li>
</ul>

<p><br /></p>

<p>✅ 토큰기반 자격 증명의 특징</p>
<ul>
  <li>인증된 사용자 정브는 서버 측에서 별도의 관리를 하지 않는다.</li>
  <li>생성된 토큰을 Header에 포함시킨다. request 전승 시, 인증된 사용자인지 증명하는 수단으로 사용된다.</li>
  <li>토큰내에 인증된 사용자 정보 등을 포함하고 있어 세션에 비해 상대적으로 많은 네트워크 트래픽을 사용한다.</li>
  <li>서버 측에서 토큰을 관리하지 않으므로 보안성 측면에서 조금 더 불리하다.</li>
  <li>인증된 사용자 request의 상태를 유지할 필요가 없기 때문에 서버의 확장성면에서 유리하고<br />
세션 불일치 같은 문제가 발생하지 않는다.</li>
  <li>토큰에 포함되는 사용자 정보는 토큰의 특성상 암호화가 되지 않기때문에 공격자에게 토큰이 탈취될 경우<br />
사용자 정보를 그대로 제공하는셈이 되므로 민감한 정보는 토큰에 포함시키지 말아야한다.</li>
  <li>기본적으로 토큰이 만료되기 전까지는 토큰을 모효화 시킬 수 없다.</li>
  <li>CSR 방식의 애플리케이션에 적합한 방식이다.</li>
</ul>

<h3 id="토큰기반-인증절차">토큰기반 인증절차</h3>

<p>아래의 사진은 토큰기반 인증절차에 대한 큰 흐름이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOIQ-igIsxJcmvSaYg6jxG6SeXQZlDrwTmzkQCd2vE2Dy4zpZG_Z_nTqJvBkFwsDBxcZYFe5xKIx86lhvRNC5h92NGU=w1299-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<ol>
  <li>클라이언트에서 로그인 요청을 보냅니다.</li>
  <li>아이디/비밀번호가 일치하는지 확인하고, 클라이언트에게 보낼 암호화된 토큰을 생성합니다.</li>
  <li>토큰을 클라이언트에게 전송하면, 클라이언트는 토큰을 저장합니다.<br />
-&gt; 저장하는 위치는 Local Storage, Session Storage, Cookie 등이 될 수 있다.</li>
  <li>클라리언트가 Headers 또는 쿠키에 토큰을 담아 어떠한 요청을 합니다.</li>
  <li>서버에서 토큰을 검증해 서버에서 발급한 토큰이 맞을 경우, 클라이언트의 요청을 처리한 후 응답을 보낸다.</li>
</ol>

<p><br /></p>

<h3 id="jwt-토큰-만들어보기">JWT 토큰 만들어보기</h3>

<p>Spring Security와 JWT를 같이 사용해보기전에 먼저 <br />
JWT 토큰을 만드는 방법을 코드로 작성해보자</p>

<p><strong>1). 의존 라이브러리 추가</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//jwt 의존 라이브러리</span>
<span class="n">implementation</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">jsonwebtoken</span><span class="o">:</span><span class="n">jjwt</span><span class="o">-</span><span class="nl">api:</span><span class="mf">0.11</span><span class="o">.</span><span class="mi">5</span><span class="err">'</span>
<span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">jsonwebtoken</span><span class="o">:</span><span class="n">jjwt</span><span class="o">-</span><span class="nl">impl:</span><span class="mf">0.11</span><span class="o">.</span><span class="mi">5</span><span class="err">'</span>
<span class="n">runtimeOnly</span>	<span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">jsonwebtoken</span><span class="o">:</span><span class="n">jjwt</span><span class="o">-</span><span class="nl">jackson:</span><span class="mf">0.11</span><span class="o">.</span><span class="mi">5</span><span class="err">'</span>
</code></pre></div></div>
<p>우선 build.gradle에 jjwt 의존라이브러리를 추가해준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMK5rCr5B2LRfcaM0vHK_8HL-XpmBLw8J4-SmsT_ZLhCAPgxjzuWPKRWep1z0eOw7WsW7Res6as9NvHmBdxJe1STWkt5A=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>추가된 모습을 확인할 수 있다.</p>

<p><br /></p>

<p><strong>2). AccessToken 만들기</strong><br />
JWT 토큰을 생서해주는 클래스를 만들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtTokenizer</span> <span class="o">{</span>
    
   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">encodeBase64SecretKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">secretKey</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">encode</span> <span class="o">=</span> <span class="nc">Encoders</span><span class="o">.</span><span class="na">BASE64</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">secretKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
      <span class="k">return</span> <span class="n">encode</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">generateAccessToken</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">claims</span><span class="o">,</span> <span class="nc">String</span> <span class="n">subject</span><span class="o">,</span> <span class="nc">Date</span> <span class="n">expiration</span><span class="o">,</span> <span class="nc">String</span> <span class="n">base64EncodedSecretKey</span><span class="o">)</span> <span class="o">{</span>

      <span class="nc">Key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">getKeyFormBase64EncodedKey</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">);</span>

      <span class="k">return</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
              <span class="o">.</span><span class="na">setClaims</span><span class="o">(</span><span class="n">claims</span><span class="o">)</span> <span class="c1">// Custom Claims를 추가 (인증된 사용자와 관련된 정보)</span>
              <span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="n">subject</span><span class="o">)</span> <span class="c1">// JWT에 대한 제목을 추가</span>
              <span class="o">.</span><span class="na">setIssuedAt</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">getTime</span><span class="o">())</span> <span class="c1">// JWT 발행 일자 설정</span>
              <span class="o">.</span><span class="na">setExpiration</span><span class="o">(</span><span class="n">expiration</span><span class="o">)</span> <span class="c1">// JWT 만료일자 설정</span>
              <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="c1">// 서명을 위한 Key 객체를 넣어준다.</span>
              <span class="o">.</span><span class="na">compact</span><span class="o">();</span> <span class="c1">// JWT를 생성하고 직렬화해줌</span>
   <span class="o">}</span>
   
   <span class="o">...</span> <span class="n">생략</span>
   
   <span class="kd">private</span> <span class="nc">Key</span> <span class="nf">getKeyFormBase64EncodedKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">base64EncodedSecretKey</span><span class="o">){</span>
      <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span> <span class="o">=</span> <span class="nc">Decoders</span><span class="o">.</span><span class="na">BASE64</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">);</span> <span class="c1">// 디코딩 진행</span>
      <span class="nc">Key</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">)</span> <span class="nc">Keys</span><span class="o">.</span><span class="na">hmacShaKeyFor</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">);</span> <span class="c1">// HMAC 알고리즘을 적용한 Key 객체 생성</span>
      <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>1). <code class="language-plaintext highlighter-rouge">encodeBase64SecretKey();</code> 메서드<br />
해당 메서드 부터 살펴보면, String 타입의 객체 secretKey라는 것을<br />
매개변수로 받고있다. 받은 매개변수는 Base64 인코딩을 통해 나온 객체를 다시 리턴해준다.<br />
즉, secretKey를 인코딩해주는 메서드이다.</p>

<p>2). <code class="language-plaintext highlighter-rouge">generateAccessToken();</code> 메서드<br />
AccessToken을 만들어주는 메서드이다.<br />
우선 매개변수로 받는 객체는 총 4개가 된다.</p>

<p>Map&lt;String, Object&gt; claims<br />
String subject<br />
Date expiration <br />
String base64EncodedSecretKey</p>

<p>claims 객체는 사용자의 관련된 정보가 Map에 담겨있다.<br />
subject 객체는 해당 토큰의 제목이다.<br />
expriation 객체 같은 경우에는 토큰의 만료 시간을 설정한다.<br />
base64EncodedSecretKey 객체는 <code class="language-plaintext highlighter-rouge">1)번</code>에서 인코딩한 객체를 넣어주면된다.</p>

<p>3). <code class="language-plaintext highlighter-rouge">getKeyFormBase64EncodedKey();</code> 메서드<br />
인코딩으로 받은 객체를 다시 디코딩해주는 메서드이다.<br />
HMAC_SHA 알고리즘을 적용해 Key객체로 만들어 리턴해준다.<br />
해당 키는 <code class="language-plaintext highlighter-rouge">2)번</code>에서 Access Token을 만들대 사용된다.</p>

<p><br /></p>

<p>이렇게 우선 AccessToken을 만들어주는 메서드를 구현했다.<br />
해당 메서드를 테스트코드를 만들어 검증해보자.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@TestInstance</span><span class="o">(</span><span class="nc">TestInstance</span><span class="o">.</span><span class="na">Lifecycle</span><span class="o">.</span><span class="na">PER_CLASS</span><span class="o">)</span> <span class="c1">// 테스트 인스턴스 생성단위가 클래스임</span>
<span class="kd">class</span> <span class="nc">JwtTokenizerTest</span> <span class="o">{</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="nc">JwtTokenizer</span> <span class="n">jwtTokenizer</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nc">String</span> <span class="n">secretKey</span><span class="o">;</span>
   <span class="kd">private</span> <span class="nc">String</span> <span class="n">base64EncodedSecretKey</span><span class="o">;</span>

   <span class="nd">@BeforeAll</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">jwtTokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JwtTokenizer</span><span class="o">();</span>
      <span class="n">secretKey</span> <span class="o">=</span> <span class="s">"LeeJaehyeok637637123231231231123"</span><span class="o">;</span> <span class="c1">// 디코딩값: TGVlSmFlaHllb2s2Mzc2MzcxMjMyMzEyMzEyMzExMg==</span>
      <span class="n">base64EncodedSecretKey</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">encodeBase64SecretKey</span><span class="o">(</span><span class="n">secretKey</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="nd">@Test</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">encode64SecretKeyTest</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">);</span>
      <span class="n">assertThat</span><span class="o">(</span><span class="n">secretKey</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="nc">Decoders</span><span class="o">.</span><span class="na">BASE64</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">))));</span>
   <span class="o">}</span>

   <span class="nd">@Test</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateAccessTokenTest</span><span class="o">(){</span>
      <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">claims</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
      <span class="n">claims</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"memberId"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
      <span class="n">claims</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"roles"</span><span class="o">,</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"USER"</span><span class="o">));</span>

      <span class="nc">String</span> <span class="n">subject</span> <span class="o">=</span> <span class="s">"test access token"</span><span class="o">;</span>
      <span class="nc">Calendar</span> <span class="n">calendar</span> <span class="o">=</span> <span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
      <span class="n">calendar</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">MINUTE</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
      <span class="nc">Date</span> <span class="n">expiration</span> <span class="o">=</span> <span class="n">calendar</span><span class="o">.</span><span class="na">getTime</span><span class="o">();</span>

      <span class="nc">String</span> <span class="n">accessToken</span> <span class="o">=</span> <span class="n">jwtTokenizer</span><span class="o">.</span><span class="na">generateAccessToken</span><span class="o">(</span><span class="n">claims</span><span class="o">,</span> <span class="n">subject</span><span class="o">,</span> <span class="n">expiration</span><span class="o">,</span> <span class="n">base64EncodedSecretKey</span><span class="o">);</span>

      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">accessToken</span><span class="o">);</span>

      <span class="n">assertThat</span><span class="o">(</span><span class="n">accessToken</span><span class="o">,</span> <span class="n">notNullValue</span><span class="o">());</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위와 같이 테스트 코드를 작성할 수 있다.</p>

<p>테스트를 실행전 secretKey값을 넣어놓고 인코딩한 값을<br />
base64EncodedSecretKey 객체에 넣어두었다.</p>

<p>첫번쨰 테스트 <code class="language-plaintext highlighter-rouge">encode64SecretKeyTest();</code> 메서드는<br />
현재 인코딩된값을 다시 디코딩해 secretKey값과 비교해<br />
같으면 테스트를 통과하는 코드이다.</p>

<p>두번째 테스트 <code class="language-plaintext highlighter-rouge">generateAccessTokenTest();</code> 메서드는<br />
실제로 AccessToken을 만들어보는 테스트이고<br />
위에서 보았던 <code class="language-plaintext highlighter-rouge">generateAccessToken()</code>;의 매개변수에<br />
해당하는 데이터를 만들어서 메서드 실행한다음 반환값을 받으면된다.</p>

<p>실제 해당 반환된 토큰 accessToken를 출력해보면<br />
<code class="language-plaintext highlighter-rouge">eyJhbGciOiJIUzI1NiJ9.eyJyb2xlcyI6WyJVU0VSIl0sIm1lbWJlcklkIjoxLCJzdWIi
OiJ0ZXN0IGFjY2VzcyB0b2tlbiIsImlhdCI6MTY2OTE5MjY0OSwiZXhwIjoxNjY5MTkzMj
Q5fQ.yt_Y741NrTH5l7wsk3oYhbBqkZKgy7GNtJxsI-XuIQg</code></p>

<p>이러한 JWT 토큰이 만들어지는 것을 확인할 수 있고<br />
위에서 공부했던 것 처럼 Header, Payload, Signature로 이루어진 것을 볼 수 있다.</p>

<p>해당 토큰을 <a href="https://jwt.io/">JWT 사이트</a>에서 디코딩 해보면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO_wCj1b91B1IxTjBKbJBSMY_NTzz2HQ5SjXSIlqonhF-Rw9nXUkcUqJWXnZ585EHK7u8dGAODelmV8U6Fl_DM4kVbpCg=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우리가 정의했던 값으로 해독이 가능한 모습을<br />
확인해볼 수 있다.</p>

<p><br /></p>

<p><strong>3). RefreshToken 만들기</strong><br />
RefreshToken을 만드는 방법은 사실 AccessToken과<br />
동일한 방법으로 만들면된다. 다만 차이점은 claims에 대한 내용만<br />
빠진 상태로 만들면 된다.</p>

<p>아까와 동일한 클래스 JwtTokenizer에다 메서드를 추가해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JwtTokenizer</span> <span class="o">{</span>
    
   <span class="o">...</span> <span class="n">생략</span>

   <span class="kd">public</span> <span class="nc">String</span> <span class="nf">generateRefreshToken</span><span class="o">(</span><span class="nc">String</span> <span class="n">subject</span><span class="o">,</span> <span class="nc">Date</span> <span class="n">expiration</span><span class="o">,</span> <span class="nc">String</span> <span class="n">base64EncodedSecretKey</span><span class="o">){</span>
      <span class="nc">Key</span> <span class="n">key</span> <span class="o">=</span> <span class="n">getKeyFormBase64EncodedKey</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">);</span>

      <span class="k">return</span> <span class="nc">Jwts</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
              <span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="n">subject</span><span class="o">)</span> <span class="c1">// JWT에 대한 제목을 추가</span>
              <span class="o">.</span><span class="na">setIssuedAt</span><span class="o">(</span><span class="nc">Calendar</span><span class="o">.</span><span class="na">getInstance</span><span class="o">().</span><span class="na">getTime</span><span class="o">())</span> <span class="c1">// JWT 발행 일자 설정</span>
              <span class="o">.</span><span class="na">setExpiration</span><span class="o">(</span><span class="n">expiration</span><span class="o">)</span> <span class="c1">// JWT 만료일자 설정</span>
              <span class="o">.</span><span class="na">signWith</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="c1">// 서명을 위한 Key 객체를 넣어준다.</span>
              <span class="o">.</span><span class="na">compact</span><span class="o">();</span> <span class="c1">// JWT를 생성하고 직렬화해줌</span>
   <span class="o">}</span>
   
   <span class="o">...</span> <span class="n">생략</span>
   
<span class="o">}</span>
</code></pre></div></div>
<p>AcessToken과 다른점은 얘기했듯이<br />
clamis에 대한 내용만 빠진 상태로 Token을 만들어주면된다.</p>

<p><br /></p>

<h3 id="오늘-만난-error">오늘 만난 ERROR</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The specified key byte array is 248 bits which is not secure enough for any JWT HMAC-SHA algorithm.  The JWT JWA Specification (RFC 7518, Section 3.2) states that keys used with HMAC-SHA algorithms MUST have a size &gt;= 256 bits (the key size must be greater than or equal to the hash output size).  Consider using the io.jsonwebtoken.security.Keys#secretKeyFor(SignatureAlgorithm) method to create a key guaranteed to be secure enough for your preferred HMAC-SHA algorithm.  See https://tools.ietf.org/html/rfc7518#section-3.2 for more information.
io.jsonwebtoken.security.WeakKeyException: The specified key byte array is 136 bits which is not secure enough for any JWT HMAC-SHA algorithm.  The JWT JWA Specification (RFC 7518, Section 3.2) states that keys used with HMAC-SHA algorithms MUST have a size &gt;= 256 bits (the key size must be greater than or equal to the hash output size).  Consider using the io.jsonwebtoken.security.Keys#secretKeyFor(SignatureAlgorithm) method to create a key guaranteed to be secure enough for your preferred HMAC-SHA algorithm.  See https://tools.ietf.org/html/rfc7518#section-3.2 for more information.
</code></pre></div></div>

<p>HMAC_SHA 알고리즘을 사용 중 발생했던 에러를 적어본다.<br />
알람 발생 경위는 위에 에러 콘솔에서<br />
<code class="language-plaintext highlighter-rouge">HMAC-SHA algorithms MUST have a size &gt;= 256 bits</code>를 보고 알 수 있다.<br />
SecretKey값이 256 bits가 넘지 않아서 발생한 문제로 추청되어</p>

<p>테스트를 진행해봤다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">encodeBase64SecretKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">secretKey</span><span class="o">){</span>
     <span class="nc">String</span> <span class="n">encode</span> <span class="o">=</span> <span class="nc">Encoders</span><span class="o">.</span><span class="na">BASE64</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">secretKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
     <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"encodeBase64SecretKey Method 실행 { "</span> <span class="o">+</span><span class="s">"secretKEY = "</span><span class="o">+</span> <span class="n">secretKey</span> <span class="o">+</span> <span class="s">" secretKEY.Byte = "</span><span class="o">+</span> <span class="n">secretKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">().</span><span class="na">length</span> <span class="o">+</span> <span class="s">" Base64 Encode = "</span> <span class="o">+</span> <span class="n">encode</span><span class="o">+</span><span class="s">" }"</span><span class="o">);</span>
     <span class="k">return</span> <span class="n">encode</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div></div>
<p>현재 매개변수로 String secretKey를 BASE64로 인코딩 해주는 작업이다.<br />
secretKey = “LeeJaehyeok63763712323123123112”;<br />
실제로 이러한 데이터를 secretKey로 입력했다.</p>

<p>해당 encode 객체로 아래의 메서드의 매개변수로 보내주었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="nc">Key</span> <span class="nf">getKeyFormBase64EncodedKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">base64EncodedSecretKey</span><span class="o">){</span>
     <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span> <span class="o">=</span> <span class="nc">Decoders</span><span class="o">.</span><span class="na">BASE64</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">);</span> <span class="c1">// 디코딩 진행</span>
     <span class="nc">Key</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">)</span> <span class="nc">Keys</span><span class="o">.</span><span class="na">hmacShaKeyFor</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">);</span> <span class="c1">// HMAC 알고리즘을 적용한 Key 객체 생성</span>
     <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div></div>
<p>첫번째로 인코딩했던 문자열을 디코딩해주고<br />
HMAC_SHA 알고리즘을 통해 Key값으로 바꾸는 작업을 했다.<br />
이떄 여기서 에러가 발생했던 지점이었다.</p>

<p><code class="language-plaintext highlighter-rouge">.hmacShaKeyFor();</code> 안에서 스펙과 맞지않는 디코드값을 <br />
넣어준게 문제인 것 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">private</span> <span class="nc">Key</span> <span class="nf">getKeyFormBase64EncodedKey</span><span class="o">(</span><span class="nc">String</span> <span class="n">base64EncodedSecretKey</span><span class="o">){</span>
     <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span> <span class="o">=</span> <span class="nc">Decoders</span><span class="o">.</span><span class="na">BASE64</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">base64EncodedSecretKey</span><span class="o">);</span> <span class="c1">// 디코딩 진행</span>
        
     <span class="c1">// ===========Test 임시 코드===========</span>
     <span class="nc">String</span> <span class="n">test</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
     <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">s</span> <span class="o">:</span> <span class="n">keyBytes</span><span class="o">){</span>
        <span class="n">test</span> <span class="o">+=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span><span class="n">s</span><span class="o">;</span>
     <span class="o">}</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">test</span><span class="o">);</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
     <span class="c1">// ==================================</span>
     
     <span class="nc">Key</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Key</span><span class="o">)</span> <span class="nc">Keys</span><span class="o">.</span><span class="na">hmacShaKeyFor</span><span class="o">(</span><span class="n">keyBytes</span><span class="o">);</span> <span class="c1">// HMAC 알고리즘을 적용한 Key 객체 생성</span>
     <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
 <span class="o">}</span>
</code></pre></div></div>
<p>실제로 디코딩했을때 우리가 넣어줬던</p>

<p><code class="language-plaintext highlighter-rouge">System.out.println(test);</code><br />
LeeJaehyeok63763712323123123112 값이 디코딩된것이 콘솔에 출력되었고</p>

<p><code class="language-plaintext highlighter-rouge">System.out.println(keyBytes.length);</code><br />
31 이라는 값이 출력되었다. 말은 즉슨 31Byte라는 것을 의미한다.</p>

<p>그러면 우리가 처음에 넣어줬던 secretKey는 31 Bytes였고<br />
Bit로 환산해보면 1Byte = 8 Bit로 계산되어지니<br />
<code class="language-plaintext highlighter-rouge">8 * 31 = 248</code>, 즉 248bits로 계산되어진다.</p>

<p>그러면 우리가 처음에 봤던 에러콘솔 첫줄에<br />
<code class="language-plaintext highlighter-rouge">The specified key byte array is 248 bits which is not secure enough for any JWT HMAC-SHA algorithm.</code> 이러한 구문이 있었고, 우리가 정의한 byte가 248 bits이니까<br />
<code class="language-plaintext highlighter-rouge">size &gt;= 256 bits</code>를 넘기게 만들라는 뜻으로 해석할 수 있다.</p>

<p>즉, secretKey의 String Byte값을 지정했을때<br />
<code class="language-plaintext highlighter-rouge">32 Bytes = 256 Bits</code>가 넘지 않아서 생기는 문제였던 것!</p>

<p>그래서 secretKey값을 LeeJaehyeok637637123231231231123로<br />
뒤에 숫자하나를 추가했더니 정상적으로 작동하는 모습을 볼 수 있었다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 JWT와 인증과 관련된 기초지식을<br />
먼저 배웠고, 내일부터는 Spring Security와 같이 사용해볼 것 같다.</p>

<p>사실 오늘은 토큰을 생성하는 법만 배웠고 더 나아간 학습을
진행하지 않았기 때문에 클라이엔트에 어떻게 보내줄지<br />
혹시 요청을 받을때 JWT를 해독해 검증하는 과정을 어떻게할지<br />
아직 머리속에서 마땅한 그림은 떠오르지 않는 상태이다.</p>

<p>모쪼록 내일까지 JWT 인증과 관련된 부분을 잘 마무리 해보자<br />
오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 삽겹살, 라면, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[확실히 Spring 관련된 기술을 사용하면서 프로그래밍을 하고 있다는 느낌이 들때가 많아서 좋다.]]></summary></entry><entry><title type="html">TIL) Spring Security 3 (권한부여)</title><link href="http://localhost:4000/til/2022/11/22/til.html" rel="alternate" type="text/html" title="TIL) Spring Security 3 (권한부여)" /><published>2022-11-22T00:00:00+09:00</published><updated>2022-11-22T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/22/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/22/til.html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO-9XVEAUETJGFf5AjYCUCurD1z-9yBYl4hAKS_SdfBOSr5ac7uSAlI8PoCiXakOadLKWhnBi-RnF5XAFfKoh4ynbCMmQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>어제 공부했던 Spring Security 인증처리 과정에서대해<br />
코드를 찾아가보면서 어느정도 깨달음이 있어서<br />
진전이 있는 느낌이 들어 오랜만에 편안한 마음으로 공부를 했다.</p>

<p>오늘은 Spring Security 권한관련 Filter를 공부하는 날이고<br />
섹션 중 Spring Security는 마지막인 시간이다.</p>

<hr />

<p>어제 <a href="https://mycatlikeschuru.github.io/til/2022/11/21/til.html">(Spring Security 인증처리)</a>에 대한 내용을<br />
코드와 아케텍쳐를 통해 쭉 살펴보았다.</p>

<p>오늘은 권한과 관련된 Filter인<br />
<code class="language-plaintext highlighter-rouge">AuthorizationFilter</code> 클래스에 대한 권한 부여의<br />
간단한 처리 흐름과 코드를 살펴보려고한다.</p>

<p><br /></p>

<h2 id="spring-security-권한부여">Spring Security 권한부여</h2>

<p>어제는 인증처리에 관련된 내용을 배웠다.<br />
인증이란 이 사이트를 이용할 수 있는 유저인지 확인하는 과정이다.<br />
하지만 권한부여는 뭘까?</p>

<p>인증된 사용자가 모든 리소스에 접근을 제한하는 것을 말한다. <br />
헤딩 사용자가 이용할 수 있는 리소스를 제한하거나 풀어주는 것을<br />
권한 부여라고 한다.</p>

<p><br /></p>

<h3 id="권한부여-처리흐름">권한부여 처리흐름</h3>

<p><strong>AuthorizationFilter</strong></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOQXGNO9jp7S5n8BR1acug8wbYP2K5CODLz3E8JL1OYltFHyEMNavYMMn7otGOC4UHR5N_85NhELKDMT5Cm9oKCeMjE=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Spring Security에서는 권한 부여를 위해<br />
<code class="language-plaintext highlighter-rouge">AuthorizationFilter</code> 클래스를 이용해 처리를 한다.</p>

<p>SecurityFilterChain을 구성하는 Filter 중 하나로<br />
인증 Filter를 거친 후 진행하게 되어진다.<br />
본격적으로 <code class="language-plaintext highlighter-rouge">AuthorizationFilter</code>의 권한처리 흐름을 알아보자</p>

<p><br /></p>

<p>(1). <code class="language-plaintext highlighter-rouge">SecurityContextHolder</code>로 부터 <code class="language-plaintext highlighter-rouge">Authentication</code> 객채를 가져온다.<br />
<a href="https://mycatlikeschuru.github.io/til/2022/11/21/til.html">(Spring Security 인증처리)</a> 과정에서 인증이 완료된 객체 <code class="language-plaintext highlighter-rouge">Authentication</code>를 <br />
<code class="language-plaintext highlighter-rouge">SecurityContextHolder</code>에 넣어줬던 흐름이 인증처리의 마지막이어었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthorizationFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>
    
    <span class="o">...</span> <span class="n">이상</span> <span class="n">생략</span>
    
    <span class="kd">private</span> <span class="nc">Authentication</span> <span class="nf">getAuthentication</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Authentication</span> <span class="n">authentication</span> <span class="o">=</span> <span class="nc">SecurityContextHolder</span><span class="o">.</span><span class="na">getContext</span><span class="o">().</span><span class="na">getAuthentication</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">authentication</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AuthenticationCredentialsNotFoundException</span><span class="o">(</span>
                    <span class="s">"An Authentication object was not found in the SecurityContext"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">authentication</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="o">...</span> <span class="n">이하</span> <span class="n">생략</span>
            
<span class="o">}</span>
</code></pre></div></div>
<p>실제로 <code class="language-plaintext highlighter-rouge">AuthorizationFilter</code> 클래스 코드 중 <code class="language-plaintext highlighter-rouge">getAuthentication();</code> 메서드를 이용해  <br />
<code class="language-plaintext highlighter-rouge">Authentication</code> 객체를 꺼내는 모습을 코드로 볼 수 있다.</p>

<p><br /></p>

<p>(2). <code class="language-plaintext highlighter-rouge">Authentication</code> 객체와 <code class="language-plaintext highlighter-rouge">HttpServletRequest</code> 객체를<br />
<code class="language-plaintext highlighter-rouge">AuthorizationManager</code>에게 전달한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthorizationFilter</span> <span class="kd">extends</span> <span class="nc">OncePerRequestFilter</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AuthorizationManager</span><span class="o">&lt;</span><span class="nc">HttpServletRequest</span><span class="o">&gt;</span> <span class="n">authorizationManager</span><span class="o">;</span>
     
    <span class="o">...</span> <span class="n">생략</span>
    
    <span class="kd">public</span> <span class="nf">AuthorizationFilter</span><span class="o">(</span><span class="nc">AuthorizationManager</span><span class="o">&lt;</span><span class="nc">HttpServletRequest</span><span class="o">&gt;</span> <span class="n">authorizationManager</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">authorizationManager</span><span class="o">,</span> <span class="s">"authorizationManager cannot be null"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">authorizationManager</span> <span class="o">=</span> <span class="n">authorizationManager</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">AuthorizationDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">authorizationManager</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">getAuthentication</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">eventPublisher</span><span class="o">.</span><span class="na">publishAuthorizationEvent</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">getAuthentication</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">decision</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">decision</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">decision</span><span class="o">.</span><span class="na">isGranted</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="s">"Access Denied"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="o">...</span> <span class="n">이하</span> <span class="n">생략</span>

<span class="o">}</span>

</code></pre></div></div>
<p>실제로 코드를 확인해보면<br />
생성자로 <code class="language-plaintext highlighter-rouge">AuthorizationManager</code>의 객체를 DI받고 있다.<br />
그리고 <code class="language-plaintext highlighter-rouge">.check(this::getAuthentication, request);</code> 메서드를 호출해<br />
<code class="language-plaintext highlighter-rouge">Authentication</code>와 <code class="language-plaintext highlighter-rouge">HttpServletRequest</code> 객체를 매개변수로 넘겨주고있다.</p>

<p><br /></p>

<p>(3). <code class="language-plaintext highlighter-rouge">AuthorizationManager</code>는 <br />
권한 부여 처리를 총괄하는 매니저 역할의 인터페이스이다.<br />
구현체는  <code class="language-plaintext highlighter-rouge">RequestMatcherDelegatingAuthorizationManager</code> 클래스이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AuthorizationManager</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="o">...</span> <span class="n">이상</span> <span class="n">생략</span>

	<span class="nd">@Nullable</span>
	<span class="nc">AuthorizationDecision</span> <span class="nf">check</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Authentication</span><span class="o">&gt;</span> <span class="n">authentication</span><span class="o">,</span> <span class="no">T</span> <span class="n">object</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>코드로도 볼 수 있듯이 인터페이스에 메서드가 정의되어있고</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RequestMatcherDelegatingAuthorizationManager</span> <span class="kd">implements</span> <span class="nc">AuthorizationManager</span><span class="o">&lt;</span><span class="nc">HttpServletRequest</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="o">...</span>
    <span class="n">이상</span> <span class="n">생략</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">AuthorizationDecision</span> <span class="nf">check</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Authentication</span><span class="o">&gt;</span> <span class="n">authentication</span><span class="o">,</span> <span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="nc">LogMessage</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Authorizing %s"</span><span class="o">,</span> <span class="n">request</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">RequestMatcherEntry</span><span class="o">&lt;</span><span class="nc">AuthorizationManager</span><span class="o">&lt;</span><span class="nc">RequestAuthorizationContext</span><span class="o">&gt;&gt;</span> <span class="n">mapping</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">mappings</span><span class="o">)</span> <span class="o">{</span>

            <span class="nc">RequestMatcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="na">getRequestMatcher</span><span class="o">();</span>
            <span class="nc">MatchResult</span> <span class="n">matchResult</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">matchResult</span><span class="o">.</span><span class="na">isMatch</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">AuthorizationManager</span><span class="o">&lt;</span><span class="nc">RequestAuthorizationContext</span><span class="o">&gt;</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="na">getEntry</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="nc">LogMessage</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Checking authorization on %s using %s"</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">manager</span><span class="o">));</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">manager</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="n">authentication</span><span class="o">,</span>
                        <span class="k">new</span> <span class="nf">RequestAuthorizationContext</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">matchResult</span><span class="o">.</span><span class="na">getVariables</span><span class="o">()));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Abstaining since did not find matching RequestMatcher"</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="o">...</span> <span class="n">이하</span> <span class="n">생략</span>
            
<span class="o">}</span>
</code></pre></div></div>
<p>구현체인 <code class="language-plaintext highlighter-rouge">RequestMatcherDelegatingAuthorizationManager</code> 클래스에<br />
<code class="language-plaintext highlighter-rouge">check();</code>메서드가 Override되어 있는 모습을 확인할 수 있다.</p>

<p><br /></p>

<p>(4),(5). 이제 전달받은 객체들로 <code class="language-plaintext highlighter-rouge">check();</code> 메서드 내부에서<br />
권한 처리에 대한 로직이 수행된다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">RequestMatcherEntry</code> 정보를 얻은 후에 <code class="language-plaintext highlighter-rouge">RequestMatcher</code> 객체를 얻는다.</li>
  <li><code class="language-plaintext highlighter-rouge">RequestMatcher</code> 객체로 <code class="language-plaintext highlighter-rouge">HttpServletRequest</code> 객체를 넣어 <code class="language-plaintext highlighter-rouge">MatchResult</code> 객체를 만든다.</li>
  <li><code class="language-plaintext highlighter-rouge">MatchResult</code> 객체의 메서드 <code class="language-plaintext highlighter-rouge">.isMatch();</code>로 권한을 체크한다.</li>
</ol>

<p>만약에 권한이 존재해 <code class="language-plaintext highlighter-rouge">if (matchResult.isMatch())</code> 메서드를 통과한다면<br />
<code class="language-plaintext highlighter-rouge">manager.check();</code>를 통해서 <code class="language-plaintext highlighter-rouge">matchResult.getVariables();</code>를 통해서<br />
Map을 담고있는 객체가 반환되며 권한 부여과정이 진행되고</p>

<p>만약에 권한이 존재하지 않아 <code class="language-plaintext highlighter-rouge">if (matchResult.isMatch())</code> 메서드를 통과하지 못한다면<br />
<code class="language-plaintext highlighter-rouge">return null;</code>로 인해 null값이 반환되게 되어진다.<br />
즉, 맨처음에 우리가 <code class="language-plaintext highlighter-rouge">check();</code>메서드를 호출했던 <code class="language-plaintext highlighter-rouge">AuthorizationFilter</code>에서</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doFilterInternal</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">filterChain</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>

    <span class="nc">AuthorizationDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">authorizationManager</span><span class="o">.</span><span class="na">check</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">getAuthentication</span><span class="o">,</span> <span class="n">request</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">eventPublisher</span><span class="o">.</span><span class="na">publishAuthorizationEvent</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">getAuthentication</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">decision</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">decision</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">decision</span><span class="o">.</span><span class="na">isGranted</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">AccessDeniedException</span><span class="o">(</span><span class="s">"Access Denied"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">filterChain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">throw new AccessDeniedException("Access Denied");</code> 예외를 던지게되어<br />
권한을 부여하지 않도록 처리를 해주는 것이다.</p>

<p><br /></p>

<h3 id="접근-제어-표현식">접근 제어 표현식</h3>

<p>Spring Security 웹 및 메서드 보안을 위한 표현식</p>

<p><strong>Spring EL</strong></p>

<table>
  <tbody>
    <tr>
      <td>표현식</td>
      <td>: 설명 :</td>
    </tr>
    <tr>
      <td>hasRole</td>
      <td>현재 보안 주체(principal)가 지정된 역할을 갖고 있는지 여부를 확인하고 가지고 있다면 true를 리턴한다. <br /> hasRole(’admin’)처럼 파라미터로 넘긴 role이 ROLE_ 로 시작하지 않으면 기본적으로 추가한다. <br /> (DefaultWebSecurityExpressionHandler의 defaultRolePrefix를 수정하면 커스텀할 수 있다.)</td>
    </tr>
    <tr>
      <td>hasAnyRole</td>
      <td>현재 보안 주체가 지정한 역할 중 1개라도 가지고 있으면 true를 리턴한다. (문자열 리스트를 콤마로 구분해서 전달한다.) <br /> ex) hasAnyRole(’admin’, ‘user’)</td>
    </tr>
    <tr>
      <td>hasAuthority</td>
      <td>현재 보안 주체가 지정한 권한을 갖고 있는지 여부를 확인하고 가지고 있다면 true를 리턴한다. <br /> ex) hasAuthority(’read’)</td>
    </tr>
    <tr>
      <td>hasAnyAuthority</td>
      <td>현재 보안 주체가 지정한 권한 중 하나라도 있으면 true를 리턴한다. <br /> ex) hasAnyAuthority(’read’, ‘write’)</td>
    </tr>
    <tr>
      <td>principal</td>
      <td>현재 사용자를 나타내는 principal 객체에 직접 접근할 수 있다.</td>
    </tr>
    <tr>
      <td>authentication</td>
      <td>SecurityContext로 조회할 수 있는 현재 Authentication 객체에 직접 접근할 수 있다.</td>
    </tr>
    <tr>
      <td>permitAll</td>
      <td>항상 true로 평가한다.</td>
    </tr>
    <tr>
      <td>denyAll</td>
      <td>항상 false로 평가한다.</td>
    </tr>
    <tr>
      <td>isAnonymous()</td>
      <td>현재 보안 주체가 익명 사용자면 true를 리턴한다.</td>
    </tr>
    <tr>
      <td>isRememberMe()</td>
      <td>현재 보안 주체가 remember-me 사용자면 true를 리턴한다.</td>
    </tr>
    <tr>
      <td>isAuthenticated()</td>
      <td>사용자가 익명이 아닌 경우 true를 리턴한다.</td>
    </tr>
    <tr>
      <td>isFullyAuthenticated()</td>
      <td>사용자가 익명 사용자나 remember-me 사용자가 아니면 true를 리턴한다.</td>
    </tr>
    <tr>
      <td>hasPermission <br /> (Object target, Object permission)</td>
      <td>사용자가 target에 해당 permission 권한이 있으면 true를 리턴한다. <br /> ex) hasPermission(domainObject, ‘read’)</td>
    </tr>
    <tr>
      <td>hasPermission <br /> (Object targetId, String targetType, Object permission)</td>
      <td>사용자가 target에 해당 permission 권한이 있으면 true를 리턴한다. <br /> ex) hasPermission(1, ‘com.example.domain.Message’, ‘read’)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<hr />

<p>이렇게 오늘을 끝으로 Spring Security의<br />
인증과 권한에 대해 알아보았다.<br />
좀 더 깊은내용을 이해하기 위해서는 여러가지 Filter에 대해 공부가<br />
필요해보이고, 내일부터 공부하는 JWT를 이용할때 어떠한 방식으로<br />
Spring Security 로직이 변경되는지 내일부터 다시 공부해보자</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 삽겹살, 된장찌개, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL) Spring Security 2 (인증처리)</title><link href="http://localhost:4000/til/2022/11/21/til.html" rel="alternate" type="text/html" title="TIL) Spring Security 2 (인증처리)" /><published>2022-11-21T00:00:00+09:00</published><updated>2022-11-21T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/21/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/21/til.html"><![CDATA[<p>주말이라는 것은… 사람을 참 나태하게 만들기도<br />
활력을 공급하기도 하는 것 같다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOjX-PSPnxF_8TEMdso4KXA0JFYzGA1vArqAdtB6h1-NxbA6XRbp-Xy587IzIYiyL_lKX7HXm5PYPHWKxXIq9zV_OpOtA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>토요일까지 Spring Security를 공부하다가 번아웃이와<br />
일요일에 너무 게으르게 누워만 있었더니<br />
유튜브 나태지옥에 다시 빠져버렸다.</p>

<hr />

<p>저번주에 Spring Security를 사용하는 예제 코드와<br />
간단한 흐름을 알아보았다.<br />
그중 Filter라는 것들을 배웠고 Spring Security도<br />
Filter로 구성된 FilterChain으로 구동하는 것도 배웠다.</p>

<p>오늘은 그 중에서 인증관련된 Filter를 자세히 알아보자</p>

<h2 id="spring-security-인증">Spring Security 인증</h2>

<h3 id="filter-흐름-복습">Filter 흐름 복습</h3>

<p>저번주에 공부했었던 <a href="https://mycatlikeschuru.github.io/til/2022/11/18/til.html">(Spring Security 기초)</a>의 흐름을 다시한번 짚고 넘어가자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOdqM4FUdK-kbSe3fOY-_nbwexPCpzCoO0wU4fxsPySDcyhG4ju9jOfdiay5TA0GmdJqNj0L4UZcOZGIHz9XGJLAcqNlw=w1299-h921" alt="image" class="align-left" style="max-width: 60%" /></p>

<p>클라이언트에서 요청이오면<br />
Filter들의 모임인 FilterChain을 거쳐 하나씩 실행한다.<br />
그 중 FilterChainProxy 클래스로 부터 보안을 위한 작업 필터모음인<br />
SecurityFilterChain를 수행하게된다.</p>

<p>여기서 SecurityFilterChain도 Filter들로 이루어져있고<br />
아래의 사진이 SecurityFilterChain의 대략적인 구조이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNlrpr3UQFs4rI7dXvh6L-v1GvYL_3mSnWy8cA9rKECR2M-C_y4fYtJrNqD7xWcvzqy0TDvYC65satnVVyAEYsoTGaQbg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /><br />
<a href="https://velog.io/@sa833591/Spring-Security-5">hyozkim.log - 출처</a></p>

<p>사진에서 보면 알 수 있듯이 <br />
SecurityFilterChain의 구조는</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SecurityContextPersistenceFilter  
LogoutFilter  
UsernamePasswordAuthenticationFilter  
...  
</code></pre></div></div>

<p>등 여러가지 필터를가진 형태로 존재한다.</p>

<p>모든 Filter의 구조를 알고 이해한다면 분명 SpringSecurity에 대한<br />
이해도가 깊어질 것이자만, 현재 공부를 시작한지 얼마안된<br />
내가 전부를 이해하기에는 사실 무리가 있는 것 같다고 생각이 들었다.</p>

<p>이 중에서도 인증과 관련된 UsernamePasswordAuthenticationFilter의<br />
인증 처리 흐름을 이해해보려한다. 해당하는 부분을 어제 코드로 구현하기도 했고<br />
흐름을 알아야 SpringSecurity를 기본적인 내용을 구현하는데 무리가 없을 것 같다.</p>

<p><br /></p>

<p><strong>Security Filter 확인 방법?</strong></p>

<p>위에서 얘기했듯이 여러 Filter들을 거쳐서<br />
인증과 권한에 대한 수행을 SpringSecurity가 진행해준다.<br />
실제로 어떠한 Filter를 거쳐왔는지 확인을 할 수 있는 애노테이션이 있고  <br />
디버그 용도로 매우 유용하게 쓰일 것 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span><span class="o">(</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span> <span class="c1">// 디버그 설정</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfigurationV2</span> <span class="o">{</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">http</span>
                <span class="o">.</span><span class="na">csrf</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span>
                <span class="o">.</span><span class="na">formLogin</span><span class="o">()</span>
                <span class="o">.</span><span class="na">loginPage</span><span class="o">(</span><span class="s">"/auths/login-form"</span><span class="o">)</span> 
                <span class="o">.</span><span class="na">loginProcessingUrl</span><span class="o">(</span><span class="s">"/process_login"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">failureUrl</span><span class="o">(</span><span class="s">"/auths/login-form?error"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span>
                <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">()</span> 
                <span class="o">.</span><span class="na">anyRequest</span><span class="o">()</span> 
                <span class="o">.</span><span class="na">permitAll</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@EnableWebSecurity(debug = true) 어노테이션을<br />
이용해 현재 요청에 이용된 Filter의 목록이 조회가 가능하다.</p>

<p>애플리케이션을 실행시키고<br />
formLogin 방식으로 요청을 보내보았다.</p>

<p>그리고 콘솔을 확인해보면</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Security filter chain: [
  DisableEncodeUrlFilter
  WebAsyncManagerIntegrationFilter
  SecurityContextPersistenceFilter
  HeaderWriterFilter
  LogoutFilter
  UsernamePasswordAuthenticationFilter
  RequestCacheAwareFilter
  SecurityContextHolderAwareRequestFilter
  AnonymousAuthenticationFilter
  SessionManagementFilter
  ExceptionTranslationFilter
  AuthorizationFilter
]
</code></pre></div></div>
<p>첫번쨰로 요청에 대한 정보들과<br />
다음으로는 Security filter chain에 Filter 목록들이<br />
나오는 것을 확인할 수 있다.</p>

<p>위에서 볼 수 있듯이 우리가 알아보려고하는<br />
UsernamePasswordAuthenticationFilter 클래스도 <br />
콘솔로 확인이 가능하다.</p>

<p><br /></p>

<h3 id="인증-처리">인증 처리</h3>

<p>이제 본격적으로 인증이 어떠한 과정으로<br />
진행되는지 처리 순서에 대한 흐름을 알아보자.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM9oGy1ZMRYopmfP5I5a2V8YyhzZ_cPot1-9VSX4vFPRYbCISfsxHheqNiPvpRv-ywxmVYbIGBUyfKCX3AaeeChzJ7toQ=w1920-h921" alt="image" class="align-left" style="max-width: 120%" /></p>

<p>(1). 클라이언트에서 로그인 요청이 오면, <code class="language-plaintext highlighter-rouge">SecurityFilterChain</code>을 거치게된다.<br />
그 중 인증에 관한 부분은 <code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code> 클래스이다.</p>

<p><br /></p>

<p>(2). <code class="language-plaintext highlighter-rouge">Authentication</code> 객체를 생성한다.<br />
여기서 로그인할때 받아온 Username과 Password를 이용해<br />
<code class="language-plaintext highlighter-rouge">Authentication</code>의 구현체인 <code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationToken</code> <br />
클래스를 이용해 <code class="language-plaintext highlighter-rouge">Authentication</code> 객체를 만든다.<br />
<em><strong>(❗️Authentication 객체는 인증이 완료되지 않음)</strong></em></p>

<p><br /></p>

<p>(3). <code class="language-plaintext highlighter-rouge">Authentication</code> 객체를 <code class="language-plaintext highlighter-rouge">AuthenticationManager</code>로 전달한다.  <br />
여기서 구현체인 <code class="language-plaintext highlighter-rouge">ProviderManager</code>가 인증이라는 작업의 총괄 매니저다. <br />
총괄은 하지만 실제 인증처리는 <code class="language-plaintext highlighter-rouge">AuthenticationProvider</code>에게 위임한다.<br />
<em><strong>(❗️Authentication 객체는 인증이 완료되지 않음)</strong></em></p>

<p><br /></p>

<p>(4). <code class="language-plaintext highlighter-rouge">Authentication</code> 객체를 <code class="language-plaintext highlighter-rouge">AuthenticationProvider</code>로 전달한다.<br />
<code class="language-plaintext highlighter-rouge">ProviderManager</code>가 전달해준 <code class="language-plaintext highlighter-rouge">Authentication</code>객체로 인증하는 작업을 진행한다.<br />
인증을 구현하는 방법은 2가지 정도가 있다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">AuthenticationProvider</code>를 상속받아 구현</li>
  <li><code class="language-plaintext highlighter-rouge">UserDetailsService</code>를 상속받아 구현</li>
</ol>

<p><a href="https://mycatlikeschuru.github.io/til/2022/11/18/til.html">(Spring Security 기초)</a>에서 우리는 <code class="language-plaintext highlighter-rouge">UserDetailsService</code>를<br />
상속받아 직접 클래스를 구현했었다.</p>

<p>여기서 1번방법으로 구현하면 <code class="language-plaintext highlighter-rouge">₩</code>UserDetailsService` 부분은<br />
사용하지 않고 구현을 할 수 있다. 구현할때 중요한 부분은<br />
직접 Credentials과 Password를 인증과정 로직을 구현해야한다는 점이다.</p>

<p>하지만 어제 우리가 구현했던 2번방법으로 구현하면<br />
<code class="language-plaintext highlighter-rouge">AuthenticationProvider</code>를 구현하지 않아도된다.<br />
<code class="language-plaintext highlighter-rouge">DaoAuthenticationProvider</code>를 구현 클래스로 사용하기 때문이다. 
실제로 호출 흐름을 본다면,</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ProviderManager</code> 클래스의 <code class="language-plaintext highlighter-rouge">.authenticate();</code> 메서드 호출</li>
  <li><code class="language-plaintext highlighter-rouge">AuthenticationProvider</code> 인터페이스의 <code class="language-plaintext highlighter-rouge">AbstractUserDetailsAuthenticationProvider</code>가<br />
<code class="language-plaintext highlighter-rouge">.authenticate();</code> 메서드를 구현했음.</li>
  <li><code class="language-plaintext highlighter-rouge">.authenticate();</code> 메서드안에서 인증 처리를 위한 <code class="language-plaintext highlighter-rouge">retrieveUser();</code> 호출<br />
<code class="language-plaintext highlighter-rouge">DaoAuthenticationProvider</code> 클래스가 <code class="language-plaintext highlighter-rouge">.retrieveUser();</code>를 구현했음</li>
  <li><code class="language-plaintext highlighter-rouge">.retrieveUser();</code> 메서드에서 <code class="language-plaintext highlighter-rouge">UserDetailsService</code> 클래스의 <code class="language-plaintext highlighter-rouge">.loadUserByUsername()</code>  <br />
메서드 호출 <code class="language-plaintext highlighter-rouge">.loadUserByUsername();</code> 메서드는 우리가 구현해야하는 부분이다.</li>
</ol>

<p><em><strong>(❗️Authentication 객체는 인증이 완료되지 않음)</strong></em></p>

<p><br /></p>

<p>(5). 즉, 위에서 얘기했던 <code class="language-plaintext highlighter-rouge">DaoAuthenticationProvider</code> 클래스가<br />
<code class="language-plaintext highlighter-rouge">UserDetailsService</code>를 이용해 <code class="language-plaintext highlighter-rouge">UserDetails</code>를 객체를 조회 한다.</p>

<p>실제로 어제 예제에서 <code class="language-plaintext highlighter-rouge">UserDetails</code>를 상속받아<br />
username, password, 권한정보를 객체로 만들어 구현하였고<br />
해당객체를 <code class="language-plaintext highlighter-rouge">UserDetailsService</code>를 이용해 반환하는 프로그램도 작성했다.<br />
<em><strong>(❗️Authentication 객체는 인증이 완료되지 않음)</strong></em></p>

<p><br /></p>

<p>(6). 즉, Credential 저장소라는 뜻은 DB의 암호화된 비밀번호를 가져온다는 뜻이다.  <br />
쉽게 말하자면 (5)번을 통해 호출된 <code class="language-plaintext highlighter-rouge">UserDetailsService</code>에서<br />
<code class="language-plaintext highlighter-rouge">loadUserByUsername(String username);</code> 메서드를 이용해 <br />
우리는 어떤 username으로 접근하는지 알 수 있으며, 해당 정보로 DB를 조회해<br />
싫제로 동일한 username이 존재할 경우 해당 테이블의 정보를 가져올 수 있다.<br />
즉, 권한정보, 암호화된 비밀번호 등등 사용자 정보를 가져올 수 있다는 뜻이다.</p>

<p><br /></p>

<p>(7). 이제 우리는 (6)번을 통해서 조회한 데이터로 인증을 비교할<br />
<code class="language-plaintext highlighter-rouge">UserDetails</code> 객체를 만들 수 있다. <code class="language-plaintext highlighter-rouge">UserDetails</code> 객체는<br />
username,password,권한정보를 가지고 있으면 객체로 만들 수 있다.</p>

<p><br /></p>

<p>(8). 만들어진 <code class="language-plaintext highlighter-rouge">UserDetails</code> 객체는, 맨처음 호출했던 <br />
<code class="language-plaintext highlighter-rouge">DaoAuthenticationProvider</code> 클래스에 반환하게 되어진다.<br />
아까 얘기했듯이 <code class="language-plaintext highlighter-rouge">AuthenticationProvider</code>를 구현한 클래스로<br />
인증을 처리해주는 클래스이다.</p>

<p><br /></p>

<p>(9). <code class="language-plaintext highlighter-rouge">UserDetails</code> 정보를 이용해 <code class="language-plaintext highlighter-rouge">DaoAuthenticationProvider</code> 클래스가<br />
<code class="language-plaintext highlighter-rouge">.mitigateAgainstTimingAttack();</code> 메서드를 호출해 인증을 처리한다.<br />
인증처리가 정상적으로 이루어졌을 경우에 <br />
그림과 같이 인증정보인 <code class="language-plaintext highlighter-rouge">Collection&lt;GrantedAuthority&gt;</code>가 추가된<br />
<code class="language-plaintext highlighter-rouge">Authentication</code> 객체를 반환하게 된다.<br />
<em><strong>(⭕️Authentication 객체는 인증이 완료됨)</strong></em></p>

<p><br /></p>

<p>(10). 이제 인증이 완료된 객체를 호출했던<br />
<code class="language-plaintext highlighter-rouge">ProviderManager</code>로 반한된다.<br />
<em><strong>(⭕️Authentication 객체는 인증이 완료됨)</strong></em></p>

<p><br /></p>

<p>(11). 마찬가지로 처음에 호출을 했던 <br />
<code class="language-plaintext highlighter-rouge">UsernamePasswordAuthenticationFilter</code> 클래스로<br />
인증이완료된 객체가 반환되게 되어진다.<br />
<em><strong>(⭕️Authentication 객체는 인증이 완료됨)</strong></em></p>

<p><br /></p>

<p>(12). 최종적으로 인증이 완료된 Authentication 객체를<br />
<code class="language-plaintext highlighter-rouge">SecurityContextHolder</code>를 이용해 <code class="language-plaintext highlighter-rouge">SecurityContext</code>에 저장을하게 된다.<br />
S<code class="language-plaintext highlighter-rouge">ecurityContext</code>의 세션 정책에 따라서<br />
HttpSession에 저장되어 사용자의 인증 상태를 유지하기도 하고<br />
HttpSession을 생성하지 않고 무상태를 유지하기도 한다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 SecurityFilterChain에서<br />
어떻게 인증이 이루어지는지 알아보았다.</p>

<p>오늘 정말 파급적인 효과로 코드에 대해 이해를 했다.<br />
아키텍쳐를 그려가면서, 실제 코드들이 호출되서<br />
실행되는 것을 하나하나 따라가보면서 순서에 대한 흐름을 글로 정리해봤다.</p>

<p>이렇게 코드를 따라가면서, 파악한 내용을 적고 하다보니까<br />
어디서 부터 시작되었고, 어떻게 객체를 돌려받는지가<br />
파악되다보니까 어느정도 인증처리에 대한 흐름은 잡힌 것 같다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 된장찌개, 라면, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[주말이라는 것은… 사람을 참 나태하게 만들기도 활력을 공급하기도 하는 것 같다.]]></summary></entry><entry><title type="html">TIL) Spring Security 1 (기초)</title><link href="http://localhost:4000/til/2022/11/18/til.html" rel="alternate" type="text/html" title="TIL) Spring Security 1 (기초)" /><published>2022-11-18T00:00:00+09:00</published><updated>2022-11-18T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/18/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/18/til.html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMbi5KBKT2qUujSToFzrlGZ8riZgXZWFRWl1il4pHA0AlwRLqDL1ROTXlmdEytfEfxx0rpCo3VI8iZTbovSWK60aVBtSA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>예전보다 월-금 시간이 정말 빨리간다.<br />
그만큼 공부하는 시간을 즐기고 있으니 시간도 빨리가는 것 같다.</p>

<p>오늘도 이번주의 마지막이니 만큼<br />
더 집중해서 공부해보자 !</p>

<hr />

<p>오늘은 Spring Security에 대해 공부하는 날이다.<br />
다음주에도 계속 공부할 것 같고<br />
오늘은 기본 구조와 웹 요청 처리 흐름에대해 공부해보려한다.</p>

<h2 id="spring-security">Spring Security</h2>

<p><strong>Spring Security란 ?</strong><br />
Spring MVC 기반 애플리케이션의 인증,인가 기능을<br />
지원하는 보안 프레임워크이다.</p>

<p>Interceptor나 Servlet Filter과 같은 보안 기능을<br />
직접 구현할 수 있지만 Spring Security에서 안정적으로 지원하고 있기 때문에<br />
Spring MVC를 기반으로한다면 Spring Security를 이용하는게 안전한 선택이라 할 수 있다.</p>

<p><strong>스프링 시큐리티를 이용한다면 ?</strong></p>
<ol>
  <li>다양한 유형의 사용자 인증 기능 적용 가능 (폼 로그인, 토큰, OAuth 2기반 인증)</li>
  <li>애플리케이션 사용자의 역할에 따른 권한 레벨 적용</li>
  <li>애플리케이션에서 제공하는 리소스 대한 접근 제어</li>
  <li>민감한 정보에 대한 데이터 암호화</li>
  <li>일반적으로 알려진 웹 보안 공격 차단</li>
</ol>

<p>스프링 시큐리티 관련 용어를 미리 숙지하고 <br />
본격적인 내용을 살펴보면 도움이 될 것이다.</p>
<ol>
  <li><strong>Principal (주체)</strong><br />
-&gt; 애플리케이션에서 작업을 수행할 수 있는 사용자,디바이스,시스템 등이 될 수 있다.<br />
인증 프로세스가 성공적으로 수행된 사용자의 계정 정보를 의미함.</li>
  <li><strong>Authentication (인증)</strong><br />
-&gt; 애플리케이션을 사용하는 사용자가 본인이 맞음을 증명하는 절차</li>
  <li><strong>Authorization (인가)</strong><br />
-&gt; 인증이 정상적으로 수행된 사용자에게 하나 이상의 권한을 부여함.<br />
특정 애플리케이션에 특정 리소스에 접근할 수 있게 허가하는 과정을 의미한다.</li>
  <li><strong>Access Control (접근제어)</strong><br />
-&gt; 사용자가 애플리케이션의 리소스에 접근하는 행위를 제어하는 것을 의미한다.</li>
  <li><strong>Credential (신원 증명정보)</strong><br />
-&gt; 인증을 정상적으로 수행하기 위해서 식별하기 위한 정보.</li>
</ol>

<p><br /></p>

<h3 id="spring-security-흐름">Spring Security 흐름</h3>

<p>사용해보기에 앞서<br />
SSR방식으로 테스트를 진행할 예정이다.<br />
별도의 html을 만들어서 테스트를 진행했고<br />
Form Login 방식으로 테스트를 진행했다.</p>

<p>간단한 스프링 시큐리티의 보안 적용 흐름을 알고 넘어가보자.<br />
우리는 보통 웹에서 요청을 보내면 EndPoint를 거쳐 리소스에 접근을 한다.</p>

<p>Servlet 기반의 애플리케이션일 경우 EndPoint에 요청이 도달하기전에 요청을 가로챈 후  <br />
어떤 처리를 할 수 있는 적절한 포인트를 제공해줄 수 있는 API가 있다.<br />
그것은 바로 Servlet Filter이다.</p>

<p>Servlet Filter를 잠깐 정리하자면</p>
<ol>
  <li>Java에서 Interface형태로 제공하는 API이다.</li>
  <li>웹요청을 가로채 전처리, 응답을 전달하기전 후처리를 할 수 있다.</li>
</ol>

<p>이러한 Servlet Filter는 하나 이상의 필터들을 연결해<br />
Filter Chain을 구성할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOgZKwDg4Q2Nju5ltzUyuDISAyDNnWwDlA-x9U3zTRmZq0JpKZx5Q6Qg95NA9nMQoOQuuyyURwFi0LI-XHIUlnGlFw3Ew=w3024-h1620" alt="image" class="align-left" style="max-width: 40%" /><br />
출처 - <a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">Spring Security 레퍼런스</a></p>

<p><br /></p>

<p>Filter Chain의 Filter들은 우리가 구현한 작업들을 실행한 후에<br />
HttpServlet을 거쳐 DispatcherServlet에 요청이 전달되어진다.</p>

<p>DispatcherServlet은 Spring MVC 계층구조할때 많이 보았을 것이다.<br />
클라이언트에서 받은 모든 요청을 적합한 컨트롤러에 위임해주는<br />
Spring MVC에서 아주 중요한 역할을 가지고 있는 녀석이였다.</p>

<p>여하튼 우리가 알아야할 핵심은 DispatcherServlet에 도달하기 전에<br />
Servlet Filter가 가로챈다는 것이다.</p>

<p><br /></p>

<p>그럼 Spring Security와 Servlet Filter와 어떠한 관계가 있냐?</p>

<p>Spring Security에서는 보안과 관련된 Filter를 이용해 <br />
클라이언트에 요청을 중간에 가로챈 뒤 추가적으로 작업을 할 수 있도록 도와준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMdhZrHIw8wm0G_zG7eQgHqqNnxZhifIy-8Y1taID3Id73Ik4ScIIQt6oclNltVUbpDmsfKO-prb1xGOdVcuLX7eJCA7A=w3024-h1620" alt="image" class="align-left" style="max-width: 70%" /><br />
출처 - <a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">Spring Security 레퍼런스</a></p>

<p><br /></p>

<p>그것을 도와주는 클래스들이 바로 위에있는 아키텍쳐에서 보는<br />
DelegatingFilterProxy와 FilterChainProxy이다. <br />
해당 클래스들은 Filter 인터페이스를 구현하고 있어<br />
Servlet Filter로써의 역할을 수행해한다.</p>

<p>DelegatingFilterProxy는 Servlet Container 영의 Filter와<br />
ApplicationContext에 Bean으로 등록된 Filter들을 연결해주는 역할을 가진다.</p>

<p>FilterChainProxy는 Spring Security를 사용하기 위한 진입점이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNcZKkvVUXMS9csndq0ceE71GN1u2pu7EDH5twxx0Grcg4f36ZzPqvVnHu73GrKupyuIf_iKM3qR7WVa328iuXmCWqZjQ=w3024-h1620" alt="image" class="align-left" style="max-width: 80%" /><br />
출처 - <a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html">Spring Security 레퍼런스</a></p>

<p><br /></p>

<p>위의 그림에서 보듯이 Spring Security의 Filter Chain으로 <br />
보안을 위한 작업을 처리하는 필터의 모음을 만들면 <br />
FilterChainProxy로 부터 해당 Filter들을 시작할 수 있게되어진다.</p>

<p>한마디로 FilterChainProxy부터 Spring Security에서 제공하는<br />
보안 Filter들이 필요한 작업을 수행해주게 도와주는 클래스라 보면된다.</p>

<p><br /></p>

<h3 id="spring-security-연습해보기">Spring Security 연습해보기</h3>

<p>위의 Spring Security 요청 흐름에 대해 어느정도<br />
이해가 되었다면, 아래 코드들을 보고<br />
어느 부분인지 정확히는 몰라도 흐름은 파악이 가능하다.</p>

<p>우선 Spring Security를 사용하기 위한 의존라이브러리를 추가해야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">security</span><span class="err">'</span>
</code></pre></div></div>
<p>build.gradle에 의존라이브러를 추가시켜 놓으면 준비 끝이다.</p>

<p>처음으로 우선 위에서 보았던<br />
SecurityFilterChain을 구성해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfiguration</span> <span class="o">{</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">http</span>
                <span class="o">.</span><span class="na">csrf</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span> <span class="c1">// csrf 공격에 대한 설정 비활성화</span>
                <span class="o">.</span><span class="na">formLogin</span><span class="o">()</span><span class="c1">// Form 로그인 인증 방법</span>
                <span class="o">.</span><span class="na">loginPage</span><span class="o">(</span><span class="s">"/auths/login-form"</span><span class="o">)</span> <span class="c1">// 로그인 커스텀 페이지 설정 (우리가만든 경로설정)</span>
                <span class="o">.</span><span class="na">loginProcessingUrl</span><span class="o">(</span><span class="s">"/process_login"</span><span class="o">)</span><span class="c1">// 인증요청을 수행할 요청 URL 설정 (html form태그에서 요청)</span>
                <span class="o">.</span><span class="na">failureUrl</span><span class="o">(</span><span class="s">"/auths/login-form?error"</span><span class="o">)</span><span class="c1">// 실패시 리다이렉트할 URL 지정</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">logout</span><span class="o">()</span> <span class="c1">// 로그아웃 설정위한 LogoutConfigurer를 리턴해줌</span>
                <span class="o">.</span><span class="na">logoutUrl</span><span class="o">(</span><span class="s">"/logout"</span><span class="o">)</span> <span class="c1">// 로그아웃 요청 url 설정 (html form태그에서 요청)</span>
                <span class="o">.</span><span class="na">logoutSuccessUrl</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span> <span class="c1">// 성공시 리다이렉트할 장소</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">exceptionHandling</span><span class="o">().</span><span class="na">accessDeniedPage</span><span class="o">(</span><span class="s">"/auths/access-denied"</span><span class="o">)</span> <span class="c1">// 권한이 없을때 보낼 요청</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">(</span><span class="n">authorize</span> <span class="o">-&gt;</span>
                        <span class="n">authorize</span><span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/orders/**"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span> <span class="c1">// 해당 경로에 ADMIN 권한만 접근가능</span>
                                <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/members/my-page"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span> <span class="c1">// 해당 경로에 USER 권한만 접근가능</span>
                                <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/**"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span> <span class="c1">// 앞에지정한 URL을 제외한것 접근 모두가능</span>
                <span class="o">);</span>
<span class="c1">//                .authorizeHttpRequests() // 클라이언트의 요청이 들어오면 접근권한을 확인하겠다고 정의</span>
<span class="c1">//                .anyRequest() // 클라이언트의 모든 요청에 대해 접근을 허용</span>
<span class="c1">//                .permitAll(); // 클라이언트의 모든 요청에 대해 접근을 허용</span>
        <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>기본적인 구성방법은 SecurityFilterChain 클래스 타입을 반환하는<br />
메서드를 하나 만들어 filter의 정보를 넣어주는 것이다.<br />
그리고 해당 메서드를 Spring Container에 Bean으로 담아주면된다.</p>

<p>빈으로 담아주면 아까 위에서 얘기했던<br />
DelegatingFilterProxy 클래스에 의해<br />
서블릿 컨테이너 영역의 필터와 스프링 컨테이너의 빈으로 등록된 필터를<br />
연결해주는 브릿가 생긴다고 예상해볼 수 있을 것 같다.</p>

<p>그리고 SSR방식의 FormLogin을 사용한다고 가정했으니<br />
첫번째 필터로는 로그인에 해당하는 내용들  <br />
두번째 필터로는 로그아웃에 해당하는 내용들 <br />
세번째로는 권한이 없을때 처리하는 내용<br />
네번째로는 클라이언트 요청에따른 권한 설정에 대한 내용<br />
이렇게 각각 필터들을 하나의 필터체인으로 .build(); 하여 반환하면<br />
해당 내용에 따라 인증과 권한 부여가 이루어질 수 있다.</p>

<p><br /></p>

<h4 id="in-memory로-인증-해보기">In Memory로 인증 해보기</h4>

<p>DB를 이용하지 않는 인증방법을 한번 연습해보자</p>

<p><strong><span style="color:#F04965"> 1). 단순하게 고정해서 등록해 인증과 권한을 주는 방식 </span></strong></p>

<p>SecurityConfiguration 클래스 아래에 <br />
UserDetailsManager 반환하는 Bean 객체를 만들어주었다.</p>

<p>UserDetailsManager 라는 인터페이스를 <br />
구현한 객체를 Bean으로 등록해주면 해당 정보로 등록된<br />
사용자들은 정보에 해당하는 인증과 권한을 가지게 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@Bean</span>
 <span class="kd">public</span> <span class="nc">UserDetailsManager</span> <span class="nf">userDetailsService</span><span class="o">(){</span>
     <span class="nc">UserDetails</span> <span class="n">user</span> <span class="o">=</span> <span class="nc">User</span><span class="o">.</span><span class="na">withDefaultPasswordEncoder</span><span class="o">()</span> <span class="c1">// password 암호화</span>
             <span class="o">.</span><span class="na">username</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">)</span> <span class="c1">// 식별하는 사용자 아이디 값</span>
             <span class="o">.</span><span class="na">password</span><span class="o">(</span><span class="s">"1111"</span><span class="o">)</span>
             <span class="o">.</span><span class="na">roles</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span> <span class="c1">// 권한지정</span>
             <span class="o">.</span><span class="na">build</span><span class="o">();</span>
     <span class="nc">UserDetails</span> <span class="n">admin</span> <span class="o">=</span> <span class="nc">User</span><span class="o">.</span><span class="na">withDefaultPasswordEncoder</span><span class="o">()</span>
             <span class="o">.</span><span class="na">username</span><span class="o">(</span><span class="s">"admin@naver.com"</span><span class="o">)</span>
             <span class="o">.</span><span class="na">password</span><span class="o">(</span><span class="s">"2222"</span><span class="o">)</span>
             <span class="o">.</span><span class="na">roles</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span>
             <span class="o">.</span><span class="na">build</span><span class="o">();</span>

     <span class="k">return</span> <span class="k">new</span> <span class="nf">InMemoryUserDetailsManager</span><span class="o">(</span><span class="n">user</span><span class="o">,</span><span class="n">admin</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div>
<p>InMemoryUserDetailsManager 구현체로 구성 정보를 넘겨주면 된다.<br />
구성 정보를 만드는 방법은 UserDetails 인터페이스를 상속받는<br />
User 클래스를 이용해 만들 수있다.</p>

<p>만약 클라이언트에서 form login 방식으로 로그인 요청이 온다면<br />
해당 구성정보를 가진 사용자는 로그인이 되며<br />
권한을 각각 USER, ADMIN으로 부여받게 되어진다.</p>

<p>위에 있는 정보는 DB를 이용한 것도 아니며<br />
단순하게 UserDetailsManager 타입의 Bean을 만들어 주 었을 뿐인데<br />
Spring Security는 해당 정보를 가진 사용자가 로그인을 하면<br />
인증을 해주고 권한을 부여해줄 수 있는 것이다.</p>

<p>여기서 <strong>User.withDefaultPasswordEncoder()</strong> 메서드를 사용하면<br />
bcrypt 방식으로 password를 암호화해준다. 즉, 1111,2222로 들어온 값을<br />
암호화하여 관리를 한다는 의미이다.</p>

<p>만약 코드로 치게된다면 <strong>Deprecated</strong> 상태로 변하는데 (가운데줄 쳐짐)<br />
해당 API는 권장하지 않는다는 뜻이다. 이 경우에는 고정으로 사용하고 있기에<br />
고정해서 사용하지 말라는 의미에서 Deprecated로 변한 것을 볼 수 있다.</p>

<p><br /></p>

<p><strong><span style="color:#F04965"> 2). 회원 가입을 이용해 등록하기 </span></strong></p>

<p>기본적으로 password를 암호화를 해야한다.<br />
암호화를 하기위해 위에서 이용했던 bcrpty 방식으로 암호화를 <br />
도와주는 API가 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cm">/*
 * PasswordEncoder Bean 등록
 * 암호화를 해야한다. Spring Security에서 지원하는 Default = bcrypt
 * */</span>
 <span class="nd">@Bean</span>
 <span class="kd">public</span> <span class="nc">PasswordEncoder</span> <span class="nf">passwordEncoder</span><span class="o">(){</span>
     <span class="k">return</span> <span class="nc">PasswordEncoderFactories</span><span class="o">.</span><span class="na">createDelegatingPasswordEncoder</span><span class="o">();</span>
 <span class="o">}</span>
</code></pre></div></div>
<p>SecurityConfiguration 클래스에<br />
PasswordEncoder 인터페이스 타입 객체를 Bean으로 등록해주고<br />
회원가입시 사용할 수있다.</p>

<p>회원가입할 경우 Controller는 구성되어 있다고 가정하고<br />
Service 코드를 확인해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
*  InMemory 사용을 위한 빈주입
* */</span>
<span class="c1">//@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaConfigurationV1</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">inMemoryMemberService</span><span class="o">(</span><span class="nc">UserDetailsManager</span> <span class="n">userDetailsManager</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">InMemoryMemberService</span><span class="o">(</span><span class="n">userDetailsManager</span><span class="o">,</span><span class="n">passwordEncoder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>MemberService라는 인터페이스 타입으로 객체를 Bean으로 등록해준다.</p>

<p>InMemoryMemberSerivce에 우리가 이용해야할<br />
UserDetailsManager와 PasswordEncoder를 매개변수로 넣어<br />
생성자로 반환하게 되어진다.</p>

<p>그럼 Bean으로 InMemoryMemberService을 구현체로<br />
의존성 주입하여 Controller에서 이용이 가능하다..</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InMemoryMemberService</span> <span class="kd">implements</span> <span class="nc">MemberService</span> <span class="o">{</span>

   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserDetailsManager</span> <span class="n">userDetailsManager</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">InMemoryMemberService</span><span class="o">(</span><span class="nc">UserDetailsManager</span> <span class="n">userDetailsManager</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">userDetailsManager</span> <span class="o">=</span> <span class="n">userDetailsManager</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">passwordEncoder</span> <span class="o">=</span> <span class="n">passwordEncoder</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="nc">Member</span> <span class="nf">createMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>

      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">GrantedAuthority</span><span class="o">&gt;</span> <span class="n">authorities</span> <span class="o">=</span> <span class="n">createAuthorities</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">MemberRole</span><span class="o">.</span><span class="na">ROLE_USER</span><span class="o">.</span><span class="na">name</span><span class="o">());</span> <span class="c1">// 권한 USER로 설정</span>

      <span class="nc">String</span> <span class="n">encryptedPassword</span> <span class="o">=</span> <span class="n">passwordEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getPassword</span><span class="o">());</span> <span class="c1">// 비밀번호 암호화 진행</span>

      <span class="nc">UserDetails</span> <span class="n">userDetails</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span> <span class="n">encryptedPassword</span><span class="o">,</span> <span class="n">authorities</span><span class="o">);</span> <span class="c1">// username, password, 권한 정보로 유저 생성</span>
      <span class="n">userDetailsManager</span><span class="o">.</span><span class="na">createUser</span><span class="o">(</span><span class="n">userDetails</span><span class="o">);</span> <span class="c1">// 생성한 유저정보 등록</span>

      <span class="k">return</span> <span class="n">member</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">GrantedAuthority</span><span class="o">&gt;</span> <span class="nf">createAuthorities</span><span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">roles</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">roles</span><span class="o">)</span>
              <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">role</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">SimpleGrantedAuthority</span><span class="o">(</span><span class="n">role</span><span class="o">))</span>
              <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>여기서 회원가입을 위한 서비스 로직 createMember <br />
안의 내용을 들여다보면된다.</p>

<p>첫번째로 권한에 대한 내용을 설정하기위해<br />
new SimpleGrantedAuthority();을 이용해 객체를<br />
List 형태로 담아둔 authorities를 만들었다.</p>

<p>두번째로 암호화를 위해 DI받은 passwordEncoder의 메서드인<br />
.encode();를 이용해 비밀번호를 넘겨줘<br />
bcrypt 방식으로 암호화하여 String 타입으로 받아두었다.</p>

<p>마지막으로 new User();를 이용해<br />
위에서 고정으로 구성정보를 구성한 것 처럼</p>

<p>username, password, roles를 생성자로 넘겨<br />
UserDetails 타입의 객체로 만들어<br />
위에서 DI 받은 userDetailsManger의 메서드<br />
createUser();의 매개변수로 넘겨주게 되면<br />
회원 가입을 할때 해당 정보를 가진 Member가 인증과 권한정보를<br />
가지게되어 로그인할때 해당 정보를 가진 사용자가 로그인을 한다면<br />
인증이되어 설정한 ROLE_USER 권한으로 이용이 가능하게되어진다.</p>

<p><br />
<br /></p>

<p><strong><span style="color:#0066CC"> 위의 1,2번을 한마디로 정리 해보자면 !! </span></strong></p>

<p>UserDetails 객체를 만들어 줘야한다.<br />
그리고 그 객체를 이용해 UserDetailsManager의 구현체인<br />
InMemoryUserDetailsManager .createUser(); 메서드에<br />
매개변수로 UserDetails 객체를 넘겨주는게 끝이다 !</p>

<p><br /></p>

<h4 id="h2-db로-인증-해보기">H2 DB로 인증 해보기</h4>

<p>위에서 UserDetailsManager를 이용해 인증과 권한을 가졌다면</p>

<p>DB를 이용하기 위해서는 UserDetailsService 인터페이스를 이용해야한다.<br />
UserDetailsManager가 UserDetailsService를 상속받은 관계이다.</p>

<p>우선 H2 DB 설정과 관련된 부분은 되어있다고 가정하겠다. <br />
문제없이 H2 DataBase를 사용하기 위해서는<br />
기존에 설정했던 SecurityFilterChain에서 한가지 Filter를 추가해줘야한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityConfiguration</span> <span class="o">{</span>
    
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">SecurityFilterChain</span> <span class="nf">filterChain</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">http</span>
                <span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">frameOptions</span><span class="o">().</span><span class="na">sameOrigin</span><span class="o">()</span>  <span class="c1">// &lt;frame&gt; 태그등 렌더링여부 설정, 동일 출처로부터 들어오는 request만 렌더링허용 , H2 사용을 위함</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">csrf</span><span class="o">().</span><span class="na">disable</span><span class="o">()</span> <span class="c1">// csrf 공격에 대한 설정 비활성화</span>
                <span class="o">.</span><span class="na">formLogin</span><span class="o">()</span><span class="c1">// Form 로그인 인증 방법</span>
                <span class="o">.</span><span class="na">loginPage</span><span class="o">(</span><span class="s">"/auths/login-form"</span><span class="o">)</span> <span class="c1">// 로그인 커스텀 페이지 설정 (우리가만든 경로설정)</span>
                <span class="o">.</span><span class="na">loginProcessingUrl</span><span class="o">(</span><span class="s">"/process_login"</span><span class="o">)</span><span class="c1">// 인증요청을 수행할 요청 URL 설정 (html form태그에서 요청)</span>
                <span class="o">.</span><span class="na">failureUrl</span><span class="o">(</span><span class="s">"/auths/login-form?error"</span><span class="o">)</span><span class="c1">// 실패시 리다이렉트할 URL 지정</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">logout</span><span class="o">()</span> <span class="c1">// 로그아웃 설정위한 LogoutConfigurer를 리턴해줌</span>
                <span class="o">.</span><span class="na">logoutUrl</span><span class="o">(</span><span class="s">"/logout"</span><span class="o">)</span> <span class="c1">// 로그아웃 요청 url 설정 (html form태그에서 요청)</span>
                <span class="o">.</span><span class="na">logoutSuccessUrl</span><span class="o">(</span><span class="s">"/"</span><span class="o">)</span> <span class="c1">// 성공시 리다이렉트할 장소</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">exceptionHandling</span><span class="o">().</span><span class="na">accessDeniedPage</span><span class="o">(</span><span class="s">"/auths/access-denied"</span><span class="o">)</span> <span class="c1">// 권한이 없을때 보낼 요청</span>
                <span class="o">.</span><span class="na">and</span><span class="o">()</span> <span class="c1">// 보안설정을 메서드 체인형태로 구성하게 도와줌</span>
                <span class="o">.</span><span class="na">authorizeHttpRequests</span><span class="o">(</span><span class="n">authorize</span> <span class="o">-&gt;</span>
                        <span class="n">authorize</span><span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/orders/**"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"ADMIN"</span><span class="o">)</span> <span class="c1">// 해당 경로에 ADMIN 권한만 접근가능</span>
                                <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/members/my-page"</span><span class="o">).</span><span class="na">hasRole</span><span class="o">(</span><span class="s">"USER"</span><span class="o">)</span> <span class="c1">// 해당 경로에 USER 권한만 접근가능</span>
                                <span class="o">.</span><span class="na">antMatchers</span><span class="o">(</span><span class="s">"/**"</span><span class="o">).</span><span class="na">permitAll</span><span class="o">()</span> <span class="c1">// 앞에지정한 URL을 제외한것 접근 모두가능</span>
                <span class="o">);</span>
<span class="c1">//                .authorizeHttpRequests() // 클라이언트의 요청이 들어오면 접근권한을 확인하겠다고 정의</span>
<span class="c1">//                .anyRequest() // 클라이언트의 모든 요청에 대해 접근을 허용</span>
<span class="c1">//                .permitAll(); // 클라이언트의 모든 요청에 대해 접근을 허용</span>
        <span class="k">return</span> <span class="n">http</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>.headers().frameOptions().sameOrigin()<br />
메서드들이 추가되었고, 추가하지 않으면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPof1RAUkqFj1p0icu1y0Y1G_-q79XgeRnNvxsgf4sahOYXm9S9UNHjL3dST2DYsW76e9J9ZS_C961EXzBBqNjpKuygEg=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위의 화면과 같이 정상적으로 H2 DataBase가 표시되지 않을 수 있다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
*  DB 사용을 위한 빈주입
* */</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaConfigurationV2</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">dbMemberService</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBMemberServiceV1</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">,</span><span class="n">passwordEncoder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>기존에 InMemory를 사용하기 위해 설정했던 구성정보를 지우고<br />
새로운 구성정보를 설정. DBMemberService가 적용되도록 스프링 빈으로 등록했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DBMemberServiceV1</span> <span class="kd">implements</span> <span class="nc">MemberService</span> <span class="o">{</span>

   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">;</span>

   <span class="kd">public</span> <span class="nf">DBMemberServiceV1</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">passwordEncoder</span> <span class="o">=</span> <span class="n">passwordEncoder</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="nd">@Override</span>
   <span class="kd">public</span> <span class="nc">Member</span> <span class="nf">createMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">verifyExistsEmail</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
      <span class="nc">String</span> <span class="n">encryptedPassword</span> <span class="o">=</span> <span class="n">passwordEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getPassword</span><span class="o">());</span> <span class="c1">// 비밀번호 암호화</span>
      <span class="n">member</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="n">encryptedPassword</span><span class="o">);</span> <span class="c1">// 암호화된 비밀번호 객체에 맵핑</span>

      <span class="nc">Member</span> <span class="n">saveMember</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// DB에 저장</span>

      <span class="k">return</span> <span class="n">saveMember</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">verifyExistsEmail</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findByEmail</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="nf">BusinessLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span><span class="o">.</span><span class="na">MEMBER_EXISTS</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>DBMemberService에서는<br />
비밀번호 암호화를 한 것을 member 객체에 담아<br />
Repository에 저장하게만 구성해주면 끝난다.</p>

<p>인메모리 사용할때에는 UserDetailsManager에다가 저장했지만<br />
이제는 DBMemberService는 회원가입이라는<br />
서비스 로직만 남게 된 것이다.</p>

<p>이제 회원가입을하였고<br />
로그인을 하였을때 UserDetailsManager와 같은 역할을 구현해줘야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
* DB사용했을때 인증 처리 적용하기 (인메모리 사용시 기존 UserDetailManager를 사용했었음)
* UserDetailsService는 User정보를 로드하는 핵심적인 인터페이스다.
* UserDetailManager는 UserDetailsService를 상속하고있음
* */</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloUserDetailsServiceV1</span> <span class="kd">implements</span> <span class="nc">UserDetailsService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">HelloAuthorityUtils</span> <span class="n">authorityUtils</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">HelloUserDetailsServiceV1</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">,</span> <span class="nc">HelloAuthorityUtils</span> <span class="n">authorityUtils</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">authorityUtils</span> <span class="o">=</span> <span class="n">authorityUtils</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/*
    * UserDetailService 오버라이딩하여 UserDetails 객채를 만들어 반환하기
    * 이후는 스프링시큐리티가 인증처리를 대신해준다
    * */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">UserDetails</span> <span class="nf">loadUserByUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UsernameNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 해당 메서드 호출 시점은, login.html에서 로그인 버튼 누를떄이다.</span>
        <span class="c1">// 즉, &lt;form action="/process_login" method="post"&gt; 가 실행될떄 호출됨</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">optionalMember</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findByEmail</span><span class="o">(</span><span class="n">username</span><span class="o">);</span> <span class="c1">// 이메일로 멤버찾기</span>
        <span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">optionalMember</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">BusinessLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span><span class="o">.</span><span class="na">MEMBER_NOT_FOUND</span><span class="o">));</span> <span class="c1">// 멤버 찾기 예외 처리</span>
        <span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">GrantedAuthority</span><span class="o">&gt;</span> <span class="n">authorities</span> <span class="o">=</span> <span class="n">authorityUtils</span><span class="o">.</span><span class="na">createAuthorities</span><span class="o">(</span><span class="n">findMember</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span> <span class="c1">// 이메일 비교후 권한 처리</span>
        <span class="nc">UserDetails</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="n">findMember</span><span class="o">.</span><span class="na">getEmail</span><span class="o">(),</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getPassword</span><span class="o">(),</span> <span class="n">authorities</span><span class="o">);</span> <span class="c1">// 해당 정보로 User생성자로 UserDetails 만들기</span>
        <span class="k">return</span> <span class="n">user1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>우리는 UserDetailsService를 구현할 클래스를 만들어<br />
상속을 받게 만들어준다음. loadUserByUsername 오버라이딩해<br />
재정의를 해서 반환을 UserDetails 객체로 만들어 반환을 해주면된다.</p>

<p>회원가입은 이미 되어있고, 암호화까지해 놓은 상태로 DB에 저장되어있다.<br />
우리가 로그인 페이지에서 form login으로 post 메서드 /process_login을 호출하게되면<br />
우리가 위에서 봤던 흐름대로 EndPoint까지 가기전에<br />
Servlet Filter가 흐름을 가로채서 실행하게 되고<br />
우리는 Spring Security를 사용하고 있기때문에 인증 절차를 가지게된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOFEpthgmY3S8CBykz2TudWwacXHEngWxFMzuqUbbRWjNwnV379_0wvzLGpOM0t0X18sB8nTpumplyiCwlc5r_PjdIZfg=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>인증 절차는 실제로 이러한 흐름을 진행된다고한다.</p>

<ol>
  <li>
    <p>사용자가 로그인 정보와 함께 인증 요청을 한다.(Http Request)</p>
  </li>
  <li>
    <p>AuthenticationFilter가 요청을 가로채고, 가로챈 정보를 통해<br />
UsernamePasswordAuthenticationToken의 인증용 객체를 생성한다.</p>
  </li>
  <li>
    <p>AuthenticationManager의 구현체인 ProviderManager에게 생성한 <br />
UsernamePasswordToken 객체를 전달한다.</p>
  </li>
  <li>
    <p>AuthenticationManager는 등록된 AuthenticationProvider(들)을 조회하여 인증을 요구한다.</p>
  </li>
  <li>
    <p>실제 DB에서 사용자 인증정보를 가져오는 UserDetailsService에 사용자 정보를 넘겨준다.</p>
  </li>
  <li>
    <p>넘겨받은 사용자 정보를 통해 DB에서 찾은 사용자 정보인 UserDetails 객체를 만든다.</p>
  </li>
  <li>
    <p>AuthenticationProvider(들)은 UserDetails를 넘겨받고 사용자 정보를 비교한다.</p>
  </li>
  <li>
    <p>인증이 완료되면 권한 등의 사용자 정보를 담은 Authentication 객체를 반환한다.</p>
  </li>
  <li>
    <p>다시 최초의 AuthenticationFilter에 Authentication 객체가 반환된다.</p>
  </li>
  <li>
    <p>Authenticaton 객체를 SecurityContext에 저장한다.</p>
  </li>
</ol>

<p><a href="https://dev-coco.tistory.com/174">출처 - 슬기로운 개발생활</a></p>

<p><br /></p>

<p>즉, 우리가 구현해줘야할 부분은<br />
5번에서 사용자 정보를 받는 것을 이용해<br />
6번, 받은 정보를 이용해 UserDetails 객체를 반환만 시켜주면<br />
그 이후는 7번 부터 Spring Security가 알아서 진행시켜준다.</p>

<p>이를 토대로 위에 프로그램을 작성해 놓은 것을 보면<br />
오버라이딩한 loadUserByUsername 메서드를 통해서<br />
username을 매개변수로 정보를 받는다.<br />
해당 정보로 DB를 조회한다음, UserDetails 객체를 반환시켜주는 프로그램이다.</p>

<p><br /></p>

<p><strong><span style="color:#0066CC"> 위의 얘기를 한마디로 정리 해보자면 !! </span></strong></p>

<p>UserDetailsService 인터페이스를 구현한 클래스를 만든다.<br />
loadUserByUsername(); 메서드를 오버라이딩하여 매개변수로 username 정보를 받을 수 있다.<br />
username정보를 이용해 DB에 조회를 한다.<br />
조회한 데이터를 토대로 UserDetails 객체를 만들어 반환만 시켜주면 된다.<br />
이후는 Spring Security가 알아서 해줌</p>

<p><br /></p>

<h3 id="오늘-만난-error">오늘 만난 ERROR</h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>***************************
APPLICATION FAILED TO START
***************************

Description:

Parameter 0 of constructor in com.codestates.member.MemberController required a single bean, but 2 were found:
	- inMemoryMemberService: defined by method 'inMemoryMemberService' in class path resource [com/codestates/config/JavaConfigurationV1.class]
	- dbMemberService: defined by method 'dbMemberService' in class path resource [com/codestates/config/JavaConfigurationV2.class]
</code></pre></div></div>
<p>오늘 테스트 중 만났던 에러다. <br />
내용은 MemberController에서 싱글빈을 요구한는데 2개가 있다는 것 같은 내용이다.<br />
즉, 같은 타입의 빈이 두개가 등록된 문제라고 생각했다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Action:

Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed
</code></pre></div></div>
<p>밑에 아주친절하게 @Primary나  @Qualifier를 사용하라한다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
*  InMemory 사용을 위한 빈주입
* */</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaConfigurationV1</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">inMemoryMemberService</span><span class="o">(</span><span class="nc">UserDetailsManager</span> <span class="n">userDetailsManager</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">InMemoryMemberService</span><span class="o">(</span><span class="n">userDetailsManager</span><span class="o">,</span><span class="n">passwordEncoder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
*  DB 사용을 위한 빈주입
* */</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaConfigurationV2</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">dbMemberService</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBMemberService</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">,</span><span class="n">passwordEncoder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>MemberControler에서는 MemberService를 DI받게 설계해놓았고</p>

<p>MemberService라는 인터페이스를 구현한<br />
클래스 inMemoryMemberServie, DBMemberService 두개를<br />
빈으로 등록하려고 시도하니까 발생한 알람인 것 같다.</p>

<p>여기서 @Configuration을 한군데를 지워주면<br />
중복되지 않고 해결 할 수 있다.</p>

<p>하지만 코드는 그대로 유지싶었기에</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JavaConfigurationV2</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="nd">@Primary</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">dbMemberService</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">,</span> <span class="nc">PasswordEncoder</span> <span class="n">passwordEncoder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">DBMemberService</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">,</span> <span class="n">passwordEncoder</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>JavaConfigurationV2에 빈등록 메서드에 @Primary를 이용해<br />
빈을 선택해 주입해주도록 정했다.</p>

<hr />

<p>오늘은 이렇게 스프링 시큐리티의 기본적인<br />
사용방법을 알아보았다.</p>

<p>내부적으로 이루어지는 작업들이 많아 정확한<br />
흐름이 감이 잡히질 않는 것 같다.<br />
글을 적으면서도 내가 정확히 이해한게 맞는지 수십번을 돌아가서 확인하고 반복했다. <br />
확인했다고 한들… 정확한 정보를 적은 것 같지 않은 느낌이든다.<br />
계속 익숙해지게 사용해보면서 사용법에 익숙해져보자</p>

<p>오늘공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 짜장면, 탕수육</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL) 인증, 보안 기초</title><link href="http://localhost:4000/til/2022/11/17/til.html" rel="alternate" type="text/html" title="TIL) 인증, 보안 기초" /><published>2022-11-17T00:00:00+09:00</published><updated>2022-11-17T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/17/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/17/til.html"><![CDATA[<p>오늘은 드디어<br />
인증과 보안관련된 공부가 시작되었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmSK7Vlbd6P-ZA2TpRO9yTFxz9gH-OdxjYebZ6-r_KUFyGQiml5Hx8m6WodAQFCprhzYPGAg5SXnE-TkysLMqq-BedG44A=w1920-h864" alt="image" class="align-left" style="max-width: 50%" /></p>

<p>Spring Security, JWT, OAuth2 등<br />
여러가지를 배울 예정이고</p>

<p>가장 고전하는 영역이지 않을까 생각한다.</p>

<hr />

<p>오늘은 인증, 보안에 대한 기초를 먼저 파악하고<br />
내일부터 본격적인 Spring Security 사용법을 알아볼 것 같다.<br />
오늘은 기초인 HTTPS와 Hashing, Cookie, Session에 대해 알아보자</p>

<p><br /></p>

<h3 id="https">HTTPS</h3>

<p>우리가 여태까지 배웠기를 HTTP 프로토콜을 이용해<br />
TCP/IP 통신으로 서버와 연결할 수 있다고 공부를 했었다.<br />
HTTP Message를 통해 Json 객체를 받아보기도 하였다.</p>

<p>HTTPS의 Hyper Text Transfer Protocol Secure Socket layer의 약자다. <br />
보면 알 수 있듯이 기존의 <strong>HTTP + Secure Socket layer</strong>가 붙은 모습이다.<br />
HTTP 프로토콜을 보다 안전하게 요청을 주고 받기위해 SSL, TLS라는 알고리즘을 이용해 <br />
HTTP 통신을 하는 과정에서 데이터를 암호화하여 전송하는 방법이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmQ7kg8wBa9J9dzD10tI68mzIX9M97wYHvAyH-tNw-vTeDL5V8vTsTeX3a_QiO7FnYOL0DMp_w7JRIh9Jt27wXdEgUoDiw=w1510-h1614" alt="image" class="align-left" style="max-width: 100%" /><br />
HTTPS TLS HandShake (출처: <a href="https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake">CLOUDFLARE 사이트 참조</a> )</p>

<p>해당 그림은 HTTPS의 통신 핸드쉐이크이다. <br />
클라이언트에서 접속요청이 왔을 때, 내부적으로 통신이되어지는 순서이다.</p>

<p>TCP 연결이 완료후 TLS 핸드쉐이크가 동작하는 모습을 볼 수 있고<br />
TLS 핸드쉐이크 내에서는 인증서, 대칭키, 비대칭키와 같은 암복호를 통해<br />
인증된 서버에 접속을 할 수 있게 확인을 해준다.</p>

<p>정말 간단하게 정리해보자면</p>

<p><strong><span style="color:#F04965">대칭키 </span>: 키 한개로 암복호를 한다.</strong><br />
<strong><span style="color:#F04965">비대칭키</span> : 암호화한 키와 복호화한키가 다르다.</strong></p>

<p>키의 종류로는 <strong>공개키(Public Key)</strong>와 <strong>개인키(Private Key)</strong>가 존재하고</p>

<p>대칭키 같은경우에는 공개키-공개키, 개인키-개인키로 암호화 복호화를 할 수 있고<br />
비대칭키 같은 경우에는 공개키-개인키, 개인키-공개키로 암호화 복호화를 할 수 있다.<br />
HTTPS TLS 핸드쉐이크는 대칭키,비대칭키를 둘다 사용한다.</p>

<p>여기서 비대칭키 같은 경우에는<br />
개인키로 암호화한것을 공개키로 복호화할 수 있는데, 목적은 인증서같은 누구나 볼 수 있는 정보고<br />
공개키로 암호화한것을 개인키로 복호화할 수 있는데, 목적은 정보보호와 외부의 탈취방지를 위한 것이다.</p>

<p>여기서 <strong>인증서</strong>라는 개념이나오는데<br />
이러한 인증서의 역할은 서버에서 인증서를 브라우저에게 보내주는데<br />
클라이언트에 접속한 곳이 정말 해당 서버와 일치하는지 보증해주는 장치이다.<br />
이러한 인증서를 관리해주는 공인된 기관들을<br />
Certificate Authority 라고하며 대표적으로 AWS가 있다.</p>

<p>TLS 핸드쉐이크를 정리해보자면</p>

<ol>
  <li>Client -&gt; Server에게 헬로 요청</li>
  <li>Server -&gt; Client 인증서를 포함해서 헬로 응답 (개인키로 암호화하여 전달)</li>
  <li>Client는 내장된 CA 리스트를 보고 인증서를 확인한다. (개인키-&gt;공개키 복호화)</li>
  <li>Client가 CA의 공개키로 복호화를 통해 인증서를 검증했다면 Client는 대칭키를 만든다.</li>
  <li>이 대칭키를 서버의 공개키로 암호화해서 Client -&gt; Server에 전달한다.</li>
  <li>그럼 Server는 서버의 개인키로 복호화하여 클라이언트의 대칭키를 확인한다. (공개키-&gt;개인키 복호화)</li>
  <li>Server -&gt; Client의 대칭키로 샘플 데이터를 암호화해서 클라이언트에게 보내서 확인한다.</li>
  <li>Client는 서버에게 받은 데이터를 대칭키로 복호화해서 서로 대칭키를 잘 가지고 있는지 확인한다</li>
  <li>이 후에는 Client와 Server는 서로 대칭키로 암호화와 복호화를 진행하여 데이터를 전송한다</li>
</ol>

<p>사실 이런 일련의 과정들은<br />
브라우저와 서버가 해당 과정을 대신 처리해주기 때문에<br />
개념과 순서정도만 이해하면 좋을 것 같다.</p>

<p><br /></p>

<h4 id="로컬-환경에서-테스트">로컬 환경에서 테스트</h4>
<p>그럼 로컬환경에서 인증서 발급과 <br />
Https 서버를 구현하는 간단한 예제를 살펴보자</p>

<p>우선 Tomcat WAS를 사용하기위해<br />
스프링부트로 프로젝트를 만들었고</p>

<p>로컬환경에서 인증서를 만들기위해 터미널로 mkcert를 설치해야한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>mkcert
</code></pre></div></div>
<p>homebrew를 이용해 mkcert 설치</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkcert <span class="nt">-install</span>
</code></pre></div></div>
<p>PKCS12 형식 인증서를 생성할 수 있도록 설치</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkcert <span class="nt">-pkcs12</span> localhost
</code></pre></div></div>
<p>내가 만든 프로젝트 resources 경로에서<br />
위의 명령어를 실행시켜 PKCS12 인증서를 생성해주면</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmSGGxmFhNDI5InKLm5xBczg_DBOgwK4OJj_PGLONuWvOCIyDPyNnQBHZR2LmGmp5KEwzXwK3MxI2-ryG8RDepbN8HRYxw=w3024-h1614" alt="image" class="align-left" style="max-width: 50%" /></p>

<p>위와 같이 resources에 <br />
localhost.p12 인증서가 생긴다.</p>

<p>인증서가 생겼다면 application.properties 안에</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">server.ssl.key-store</span><span class="p">=</span><span class="s">classpath:localhost.p12</span>
<span class="py">server.ssl.key-store-type</span><span class="p">=</span><span class="s">PKCS12</span>
<span class="py">server.ssl.key-store-password</span><span class="p">=</span><span class="s">changeit</span>
</code></pre></div></div>
<p>와 같이 입력해주면 https로 서버를 사용가능하다.<br />
여기서 비밀번호는 초기해 셋팅을 하지않으면 changeit으로 입력하면된다.</p>

<p>그리고 스프링 애플리케이션을 실행시키면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmThmekJqkRGtjmJemxwLYuP9uTAyLwsOWuvrxTqsdCdOtk4pnyAXTjmlQ8MrR_5PaU4rYOu8DZll_u-Qvzy1E2s4UGW7A=w3024-h1614" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>사진과 같이 https로 서버 구현된 것을 확인할 수 있다.</p>

<p><br /></p>

<h3 id="hasing">Hasing</h3>
<p>어떤한 문자열에 임의의 연상을 적용하여 <br />
다른 문자열로 변환하는 것을 Hasing이라고 한다.</p>

<p>즉, 해싱한다는 의미는 어떠한 값을 암호화해준다 생각하면 될 것 같다.<br />
여기서 해싱의 특징을 적어보자면</p>

<ol>
  <li>모든 값에 대한 해시값을 계산하는데 오래걸리지 않아야한다.</li>
  <li>최대한 해시값을 피해야 하며, 모든 값은 고유한 해시값을 가진다.</li>
  <li>아죽 작은 단위의 변경이라도 완전히 다른 해시값을 가져야한다.</li>
</ol>

<h3 id="salt">Salt</h3>
<p>암호화해야 하는 값에 어떤 별도의 값을 추가하여 결과를 변형하는 것이다.<br />
영어로 소금이라는 뜻과 걸맞게 무언가 간을치는 느낌이라 생각하면 될 것 같다.</p>

<p>Salt의 큰 특징을 4가지 살펴보면</p>

<ol>
  <li>유저와 패스워드 별로 유일한 값을 가져야 한다.</li>
  <li>사용자 계정을 생성할 때와 비밀번호를 변경할 때 마다 새로운 임의의 Salt를 사용해서 해싱해야 한다.</li>
  <li>절대 재사용하지 말아야한다.</li>
  <li>DB의 유저테이블에 같이 저장 되어야한다.</li>
</ol>

<h3 id="cookie">Cookie</h3>

<p>쿠키는 서버가 웹 브라우저에 정보를 저장하고 불러올 수 있는 수단<br />
이라고 생각하면 간단할 것 같다.</p>

<p>우리가 이전에 배운 Http 프로토콜은<br />
무상태성(stateless)은 이전에 했던 작업에 대해 기억하지 않는 특성을 가지는데<br />
검색을 하려는데 검색목록이 아래 표시된다든지<br />
로그인 기억버튼을 눌러놓았는데 다음에 열어도 눌려져있다든지<br />
우리는 요청을 보낼때 무상태성으로 동작하기때문에 이러한 내용들을 기억하지 못 하는데<br />
브라우저에서 쿠키라는 것을 이용해 이러한 내용들을 저장해 사용할 수 있는 것이다.</p>

<p>한마디로 서버가 클라이언트에서 요청을 받고<br />
클라이언트쪽에 응답할때 쿠키에 데이터를 싦어서 보내면<br />
브라우저에서 쿠키값을 유지시키고 사용한다고 보면될 것 같다.</p>

<p>쿠키의 옵션으로는</p>

<p>domain - 서버와 요청의 도메인이 일치하는 경우 쿠키 전송<br />
path - 서버의 요청의 세부 경로가 일치하는 경우 쿠키 전송<br />
maxage/expires - 쿠키의 유효기간 설정<br />
httpOnly - 스크립트의 쿠키 접근 가능 여부 설정<br />
secure - HTTPS 에서만 쿠키 전송 여부 설정<br />
sameSite - 같은 사이트에서만 쿠키를 사용할 수 있게 하는 설정</p>

<h3 id="session">Session</h3>

<p>세션은 인증해주는 방법으로<br />
여러 페이지에 걸쳐 사용되는 사용자 정보를 저장하는 방법이다.</p>

<p>세션은 중요한 데이터를 서버에 저장하고 암호화된<br />
세션id를 쿠키에 담아 클라이언트에 전달하고<br />
세션id가 부여된 브라우저는 신분증같이 이를 이 유저는 인증에 성공했다고 알리며<br />
다른 요청을 보낼때 마다 해당 세선id로 인증을 거치며 사용할 수 있게된다.</p>

<p><br />
<br /></p>

<p><strong>쿠키와 세션의 비교</strong></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: center">Cookie</th>
      <th style="text-align: center">Seesion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>설명</td>
      <td style="text-align: center">쿠키는 그저 http의 stateless<br />한 것을 보완해주는 도구</td>
      <td style="text-align: center">접속 상태를 서버가 가짐<br /> 접속 상태와 권환 부여를 위해<br />세션아이디를 쿠키로 전송</td>
    </tr>
    <tr>
      <td>접속 상태<br />저장 경로</td>
      <td style="text-align: center">클라이언트</td>
      <td style="text-align: center">서버</td>
    </tr>
    <tr>
      <td>장점</td>
      <td style="text-align: center">서버에 부담을 덜어줌</td>
      <td style="text-align: center">신뢰할 수 있는 유저인지 서버에서 확인</td>
    </tr>
    <tr>
      <td>단점</td>
      <td style="text-align: center">쿠키 그자체는 인증이 아님</td>
      <td style="text-align: center">하나의 서버에서만 접속 상태를 가지므로 <br />서버분산에 불리</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<hr />

<p>오늘은 이렇게 인증, 보안에 관한 <br />
간단한 CS 지식들을 공부해보았는데<br />
사실 처음 듣는 개념들이라 아직 어떻게 쓰이는지 감을 잡기가 어렵다.</p>

<p>이러한 것들이 있고 후에 학습하면서<br />
이렇게 사용하는구나를 깨닫고 내것으로 체득을 해야할 것 같다.</p>

<p>오늘 공부는 여기서 끝 !</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 라면, 김밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[오늘은 드디어 인증과 보안관련된 공부가 시작되었다.]]></summary></entry><entry><title type="html">TIL) 세달차 회고</title><link href="http://localhost:4000/til/2022/11/16/til.html" rel="alternate" type="text/html" title="TIL) 세달차 회고" /><published>2022-11-16T00:00:00+09:00</published><updated>2022-11-16T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/16/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/16/til.html"><![CDATA[<p>어느덧 가을을 지나 겨울을 향해 달리고있다.<br />
시간은 멈추지 않는다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmR16i01UpPNroUzNknMVxn4tsIkhDV6gkngKajpEaMzj2xJ4E5Vyez__5rtpW5xjh_1Acwk1IZjAcZmfys0znB7kYUlsA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>내가 느끼는 한국사회에서의 시간은<br />
조금더 빠른 것 같다는 생각이드는 요즘.</p>

<p>공부에 대한 재미와 열망이 강해지고 있다.<br />
좋은 징조인 것 같다는 생각도들고, 공부하면할 수록 더욱더<br />
파고들어 알고싶다는 욕심이 가득해진다.</p>

<p>현재 단계에서 학습에 어느정도 방해가 되는 요소라고 생각한다.<br />
알면서도 한가지에 대해 계속 파다보니 다른 공부들을<br />
전부 학습하기에 시간이 많이 허비되고 비효율적이라는  점을 발견했다.</p>

<p>어느덧 개발공부한지 세달차가 되어버린<br />
나의 일상과 회고를 작성해보려한다.</p>

<hr />

<h3 id="내가-배운-것">내가 배운 것?</h3>
<p>지난 세달간 배운 것을 나열하자면<br />
엄청나게 많은 내용들이 있다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmSXU951Um_58x0b3_0a2GfPEYsLXEs-jRIv8ABUveSo7Iw5c_T-fB_Qq0joTmnrxVKOQF2vwPY=w1512-h753" alt="image" class="align-left" style="max-width: 80%" /></p>

<p>Java와 JavaScrpit도 구분하지 못하는 내가<br />
어느덧 Java와 Spring Framework를 사용하고 있으니<br />
느리지만 대단한 발전이라고 생각한다.</p>

<p>이번 한달은 Spring에 대해 집중적으로 공부하는 시간이였다.<br />
Spring MVC, 애플리케이션 계층, Spring 예외처리,<br />
Spring JDBC,JPA,Transaction, JUnit, APi 문서 자동화 등<br />
기본적인 지식부터 Spring을 이용한 웹애플리케이션<br />
설계와 구현에 대한 전반적인 내용들을 다루어보았었다.</p>

<p>한달동안 정말이지 가장 유익했던 공부를 많이한 것 같다.  <br />
이유는 당연하게도 실무에서 사용되는 기술들을 배웠다는 점이 가장 컸고<br />
해당 기술로 어느정도 웹애플리케이션을 만드는 구조에대해 익힌 것 같아서이다.</p>

<p><br /></p>

<h3 id="세달-간-나의-루틴은">세달 간 나의 루틴은?</h3>
<p>인간이란 생물은 참 신기한 것 같다.<br />
복잡한 감정을 느끼게 되어 행복할 수도 불행할 수도 있는 것 같으니,,</p>

<p>이번달은 사실 가장 복잡한 감정을 많이 느낀 달이다.<br />
오랜기간 같은걸 반복하다보면 목표가 흐려지고 지치기 마련이다.<br />
나도 난이도가 증가하는 학습과 학습량 그리고 반복되는 일상에<br />
어느정도 번아웃이 왔었고, 마음가짐을 여러번 고쳐먹었었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmRlTDexto7K3zOvG3HYqMS_zovg7kMNMWV_JL6QzWm5fP4TRqS5b9iNtWo3ee1ln1iJUhg2uR-djF3gZupYtWSzYRNn=w3024-h1614" alt="image" class="align-left" style="max-width: 80%" /></p>

<p>세달 동안 거의 루틴이 동일하다.<br />
<strong>콘텐츠 학습(09:00~18:00) -&gt; 복습 및 TIL 작성(19:00~21:00) -&gt; 강의 공부 및 예습(21:00~)</strong><br />
위와 같은 루틴으로 계속 공부해왔고, 중간에 리프레쉬를 위해<br />
운동도 해보고 여러가지를 시도해보았지만, 침대에서 쉬었다가 <br />
다시 공부하는게 가장 나한테 집중을 할 수 있게 해주는 요인으로 확인했다.</p>

<p>강의는 주로 Infren 김영한님의 강의를 듣고있고<br />
지식적으로나 인간적으로 매우 배울점이 많은 분이신 것 같다는 생각이 든다.<br />
하신 말씀중에 너무나도 기억에 남는게</p>

<p>열정은 금방식는다. 무언가 도전을한다면<br />
몰입할 수 있는 시스템을 만들어서 거기에 나를 던지라는 말이 너무나도 와닿았다.  <br />
현재 내가 그런 상태이기 때문에, 열정보단 내가 공부하는<br />
루틴과 시스템을 만들어 잘 지키도록 노력을 해야겠다고 생각했고</p>

<p>나도 저렇게 멋지게 성장해야겠다는 마음을 항상 다지고있다.</p>

<p><br /></p>

<h3 id="다음달은-어떻게-보낼-것인가">다음달은 어떻게 보낼 것인가?</h3>

<p>지난 세달간 열심히 달려왔고<br />
항상 해오던 것들은 유지할 생각이다.</p>

<p>데일리 루틴으로 항상 하는것은</p>
<ol>
  <li>1일 1커밋하여 잔디심기 (의미있는 것들로)</li>
  <li>TIL 블로그 작성하기</li>
</ol>

<p>이렇게 2가지는 항상 해오고 있다.<br />
주말에는 못하더라도 부족했던 부분에 대한 복습과 프로젝트때<br />
필요할 것 같은 기술에 대한 예습을 주로하는 편이다.<br />
이 부분들은 나와 잘 맞는 것 같고, 성장에 도움이된다 생각하여<br />
매번 실천할 생각이다.</p>

<p>오랜 공부시간동안 운동을 나갔다오거나<br />
다른 것으로 리프레쉬하는 방법을 많이 취해보았는데<br />
크게 도움은 없다고 깨달았고, 누워서 정신을 맑게<br />
쉬는 것이 최고의 방법이라 생각하여 이 부분도 계속 이렇게 공부에<br />
집중할 수 있도록 유지할 생각이다.</p>

<p><br /></p>

<p>그리고 공부하면서 깨달은 안좋은 습관들을 발견했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmRpTAUYSI-GUgK5uUnr4WgRsY_BsNfK-teJ_Bu1og9-RxJlO8Q1HRRnCY01NZUpfNaJdscM7wwPNseuLvdUlc7ZLff_5w=w1920-h864" alt="image" class="align-left" style="max-width: 40%" /></p>

<ol>
  <li>공부중 카카오톡과 SNS를 수시로 들어간다.</li>
  <li>노래를 들으면서 공부한다.</li>
  <li>오늘 공부의 목표점에 도달하면 다음공부를 미룬다.</li>
</ol>

<p>처음에는 대수롭지 않게 생각하고 있던 습관들이다.<br />
최근에 공부를하면서 내집중을 흐리는데 가장 큰 역할을 한다고 생각했고 <br />
학교처럼 공부시간에 철저하게 시스템을 갖춰<br />
거기안에서 내가 실천할 수 있게끔 공부하는 방식으로 개선을 했다.</p>

<p>이 개선방법으로 계속 공부해나아갈 생각이고<br />
3번과 같은 경우, 다들 그런지는 모르겠지만… 오늘의 학습량을<br />
마치고 나면 그냥 시간이 남아도 쉬어버리는 문제가 있었다.</p>

<p>마음의 안심이랄까? 오늘할꺼 다했다! 라는 생각이 들어서<br />
공부를 안하게되어서, 억지로라도 인프런 강의를 켜서<br />
듣기 시작하다보니 이제 그 시간이 재밋어지기 시작하고있다.<br />
뭐든지 실천하는게 가장 어렵듯이 강의를 키기까지가 제일 어렵지만<br />
막상 키고나면 재밌어서 계속 듣게되는 효과가 있는 것 같다.</p>

<p><br /></p>

<p>그리고 가장 공부가 필요하다고 생각하는 부분이 드는게 있다.<br />
물론 현재 배우고있는 Spring 관련 공부는 계속해야하는 것이지만<br />
이제 슬슬 <strong>정규식관련 문법, 알고리즘 공부</strong>를 준비해야할 것 같다는 생각이든다.</p>

<p>다음달 학습을 어느정도 마친후<br />
알고리즘 공부도 체계적으로 진행해볼 예정이다.<br />
다양한 문제를 접하기 보다는, 한가지 유형의 문제를 많이 풀어<br />
먼저 익숙해지는 방법을 가지고 범위를 확장시켜 나아갈 생각이다.</p>

<p><br /></p>

<h3 id="마치며">마치며</h3>

<p>어렸을 때 부터, 여러가지를 많이 경험해보고 싶었고<br />
어떻게 하다보니까 지금에서야 개발자 준비를 하게되었다.</p>

<p>적지않은 나이에 준비를 시작하자니 불안감과 상대적 비교가<br />
나를 가장 불안하게 했던 달이었던 것 같다.</p>

<p>최근에 가장 감명깊게 보았던 것 중에서<br />
조금 오그라들거나 별거 아닌 것 처럼 느끼는 분들도 있을 것 같긴한데<br />
나한테는 큰 임펙트로 다가와서 얘기해보려한다.</p>

<p>내가 가장 많이하는 게임.. 리그오브레전드<br />
나 같은 겜돌이들은 당연히 이번년도에 열리는 결승전 경기를 보았을 거라 생각한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmTXoT1HvGMR6nEoy_n4kpu1lcISRNm8bgZN4eeS86_HASrkFdxrDDPt7RLkMKW6DR-q62hJyo-QTUpuNjaoKCC-c5o59w=w1920-h864" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>DRX Deft 선수가 10년의 역경을 이기고 우승 트로피를 들어올리는 장면이다.<br />
아마 역대 가장 스토리가 좋은 결승전으로 꼽힐거고<br />
롤을하는 유저들이라면 백퍼센트 공감할 것 같다.</p>

<p>한국에서도 가장 낮은 시드로 월즈에 진출해<br />
가장 약한팀으로 평가받았고 누구도 우승할거라 예상하지 못했을 거다.<br />
결승하는 과정도 진짜 순탄치않았고, 나는 그과정들을 다챙겨 보았었다.</p>

<p>올라가는 과정 중 데프트 선수가 했던 얘기가 기사화 되어<br />
기사의 작명으로 <strong>‘중요한건 꺽이지 않는 마음’</strong> 이라는 말이 밈이되었고 명언이되었다.</p>

<p>누구에겐 장난처럼들리고 별 것 아닌 것 처럼 들릴 수 있겠지만<br />
지금 개발자로 커리어 전환하려는 나의 마음이 가볍지 않았기 때문에<br />
나에겐 이 문구가 꽤나 크게 다가왔다.</p>

<p>단순히 컨텐츠적으로 재미로 소모할 수 있었겠지만<br />
내 마음의 큰 변화가 생겼고, 그 동안 나는 너무 가볍게 공부하지 않았을까?<br />
정말 죽어라 고생하면서 공부하고있니? 라는 물음들이<br />
가슴속에 던져졌고 나는 이를 계기로 조금 더 성장하면서<br />
나아가야겠다는 마음을 가지게 된 것 같다.</p>

<p><br /></p>

<p>이상 세달차 공부 중인 <br />
나란 사람의 회고를 적어본다.</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[어느덧 가을을 지나 겨울을 향해 달리고있다. 시간은 멈추지 않는다.]]></summary></entry></feed>