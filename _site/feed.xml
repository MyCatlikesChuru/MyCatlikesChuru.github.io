<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-12T17:17:22+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LeeJellan</title><subtitle>안녕하세요!🙂 IT,여행,기타 등 기록을 남기기위한 블로그 입니다 !</subtitle><author><name>LEE JAEHYEOK</name></author><entry><title type="html">TIL) API Documentation 1</title><link href="http://localhost:4000/til/2022/11/11/til.html" rel="alternate" type="text/html" title="TIL) API Documentation 1" /><published>2022-11-11T00:00:00+09:00</published><updated>2022-11-11T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/11/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/11/til.html"><![CDATA[<p>요번주도 한주가 지나간다.<br />
얼마 공부한 것 같은느낌이 아닌데 벌써<br />
월요일이지나 금요일이 되었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmQk4K8CSftTVVdvYx3CCxrYZD4T2BrAhtXL4imWit5EO503BT7GHs58m2U-u9Ff8-jqsP6WkToRyaKKm_g388y_S6IT=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>저번주에 본 리그오브레전드 월즈 결승전을 감명깊게 보아서 그런지  <br />
내 마음 한켠에 불안하고 안정적이지 못한 지금의 삶에<br />
많이 지쳐하고 있었는데, 많은 위로가 되었다.</p>

<p>‘중요한건 꺽이지 않는 마음’ 참 잘 만든 문구인 것 같다.<br />
나도 꺽이지 않고 나아가는 모습을 발견할 수있도록<br />
더욱더 노력해보아야겠다.</p>

<hr />
<p>3일간 JUnit에 대한 공부를 했다. <br />
여러 API를 사용해보면서 계층별로 단독으로<br />
테스트할 수 있는 Mockito라는 좋은 API를 배웠다.</p>

<p>오늘은 이것에 연장선상인 API 문서화에 대해 공부해보는 날이다.</p>

<p><br /></p>

<h2 id="spring-rest-docs">Spring Rest Docs</h2>

<p>API 문서화라고하면<br />
클라이언트에서 REST API 백엔드 애플리케이에<br />
요청을 전송하기 위해서 알아 되는 요청 정를 문서로 정리한 것이다.<br />
(URI, request body, query parameter 등..)</p>

<p>Spring Rest Docs는 이 문서를 자동으로 만들어주는 API이다.<br />
기존에는 Swagger 오픈 API를 많이 이용하였다고 한다.</p>

<p>Spring Rest Docs 문서 생성 흐름<br />
테스트 코드 작성</p>
<ol>
  <li>test 테스크 실행</li>
  <li>테스트 결과 Passed / Failed 1번으로 복귀</li>
  <li>API 문서 스니펫 생성(.adoc)</li>
  <li>API 문서 생성(.adoc)</li>
  <li>API 문서 -&gt; HTML로 변환</li>
</ol>

<p>위와 같은 흐름으로 API 문서가 생성되며<br />
테스트 케이스에 통과한 테스트의 API 문서 <strong>스니핏</strong>이 생성된다.<br />
*스니핏: 문서의 일부 조각이라 생각하면 된다.</p>

<p>Spring Rest Docs를 사용하기 위해 사전 작업을 하여야한다.<br />
build.gradle의 설정해주자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plugins</span> <span class="o">{</span>
	<span class="n">id</span> <span class="s">"org.asciidoctor.jvm.convert"</span> <span class="n">version</span> <span class="s">"3.3.2"</span>
        <span class="o">...</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="n">ext</span> <span class="o">{</span>
	<span class="n">set</span><span class="o">(</span><span class="err">'</span><span class="n">snippetsDir</span><span class="err">'</span><span class="o">,</span> <span class="n">file</span><span class="o">(</span><span class="s">"build/generated-snippets"</span><span class="o">))</span>    <span class="c1">// 스니펫 생성 경로 설정</span>
<span class="o">}</span>

<span class="n">configurations</span> <span class="o">{</span>
	<span class="n">asciidoctorExtensions</span> <span class="c1">// AsciiDoctor 의존그룹 지정            </span>
<span class="o">}</span>

<span class="n">dependencies</span> <span class="o">{</span>
    <span class="c1">// 의존라이브러리 추가 </span>
	<span class="n">testImplementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">restdocs</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">restdocs</span><span class="o">-</span><span class="n">mockmvc</span><span class="err">'</span>                         
	<span class="n">asciidoctorExtensions</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">restdocs</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">restdocs</span><span class="o">-</span><span class="n">asciidoctor</span><span class="err">'</span>
        <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// test task실행 시, API 문서 생성 스니핏 경로를 설정</span>
<span class="n">tasks</span><span class="o">.</span><span class="na">named</span><span class="o">(</span><span class="err">'</span><span class="n">test</span><span class="err">'</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">outputs</span><span class="o">.</span><span class="na">dir</span> <span class="n">snippetsDir</span>
	<span class="nf">useJUnitPlatform</span><span class="o">()</span>
<span class="o">}</span>

<span class="c1">// Asciidoctor 기능을 사용하기 위한 설정</span>
<span class="n">tasks</span><span class="o">.</span><span class="na">named</span><span class="o">(</span><span class="err">'</span><span class="n">asciidoctor</span><span class="err">'</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">configurations</span> <span class="s">"asciidoctorExtensions"</span>
	<span class="n">inputs</span><span class="o">.</span><span class="na">dir</span> <span class="n">snippetsDir</span>
	<span class="n">dependsOn</span> <span class="n">test</span>
<span class="o">}</span>

<span class="c1">// index.html copy</span>
<span class="n">task</span> <span class="nf">copyDocument</span><span class="o">(</span><span class="nl">type:</span> <span class="nc">Copy</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">dependsOn</span> <span class="n">asciidoctor</span>         
	<span class="n">from</span> <span class="nf">file</span><span class="o">(</span><span class="s">"${asciidoctor.outputDir}"</span><span class="o">)</span>  
	<span class="n">into</span> <span class="nf">file</span><span class="o">(</span><span class="s">"src/main/resources/static/docs"</span><span class="o">)</span>  
<span class="o">}</span>

<span class="c1">// copyDocument가 먼저 실행되도록 설정</span>
<span class="n">build</span> <span class="o">{</span>
	<span class="n">dependsOn</span> <span class="n">copyDocument</span> 
<span class="o">}</span>

<span class="c1">// bootJar task 설정</span>
<span class="n">bootJar</span> <span class="o">{</span>
	<span class="n">dependsOn</span> <span class="n">copyDocument</span>   
	<span class="nf">from</span> <span class="o">(</span><span class="s">"${asciidoctor.outputDir}"</span><span class="o">)</span> <span class="o">{</span> 
		<span class="n">into</span> <span class="err">'</span><span class="kd">static</span><span class="o">/</span><span class="n">docs</span><span class="err">'</span>    
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>build.gradle 설정이 끝났다면 이제 코드를 작성해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebMvcTest</span><span class="o">(</span><span class="nc">MemberController</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@MockBean</span><span class="o">(</span><span class="nc">JpaMetamodelMappingContext</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="c1">//@Transactional</span>
<span class="c1">//@SpringBootTest</span>
<span class="c1">//@AutoConfigureMockMvc</span>
<span class="nd">@AutoConfigureRestDocs</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberControllerRestDocsTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">MemberMapper</span> <span class="n">mapper</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">Gson</span> <span class="n">gson</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postMemberTest</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">MemberDto</span><span class="o">.</span><span class="na">Post</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberDto</span><span class="o">.</span><span class="na">Post</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">,</span> <span class="s">"이재혁"</span><span class="o">,</span> <span class="s">"010-1234-5678"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">gson</span><span class="o">.</span><span class="na">toJson</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>

        <span class="nc">MemberDto</span><span class="o">.</span><span class="na">response</span> <span class="n">responseDto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberDto</span><span class="o">.</span><span class="na">response</span><span class="o">(</span>
                <span class="mi">1L</span><span class="o">,</span>
                <span class="s">"dhfif718@naver.com"</span><span class="o">,</span>
                <span class="s">"이재혁"</span><span class="o">,</span>
                <span class="s">"010-1234-5678"</span><span class="o">,</span>
                <span class="nc">Member</span><span class="o">.</span><span class="na">MemberStatus</span><span class="o">.</span><span class="na">MEMBER_ACTIVE</span><span class="o">,</span>
                <span class="k">new</span> <span class="nf">Stamp</span><span class="o">()</span>
        <span class="o">);</span>

        <span class="n">given</span><span class="o">(</span><span class="n">mapper</span><span class="o">.</span><span class="na">memberPostToMember</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">any</span><span class="o">(</span><span class="nc">MemberDto</span><span class="o">.</span><span class="na">Post</span><span class="o">.</span><span class="na">class</span><span class="o">))).</span><span class="na">willReturn</span><span class="o">(</span><span class="k">new</span> <span class="nc">Member</span><span class="o">());</span>
        <span class="n">given</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">createMember</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">any</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">))).</span><span class="na">willReturn</span><span class="o">(</span><span class="k">new</span> <span class="nc">Member</span><span class="o">());</span>
        <span class="n">given</span><span class="o">(</span><span class="n">mapper</span><span class="o">.</span><span class="na">memberToMemberResponse</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">any</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">))).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">responseDto</span><span class="o">);</span>

        <span class="nc">ResultActions</span> <span class="n">actions</span> <span class="o">=</span> <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span>
                <span class="n">post</span><span class="o">(</span><span class="s">"/api/members"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">content</span><span class="o">)</span>
        <span class="o">);</span>


        <span class="n">actions</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.email"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getEmail</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.name"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.phone"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getPhone</span><span class="o">()))</span>

                <span class="o">.</span><span class="na">andDo</span><span class="o">(</span><span class="n">document</span><span class="o">(</span>
                        <span class="s">"post-member"</span><span class="o">,</span>
                        <span class="n">getRequestPreProcessor</span><span class="o">(),</span>
                        <span class="n">getResponsePreProcessor</span><span class="o">(),</span>
                        <span class="n">requestFields</span><span class="o">(</span>
                                <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"email"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"이메일"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"name"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"이름"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"phone"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"휴대폰 번호"</span><span class="o">)</span>
                                <span class="o">)</span>
                        <span class="o">),</span>
                        <span class="n">responseFields</span><span class="o">(</span>
                                <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">OBJECT</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"결과 데이터"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data.memberId"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">NUMBER</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"회원 식별자"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data.email"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"이메일"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data.name"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"이름"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data.phone"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"휴대폰 번호"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data.memberStatus"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">STRING</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"회원 상태"</span><span class="o">),</span>
                                        <span class="n">fieldWithPath</span><span class="o">(</span><span class="s">"data.stamp"</span><span class="o">).</span><span class="na">type</span><span class="o">(</span><span class="nc">JsonFieldType</span><span class="o">.</span><span class="na">NUMBER</span><span class="o">).</span><span class="na">description</span><span class="o">(</span><span class="s">"스탬프 갯수"</span><span class="o">)</span>
                                <span class="o">)</span>
                        <span class="o">)</span>
                <span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>기존 코드와 달라진점은 
@WebMvcTest(MemberController.class)          <br />
@MockBean(JpaMetamodelMappingContext.class)  <br />
어노테이션으로 변경하였다는 점이다.<br />
이전에 SpringBootTest와 AutoConfigureMockMvc를 사용했던 부분을<br />
변경하였다. WebMveTest로 변경 함으로써 Controller 계층에 사용하는<br />
Bean만 등록하기때문에 상대적으로 속도가 빠르다고 한다.</p>

<p>또한, @AutoConfigureRestDocs 어노테이션을 붙여주었고<br />
.andDo(docment())를 이용해 Rest Docs에 필요한 정보를 보내주었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">restdocs</span><span class="o">.</span><span class="na">payload</span><span class="o">.</span><span class="na">PayloadDocumentation</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">restdocs</span><span class="o">.</span><span class="na">mockmvc</span><span class="o">.</span><span class="na">MockMvcRestDocumentation</span><span class="o">.</span><span class="na">document</span><span class="o">;</span>
</code></pre></div></div>
<p>document(), fieldWithPath(), requestFields() <br />
필요한 정보를 만드는 과정에서 위 api를 사용하기위해선<br />
PayloadDocumentation, MockMvcRestDocumentation을 import 해주어야한다.</p>

<p>그리고 patch 핸들러 메서드에 대해 path parameter를 이용할 경우</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">restdocs</span><span class="o">.</span><span class="na">request</span><span class="o">.</span><span class="na">RequestDocumentation</span><span class="o">.</span><span class="na">pathParameters</span><span class="o">;</span>
</code></pre></div></div>
<p>를 스태틱으로 import 해주면 사용이 가능하다.</p>

<p><br /></p>

<p>Document()의 매개변수로 전달하기위해 <br />
OperationRequestPreprocessor<br />
OperationResponsePreprocessor<br />
클래스를 이용해 인터페이스안에 정적 메서드를 만들어 구현하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ApiDocumentUtils</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="nc">OperationRequestPreprocessor</span> <span class="nf">getRequestPreProcessor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">preprocessRequest</span><span class="o">(</span><span class="n">prettyPrint</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="nc">OperationResponsePreprocessor</span> <span class="nf">getResponsePreProcessor</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">preprocessResponse</span><span class="o">(</span><span class="n">prettyPrint</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>getRequestPreProcessor() <br />
getResponsePreProcessor()<br />
아리는 메서드를 만들었고 해당 내용엔 OperationPreprocessor 클래스의<br />
메서드인 prettyPrint()로 객체를 주입해주었다.</p>

<p>API 문서를 생성 전 전처리를 수행하는 기능이라는데<br />
해당 내용에 대해서는 조금더 깊은 학습이 필요해 보인다.</p>

<p>또한 Document() 매개변수인<br />
requestFields와 responseFields를 List.of로 <br />
문서화 시킬 내용을 설명과 함께 담아 전달하도록<br />
내용을 작성하였다.</p>

<p><br /></p>

<p>여기까지 작성후 테스트 케이스를 실행하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmQkvJ4wiPE1h_7rk6WxVw-45PCgHTiM7tPBoXPQp9BI9-0QNhkyLJ9dvyFDgh1FIcoc9NAzwN1MqviHV234SBgKq-Fudw=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우리가 build.gralde에서 ext로 설정해놓은 경로<br />
build/generated-snippets 안에 스니핏 식별자로<br />
post-member로 지정해여 해당 폴더안에 .adoc 파일이 생긴 모습을 볼 수 있다.</p>

<p>실제 내용을 확인해보면 우리가 원하는<br />
API 내용들이 담겨져있다.</p>

<p>그리고 Gradle 프로젝트의 경우<br />
src/docs/asciidoc 폴더 경로에서 index.adoc 파일을 생성한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmSP6yS5JEcQYvdmCiJBkQnCg6AjwPkGkEPL4LLA99PvGdapaJxSgq3S0yUGWaItGJc-VGK1hETfSnrBJQuxYueo82_6=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>index.adoc파일에 Asciidoc 문법으로<br />
템플릿 코드를 넣어 Gradle의 :build, :bootJar을  <br />
실행시켜주면 index.html</p>

<p>gradle의 설정했던 task copyDocument의 경로인<br />
src/main/resources/static/docs 안에 index.html 파일로  <br />
우리의 API문서가 변환된 모습을 볼 수 있다.</p>

<p>그리고 최종적으로 Spring Boot를 실행시켜<br />
index.html에 접근해보면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmRVSbop-au0zBS7T5VYwEbIIprDpuG7rQJQI3FpLPJncTS0N-xC6MLCi11JQdcFK3cWv2I50pjxUYkTgLFp5FArYVMaog=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우리가 원하는 모습대로 API 문서가 작성된 모습을 확인해 볼 수 있다.<br />
(해당 템플릿 코드는 코드스테이츠 교육자료로 제공된 템플릿이므로<br />
템플릿 코드는 따로 올리지 않겠습니다!)</p>

<hr />

<p>이렇게 오늘은 간단한 것 같으면서도 어려운…<br />
SpringRestDocs를 사용하는 법을 알아보았고</p>

<p>초기 셋팅만 gradle에 잘 해놓고 템플릿 코드만 준비되어있다면<br />
크게 어려운점은 없었던 것 같다.</p>

<p>매우 유익했던 Test케이스를 이용한 API 자동화 작업.<br />
엄청 신기하고 재밌었다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 핫도그, 빵</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[요번주도 한주가 지나간다. 얼마 공부한 것 같은느낌이 아닌데 벌써 월요일이지나 금요일이 되었다.]]></summary></entry><entry><title type="html">TIL) JUnit 3</title><link href="http://localhost:4000/til/2022/11/10/til.html" rel="alternate" type="text/html" title="TIL) JUnit 3" /><published>2022-11-10T00:00:00+09:00</published><updated>2022-11-10T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/10/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/10/til.html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPEtAIsYVHYZngjJKd7DhE7QvwO4nT5RQrbx3n7Hgtx83b5wSHcAK9fgNs42_a12-wjBXSB7EmmaORw8NUf4CEwXDJY2g=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>드이어 JUnit 관련해서 마지막 시간이다.<br />
테스트 프로그램을 작성하는 연습도 틈틈히 해둬야<br />
까먹지 않고 계층별 테스트가 원활하게 잘 될 것 같다.</p>

<p>새로운걸 알면알수록 재미있지만<br />
내 뇌용량의 초과로,,, 전에 배웠던 내용들이 슬슬<br />
휘발되기 시작한다 ㅋㅋ…</p>

<p>복습 하는시간도 마련해야 할 것 같은 느낌이다</p>

<hr />

<p>어제는 <a href="https://mycatlikeschuru.github.io/til/2022/11/09/til.html">계층별 테스트</a>에 대해서 간단하게 포스팅 해보았다.<br />
사실 계층별 테스트라고 작성을 했지만<br />
진정한 Slice 테스트가 되는 프로그램이 아니였고<br />
계층별 테스트를 위한 문법을 사전에 공부한느 시간이었다.</p>

<p>오늘은 정말 애플리케이션 계층별로 테스트를<br />
진행하려면 어떻게해야하는지?</p>

<p>테스팅 기술에 대해 배워보는 시간이다.</p>

<h2 id="mockito">Mockito</h2>

<p>오늘 공부할 api는 Mockito라는 테스트를 위한 api이다.</p>

<p>우리가 평상시에 Mock이라고하면 가짜를 얘기한다.<br />
목업폰과 같이 실제 기능은 없지는 모양만있는 가짜이다.</p>

<p>이와 같은 기술로 객체를 가짜로 만들어 계층별 테스트하는 방법이다.</p>

<p>너무나게 당연하게도 다른 계층을 접근하지 않으니<br />
테스트시간이 확실히 빨라지게되며<br />
계층별로 테스트를 해볼 수 있다는 장점이 있다.</p>

<h3 id="controller-계층-slice-test">Controller 계층 Slice Test</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmTnXpBWUcCganXkdulhuUs7yIiBV4jduubimbBhkIH1II-o-KZ6mUljknzsuWm-0Hf-czO1b7FkvAxK-aJEpMiHDGar9Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>간단하게 Controller 계층만 두고 얘기해보자<br />
어제 <a href="https://mycatlikeschuru.github.io/til/2022/11/09/til.html">JUnit 2</a> 챕터에서 테스트해보았던건<br />
왼쪽에서 보는 것과 같은 형태의 ‘통합 테스트’라고 볼 수 있다.</p>

<p>이유는 핸들러메서드를 호출해 Service -&gt; Repository 까지<br />
접근해 Controller 계층이 잘 실행되는지를 알아보았기 때문이다.</p>

<p>이제 우리가 해볼거는 Mock 객체를 만들어<br />
Test를 호출하면 Controller 계층만 독단적으로<br />
테스트할 수 있는 방법이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberControllerHomeworkTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">Gson</span> <span class="n">gson</span><span class="o">;</span>

    <span class="nd">@MockBean</span> <span class="c1">// 추가부분</span>
    <span class="kd">private</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Autowired</span> <span class="c1">// mppaer 사용을 위한 추가</span>
    <span class="kd">private</span> <span class="nc">MemberMapper</span> <span class="n">mapper</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">postMemberTest</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>코드를 예제로 살펴보자</p>

<p>이전과 달라진점은 @MockBean이 추가되었다는 점이다.<br />
SpringBoot를 사용하는 어노테이션을 달아주었기때문에</p>

<p>@MockBean을 필드변수에 붙여주면<br />
해당 객체에 Bean과 같은 타입의 객체가 DI된다.</p>

<p>즉 MemberService 클래스 객체가 주입되므로<br />
우리는 가짜로 만들어진 memberService 객체로 메서드들을 호출할 수 있다.</p>

<p>@Test 프로그램을 작성해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">postMemberTest</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">MemberDto</span><span class="o">.</span><span class="na">Post</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberDto</span><span class="o">.</span><span class="na">Post</span><span class="o">(</span>
            <span class="s">"dhfif718@naver.com"</span><span class="o">,</span>
            <span class="s">"이재혁"</span><span class="o">,</span>
            <span class="s">"010-1234-5678"</span>
    <span class="o">);</span>

    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">memberPostToMember</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setStamp</span><span class="o">(</span><span class="k">new</span> <span class="nc">Stamp</span><span class="o">());</span>

    <span class="n">given</span><span class="o">(</span><span class="n">memberService</span><span class="o">.</span><span class="na">createMember</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">any</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">))).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

    <span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">gson</span><span class="o">.</span><span class="na">toJson</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>

    <span class="nc">ResultActions</span> <span class="n">actions</span> <span class="o">=</span> <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span>
            <span class="n">post</span><span class="o">(</span><span class="s">"/api/members"</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">content</span><span class="o">)</span>
    <span class="o">);</span>

    <span class="nc">MvcResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">actions</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.email"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getEmail</span><span class="o">()))</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.name"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
            <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.phone"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getPhone</span><span class="o">()))</span>
            <span class="o">.</span><span class="na">andReturn</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>대부분은 자바 문법적인 요소이고<br />
중요한 부분은 given(); api 쪽이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">mockito</span><span class="o">.</span><span class="na">BDDMockito</span><span class="o">.</span><span class="na">given</span><span class="o">;</span>
</code></pre></div></div>
<p>해당 라이브러리를 import 해야 사용이 가능하고</p>

<p>given(); 메서드를 통해서 우리는 가짜 객체를 만들 수 있다.</p>

<p>given() : 가짜로 만들 메서드 지정<br />
willRetrun() : 가짜로 만든 반환 값 지정<br />
이렇게 생각하면 간단 할 것 같다.</p>

<p>여기서 @MockBean을 통해 의존성 주입받은 객체의<br />
memberSerive.createMember()를 given()안에 넣어주었고<br />
해당 .createMember()의 매개변수가 Member.class 타입이므로<br />
Mockito.any(Member.class) 라고 설정을 해두었다.</p>

<p>여기서 만약 다른 타입일 경우에<br />
Mockito.anyInt()<br />
Mockito.anyLong()<br />
Mockito.anyString()<br />
등 여러가지 메서드들도 제공하고 있다.</p>

<p><br /></p>

<p>테스트 코드를 이렇게 작성하면<br />
가짜객체로 리턴값을 우리가 정해서 넘겨줄 수 있다.<br />
Controller 계층 프로그램을 봐보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@PostMapping</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">postMember</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">MemberDto</span><span class="o">.</span><span class="na">Post</span> <span class="n">requestBody</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">memberPostToMember</span><span class="o">(</span><span class="n">requestBody</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setStamp</span><span class="o">(</span><span class="k">new</span> <span class="nc">Stamp</span><span class="o">());</span> <span class="c1">// homework solution 추가</span>

    <span class="nc">Member</span> <span class="n">createdMember</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">createMember</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nc">ResponseEntity</span><span class="o">&lt;&gt;(</span>
            <span class="k">new</span> <span class="nc">SingleResponseDto</span><span class="o">&lt;&gt;(</span><span class="n">mapper</span><span class="o">.</span><span class="na">memberToMemberResponse</span><span class="o">(</span><span class="n">createdMember</span><span class="o">)),</span>
            <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">CREATED</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위에서 보듯이 memberService.createMember(member);<br />
메서드를 호출하는 시점에서 우리의 가짜 객체의 반환값이<br />
대신 createdMember 객체로 할당되게 되어진다.</p>

<p>그렇게 되면 Service 계층을 접근하지않고<br />
우리가 만든 Mock으로만으로 Controller를 테스트 해 볼 수 있는 것이다.</p>

<p><br /></p>

<h3 id="service-계층-slice-test">Service 계층 Slice Test</h3>

<p>Controller 계층을 테스트할 때에는 SpringBootTest를 이용했다.<br />
스프링 부트를 실행시키는 시간도 포함하면<br />
시간이 느려질 수 있는 단점이 있지만 Controller 계층은<br />
spring web servlet 기술을 사용하기에 포함시켰었다.</p>

<p>하지만 Service 계층은 SpringBoot 없이도<br />
Mockito API를 이용해 Serivce 계층만 테스트가 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmT11Owrzo9GJ8WW4G2Oo2z7sh78eNqCI7yo5XbMPJ_0mlZQKHtsqqku8nDD_99cQhCgmaZ-OBsms1m9QJdQuPEvf_ijUw=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 테스트가 이루어지고<br />
Repository 계층과의 연결도 끊고 Mock 객체로만<br />
테스트를 할 수 있다는 점이 중요하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberServiceMockTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="kd">private</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>


    <span class="nd">@InjectMocks</span>
    <span class="kd">private</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">createMemberTest</span><span class="o">()</span>  <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Controller과는 다르게 @ExtendWith 어노테이션을 이용해<br />
Mockito API를 사용할 수 있다.</p>

<p>여기서 우리가 테스트할 계층은 memberService 계층이고<br />
가짜로 만들어야할 객체는 memberRepository이다</p>

<p>그런 개념에서 @Mock을 memberRepository에 붙이고 <br />
@InjectMocks를 memberService에 붙여주면</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MemberService</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">memberRepository</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="o">...</span>
</code></pre></div></div>
<p>Service 계층의 Repository에 Mock객체가<br />
자동으로 의존성 주입이된다.</p>

<p>그리하여 우리가 Repository를 Mock 객체를 사용할 수 있는 것이다.</p>

<p><br /></p>

<p>이제 테스트 예제코드를 봐보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">createMemberTest</span><span class="o">()</span>  <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">,</span><span class="s">"이재혁"</span><span class="o">,</span><span class="s">"010-1234-5678"</span><span class="o">);</span>

        <span class="n">given</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">.</span><span class="na">findByEmail</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">())).</span><span class="na">willReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
        <span class="c1">//given(memberRepository.findByEmail(Mockito.anyString())).willReturn(Optional.of(member));</span>

        <span class="n">assertThrows</span><span class="o">(</span><span class="nc">BusinessLogicException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">memberService</span><span class="o">.</span><span class="na">createMember</span><span class="o">(</span><span class="n">member</span><span class="o">));</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>검증을 어떻게하는지에 따라 달리지겠지만<br />
Member 객체를 생성하는 serive 클래스 메서드를 테스트하기위해<br />
새로운 Member 객체를 만들어 검증할 것이다.</p>

<p>given()으로 Controller 계층에서 했던것과 동일하게<br />
가짜로만들 메서드의 형식과 매개타입을 입력해준다음<br />
리턴값으로 어떤 객체를 받을지 정해주면된다.</p>

<p>최종적으로 동일한 Member가 발견되어<br />
Exception을 잡아 검증하는 프로그램으로 작성하였다.</p>

<p>우리가 잘라줘야하는부분은 Repositroy의 findByEmail();로 정의한 부분이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Member</span> <span class="nf">createMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">verifyExistsEmail</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
    <span class="nc">Member</span> <span class="n">savedMember</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">savedMember</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">verifyExistsEmail</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findByEmail</span><span class="o">(</span><span class="n">email</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">BusinessLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span><span class="o">.</span><span class="na">MEMBER_EXISTS</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>MemberService 로직은 너무 간단하게<br />
기존 member와 email을 비교해 같은 email이 존재하면<br />
throw Exception을 하게 되어있다.</p>

<p>우리는 위에서 메서드 호출할때의 매개변수 “dhfif718@naver.com”과<br />
결과로 반환된 객체의 email “dhfif718@naver.com” 결과적으로 같기 때문에<br />
if(member.isPresent()) 조건에 성립되<br />
Exception을 던지게되어 Serivce 로직을 검증해볼 수 있다.</p>

<p>자연스럽게 예외가 던져지므로 해당 Service 로직은 종료되고<br />
.save()까지 검증할 필요가 없어진다.<br />
save를 검증하는 것은 사실 비지니스로직을 검증하는 것보단<br />
Repository를 검증하는 것에 가깝기 때문에<br />
Serivce 계층에서 검증하는 로직을 굳이 작성하지 않아도 될 것 같다.</p>

<p><br /></p>

<h3 id="오늘-만난-에러">오늘 만난 에러</h3>

<p>이렇게 위에서 Controller과 Service 계층을 분리해서<br />
따로 따로 테스트할 수 있게 프로그램을 작성하고<br />
정상적으로 수행되는 모습을 볼 수 있었다.</p>

<p>Mockito라는 API를 처음 사용하다보니<br />
여러가지 에러들을 만났고 그중에 기억남는 에러를 적어본다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancelOrderTest</span><span class="o">(){</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
    <span class="kt">long</span> <span class="n">orderId</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">findOrder</span> <span class="o">=</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="n">given</span><span class="o">(</span><span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">getOrderId</span><span class="o">())).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">findOrder</span><span class="o">);</span>
    <span class="n">assertThrows</span><span class="o">(</span><span class="nc">BusinessLogicException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">orderService</span><span class="o">.</span><span class="na">cancelOrder</span><span class="o">(</span><span class="n">orderId</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위와 같이 테스트 코드를 작성후 실행시켜 보았는데</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AJc5JmTitd8kl31KKTTaIB7nQrL7AvxwT54hIPaJEcnmdlC5BhBrezzcRcqyhYeyWzO1aK7O1OYjVG_yqk2EYkUVRD6lZHWCiw=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>misusing.PotentialStubbingProblem 이라는 에러를 만났다.<br />
잠재적인 Stubbing 문제라면서 예외가 잡혔다.</p>

<p>코드를 열심히 보다보니..<br />
given()안의 매개변수로 order.getOrderId()를 넣어주고 있었고<br />
cancelOrder();메서드 호출하는 매개변수에는 orderId를 넣어주고 있었다.</p>

<p>여기서 order객체가 만들어질때 Long타입으로 null로 만들어졌고<br />
타입이 잘못들어간 상태로 테스트 코드를 실행하니까 위와 같은 에러가 발생했다.</p>

<p>해결은</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">given</span><span class="o">(</span><span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="nc">Mockito</span><span class="o">.</span><span class="na">anyLong</span><span class="o">())).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">findOrder</span><span class="o">);</span>
</code></pre></div></div>
<p>위와 같이 타입을 Mockito.anyLong()을 붙여서 해결이 가능하고<br />
order.serOrderId(orderId);를 통해서 값을 넣어주어도<br />
문제가 해결이 가능하다.</p>

<hr />

<p>오늘 공부는 여기까지 했고<br />
JUnit관련해서 Slice 테스트에 대해 자세히 배울 수 있어서<br />
너무 유익한 시간이였다.</p>

<p>한가지 아쉬운점은 많은 api중에서도 한정적인 것만 사용해보았기에<br />
지식층이 얕은점..?이 조금 아쉬웠고<br />
이후에 프로젝트하기전에 테스트 관련 여러 메서드들을 공부한다음<br />
테스트 코드를 작성해봐야겠다.</p>

<p>오늘 공부는 여기서 끝 !</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 카레, 라면, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL) JUnit 2</title><link href="http://localhost:4000/til/2022/11/09/til.html" rel="alternate" type="text/html" title="TIL) JUnit 2" /><published>2022-11-09T00:00:00+09:00</published><updated>2022-11-09T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/09/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/09/til.html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmR_RuNelXZR9wXYkkDNPxOHlFm1gfwD72mlxFWutdJvtLpD7ODhrLzTuczuHNHObb4Iq-3wmnCTJcm2yUGGaGj76Ho1Xw=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>늘상 같은일의 반복이다.<br />
지루하면서도 행복한 일상의 반복이다.</p>

<p>반복적인 학습에 지치기도 하지만<br />
새로운 지식습득의 즐거움이 너무크기때문에<br />
오늘도 열심히 공부해보려한다.</p>

<hr />

<p>어제는 Test라는 개념과<br />
Spring Boot의 Default 프레워크인 JUnit에 대해서도<br />
간단히 사용하는 클래스와 어노테이션등을 알아보았다.</p>

<p>오늘은 웹애플리케이션 계층별로 테스트하는<br />
슬라이스 테스트에대해 알아볼 예정이다.</p>

<h2 id="controller-계층-테스트">Controller 계층 테스트</h2>
<p>Controller 계층을 테스트하기위해서는<br />
기본적으로 Postman으로 핸들러 매서드를 호출하여<br />
JSON 객체를 주고 응답받는 방식을 사용했었다.</p>

<p>하지만 이모든 것도 자동화시키고 더욱 프로그래머답게 테스트하기위해선<br />
테스트 코드로 Controller 계층을 테스트해볼 필요가 있다.</p>

<h3 id="mockmvc">MockMvc</h3>

<p><strong>@AutoConfigureMockMvc</strong> 어노테이션은 Controller 테스트를 위한 애플리케이션의<br />
자동 구성 작업을 해준다. 이중 우리는 MockMvc 같은 클래스의 기능을 사용할 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>    
<span class="nd">@AutoConfigureMockMvc</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ControllerTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>
    
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postTest</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>테스트 파일의 @SpringBootTest 어노테이션 붙여<br />
Application Context를 생성하고<br />
MockMvc클래스를 사용하기 위한 어노테이션 @AutoConfigureMockMvc를<br />
붙여준 다음 @Autowired로 의존성 주입을 시켜주면 된다.</p>

<p>그렇게 되면 .perfrom(); 이라는 메서드를 사용하여<br />
POST, GET, DELETE, PATCH 등<br />
핸들러 메서드들을 자유롭게 이용할 수 있게 되어진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ResultActions</span> <span class="n">actions</span> <span class="o">=</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span>                       
            <span class="n">post</span><span class="o">(</span><span class="s">"/api/coffees"</span><span class="o">)</span> 
                <span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span> 
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">)</span> 
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">content</span><span class="o">)</span> 
        <span class="o">);</span>
</code></pre></div></div>
<p>간단한 코드 예제를 살펴보자 perform을 통해<br />
uri와 핸들러 메서드 방식 설정을해주고<br />
응답받을 객체 타입 .accept();<br />
전송할 컨텐츠 타입 .contentType();<br />
전송할 컨텐츠 .content();<br />
를 호출하여 각각의 내용들을 담아주면 Controller에서 작성한<br />
api가 호출되게 되어진다.</p>

<p>여기서 반환된 객체는 <strong>ResultActions</strong>이라는 타입으로 반환되면<br />
후에 검증하는 용도로 사용되어진다.</p>

<p>핸들러 메서드(post(),get(),patech())를 사용하기 위해서는</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">web</span><span class="o">.</span><span class="na">servlet</span><span class="o">.</span><span class="na">request</span><span class="o">.</span><span class="na">MockMvcRequestBuilders</span><span class="o">.*;</span>
</code></pre></div></div>

<p>MockMvcRequestBuliders를 import해야 사용이 가능하다.</p>

<p><br /></p>

<h3 id="json-객체-받기">Json 객체 받기</h3>

<p>여기서 우리는 JSON 객체를 주고받는 것으로 설정했고<br />
Json 객체를 만들기 위해 Google Json 라이브러리를 사용했다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implementation</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">code</span><span class="o">.</span><span class="na">gson</span><span class="o">:</span><span class="nl">gson:</span><span class="mf">2.8</span><span class="o">.</span><span class="mi">7</span><span class="err">'</span>
</code></pre></div></div>

<p>사용법은 간단하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">Gson</span> <span class="n">gson</span><span class="o">;</span>
</code></pre></div></div>
<p>필드의 Gson 객체를 주입받도록 설정 후</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CoffeeDto</span><span class="o">.</span><span class="na">Post</span> <span class="n">post</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Coffee</span><span class="o">.</span><span class="na">Post</span><span class="o">(</span>
        <span class="s">"아메리카노"</span><span class="o">,</span>
        <span class="s">"Americano"</span><span class="o">,</span>
        <span class="mi">4500</span>
<span class="o">);</span>
<span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">gson</span><span class="o">.</span><span class="na">toJson</span><span class="o">(</span><span class="n">post</span><span class="o">);</span>
</code></pre></div></div>
<p>우리가 Dto 용도로 만들었던 클래스의<br />
해당 타입의 맞는 객체를 gson.toJson(); 안에 넣어주면<br />
String 타입으로 반환되게 되어진다.</p>

<p>그렇게 반환된 객체로 .content();안에 담에주게 되면 끝이다.</p>

<p><br /></p>

<h3 id="mvcresult">MvcResult</h3>
<p>위에서 언급했던 ResultAction 타입의 객체로<br />
여러가지 검증 메서드들을 사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MvcResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">actions</span>
        <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
        <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.korName"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getKorName</span><span class="o">()))</span>
        <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.engName"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getEngName</span><span class="o">()))</span>
        <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.data.price"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">post</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()))</span>
        <span class="o">.</span><span class="na">andReturn</span><span class="o">();</span>
</code></pre></div></div>
<p>.andExpect(); 메서드로 검증을 할 수 있다.<br />
actions객체는 ResultAction 타입이며</p>

<p>status().isCreated() -&gt; 응답 상태에 대한 검증 (OK,NOT FOUND 등등..)<br />
jsonPath().value() -&gt; 응답받은 Json 객체의 데이터를 검증</p>

<p>추가로 .andReturn(); 메서드를 사용하게되면<br />
MvcResult 클래스 타입으로 반환되는데<br />
해당 클래스의 메서드로 Json 객체를 문자열로 출력하는 것도 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getResponse</span><span class="o">().</span><span class="na">getContentAsString</span><span class="o">());</span>
</code></pre></div></div>
<p>위와 같이 getResponse().getContentAsString(); 메서드를<br />
이용하여 실제 어떻게 응답받았는지 출력해볼 수 있다</p>

<p><br /></p>

<h2 id="service-계층-테스트">Service 계층 테스트</h2>

<p>데이터 엑세스 계층을 테스트하기 위해서는<br />
한 가지 규칙이있다.</p>

<p>DB의 상태를 테스트 케이스 실행 이전으로 되돌려 놓는다.<br />
라는 규칙이 있다.</p>

<p>이유는 말하지 않아도 알 수 있다.<br />
테스트케이스 실행을하는 데이터를 남겨둘 이유가 없기 때문이다.</p>

<p>가장 원초적인 방법으로는 <br />
@BeforeEach - 테스트 레코드 생성 , @AfterEach - 테스트 레코드 삭제<br />
정도 생각해볼 수 있을 것 같다. 하지만 데이터 생성 후<br />
로직에서 예외가 발생하거나하면 데이터가 잔존하는 문제가 생길 수도 있다.</p>

<p>@Transactional 애노테이션을 테스트 클래스에<br />
붙여놓고 Test를 진행하면, 테스트 완료후 rollback();이<br />
되어지기 때문에 편리하게 테스트를 할 수 있다.</p>

<h3 id="datajpatest">@DataJpaTest</h3>
<p>Spring에서 데이터 엑세스 계층을 테스트 하기 위해<br />
만들어둔 어노테이션이다.</p>

<p>해당 어노테이션을 추가함으로써, Jpa 기술을 사용하는<br />
Repository의 기능을 정상적으로 사용하기 위한<br />
Configuration을 Spring이 자동으로 해주게 된다.<br />
그리고 해당 어노테이션은 @Transactional을 포함하고 있기에<br />
위에서 설명했던 rollback 처리까지 되어진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@DataJpaTest</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeRepositoryTest</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">CoffeeRepository</span> <span class="n">coffeeRepository</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">(){</span>
        <span class="o">...</span>
    <span class="o">}</span>
    
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test2</span><span class="o">(){</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>사용 방법은 Controller보다 간단하다. <br />
JPA를 상속받는 Repository를 의존성 주입시킨 객체를 이용하고</p>

<p>@DataJpaTest를 클래스레벨에 붙여주면<br />
트랜잭션이 보장된 Service 계층 테스트가 가능한<br />
Test 클래스가 만들어 진다.</p>

<p><br /></p>

<hr />

<p>오늘은 Controller 계층을 테스트 하기위한<br />
여러가지 API들을 알아보았다.<br />
확실히 Postman으로 테스트할때는 눈으로 보이지만<br />
프로그램으로 테스트할때 예외발생이라든지, 오류발생이 생기면<br />
한눈에 문제파악하는게 쉽지는 않은 것 같고<br />
연습이 필요할 것 같다.</p>

<p>오늘 공부도 여기서 끝 !</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김치찌개, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">TIL) JUnit 1</title><link href="http://localhost:4000/til/2022/11/08/til.html" rel="alternate" type="text/html" title="TIL) JUnit 1" /><published>2022-11-08T00:00:00+09:00</published><updated>2022-11-08T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/08/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/08/til.html"><![CDATA[<p>오늘따라 눈을 뜨기가 힘들었다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRtGpeYtviYIzfeRp5N9UsAFv4DyoXncCtpBv_yEBy2yHuy6nlv2NoLtIhafrvn3BC3SJSlY-XIggHVKpNsrfQ-cfUeRQ=w1512-h808" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>오랜만에 잠에서 이겨내지 못하는 아침이었다…<br />
정말 한결같기는 진짜 어렵다는 생각도 들고<br />
참 나약하구나라는 생각도 든다.</p>

<p>그래도 오늘은 비교적 쉬운 주제이기 때문에<br />
열심히 공부해보자 !!</p>

<hr />
<p>어제는 트랜잭션에 대해 알아보았다.<br />
기본적으로 선언형 방식을 이용해보았다. 속성에 대해서는<br />
깊은 공부가 이루어지지는 않았다.<br />
트랜잭션의 기본 동작원리와 적용시 어떻게 처리가되는지?<br />
정도 확인을 해보았다.</p>

<p>오늘은 비교적 난이도가 쉬운 주제인 Testing에 대해 공부해볼 예정이다.</p>

<h2 id="test">TEST</h2>
<p>테스트는 여러가지 분야에서 많이 들어봤을 것 같다.<br />
무었이든지 출시하기전에는 검증과 테스트가 거쳐진다.</p>

<p>프로그램에서의 테스트는 내가 작성한 로직에 대한<br />
검증이고, 여러가지 예외상황을 가정해 테스트를 진행해볼 수 있다.</p>

<h3 id="unit-test">Unit Test</h3>
<p>단위테스트라고 직역할 수 있다.<br />
단위 테스트는 이름에서 오듯이 단위를 정해 테스트를 진행한는 것이다.<br />
비지니스 로직에서 사용하는 클래스들이 독립적으로 테스트하기<br />
가장 좋은 대상이기 때문에 단위테스트라고 부르는 경우가 많다.</p>

<p>우리가 작성한 메서드 단위로 테스트를 한다고 생각하면 될 것 같다.<br />
그 외에 전체단위로 보았을 때 여러 테스트가 있다.</p>

<ol>
  <li>기능 테스트
-&gt; 클라이언트, 애플리케이션, DB 까지 테스트하는 과정</li>
  <li>통합 테스트
-&gt; 애플리케이션, DB까지 테스트하는 과정</li>
  <li>슬라이드 테스트
-&gt; 애플리케이션 특정 계층을 쪼개어서 하는 테스트</li>
</ol>

<p><br /></p>

<h3 id="test-express">Test Express</h3>
<p>Given-When-Then 방식으로 표현을 한다.<br />
BDD(Behavior Driven Development)라는 테스트 방식의 용어이다.</p>

<p><strong>Given</strong><br />
-&gt; 테스트를 위한 준비과정을 명시<br />
-&gt; 테스트에 필요한 전제 조건들이 포함된다.</p>

<p><strong>When</strong><br />
-&gt; 테스트할 동작을 지정한다.<br />
-&gt; 테스트할 메서드 호출을 하는 부분이다.</p>

<p><strong>Then</strong><br />
-&gt; 테스트의 결과를 검증하는 영영이다.<br />
-&gt; Assertion과 같은 클래스로 검증을하는 부분이다.</p>

<p><br /></p>

<h3 id="junit">JUnit</h3>
<p>우리는 Java언어로 만들어진 애플리케이션을 테스트하기위해서<br />
오픈 소스 테스트 프레임워크인 JUnit을 사용하게 된다.<br />
(Spring Boot의 Default 테스트 프레임워크가 Junit이다)</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTUGtth7qi-Z3xGykSHbxfz7SkPIuHfT_kXClFjYRN9M2CbsLZ4nY0Eu-CfahjOSV00vSWx_g5kPmxUZDMn9iQdpfKttQ=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위 사진과 같이 스프링 프로젝트를 만들 경우<br />
test 패키지가 생긴다 안에 패키지를 만들어 다양한 <br />
테스트 케이스를 만들어 로직을 검증해볼 수 있다.</p>

<p>기본적인 사용방법은 간단하다.</p>

<p>클래스를 만들어<br />
매서드에 @Test 어노테이션을 붙여 테스트 해볼 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JunitTest</span> <span class="o">{</span>
    
    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"Test 1"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">assertionTest</span><span class="o">(){</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>어노테이션에 대해 공부한 것들을 적어본다</p>

<p>@BeforeEach<br />
-&gt; 테스트 실행중 먼저 실행되어지는 메서드에 붙여준다.<br />
-&gt; 각테스트 매서드가 실행되기전 실행한다.</p>

<p>@BeforeAll<br />
-&gt; 테스트 실행중 딱한번만 실행되어지는 메서드에 붙여준다.<br />
-&gt; Test 클래스 실행전 한번만 실행된다.<br />
-&gt; 그러므로 정적 메서드여야 한다 (static)</p>

<p>@AfterEach<br />
-&gt; 테스트 실행중 실행완료후 실행되어지는 메서드에 붙여준다.<br />
-&gt; 각테스트 메서드가 실행되고난후 실행한다.</p>

<p>@AfterAll<br />
-&gt; 위에 내용과 같으니 참조</p>

<p>@DisplayName(“”)<br />
-&gt; 메서드에 붙여주면, 해당 어노테이션의 이름을 커스터마이징 할 수 있다.</p>

<p>@SpringBootTest<br />
-&gt; 테스트 클래스에 붙여준다 <br />
-&gt; 테스트실행시, 스프링을 띄운다음 스프링을 사용할 수 있게된다.<br />
-&gt; 즉, 애플리케이션에서 컨테이너에 담아둔 빈들을 주입할 수 있다.</p>

<p>@TestConfiguration<br />
-&gt; 테스트 안에서 내부 클래스를 만들어서 사용하면서 이 어노태이션을 붙이면 <br />
스프링 부트가 자동으로 만들어주는 빈들에 추가로 필요한 스프링 빈들을 등록하고 테스트를 수행할 수 있다.</p>

<p>@AutoConfigureMockMvc<br />
-&gt; MockMvc 기능을 사용하기위한 애노테이션 <br />
-&gt; Controller 슬라이스 테스트를 진행한다고 가정하면 <br />
Controller 테스트를 위한 애플리케이션의 자동 구성 작업을 해준다.<br />
-&gt; 주입받은 객체는 .perform()을 이용해 http매세더 요청가능</p>

<p><br /></p>

<p>사용 방법을 알았으니 이제 검증하는 방법도 알아야한다.<br />
검증할때 사용하는 클래스들이 여러가지 있다.</p>

<p>1). Assertions 클래스<br />
-&gt; assertJ 패키지의 클래스를 가져와야 사용가능<br />
-&gt; .assertThat(); 같은 매서드로 검증해주는 기능들을 제공해줌</p>

<p>.assertThat();<br />
-&gt; 다양한 검증 메서드들을 제공</p>

<p>.assertThatThrownBy();<br />
-&gt; assertThat과 동일하게 메서드를 제공하지만 예외를 확인할 수 있다.</p>

<p>.isTure();<br />
-&gt; 앞의 내용이 참이면 테스트 성공</p>

<p>.isFalse();<br />
-&gt; 앞의 내용이 거짓이면 테스트 실패</p>

<p>.isEqualTo<br />
-&gt; 값이 동일하면 테스트 성공</p>

<p>2.) Assertions 클래스<br />
-&gt; jupiter 패키지의 클래스를 가져와야 사용가능</p>

<p>.assertEquals();<br />
-&gt; 기대값이 실제값과 같은지 비교<br />
-&gt; 좌측이 기대값, 우측이 실제값<br />
-&gt; ex) assertEquals(“a”,”a”);</p>

<p>.assertNotNull();<br />
-&gt; Null값이 아니면 검증 통과, 아니면 Fail<br />
-&gt; ex) assertNotNull(변수, 매세지);</p>

<p>.assertThrows();<br />
-&gt; 기대하는 Exception타입과 내용을 입력한다.  <br />
-&gt; 기대하는값이 Exception 타입과 맞지 않을 경우에는 테스트 실패<br />
반대로 타입과 같을경우에는 성공<br />
-&gt; ex) assertThrows(NullPointerException.class, ()-&gt; 호출메서드));</p>

<p>2). Assumption 클래스<br />
.assumeTrue();<br />
-&gt; 특정 조건에서 선택적인 테스트가 필요할때 사용</p>

<p>4). MatcherAssert 클래스<br />
   -&gt; JUnit 기반의 Assertion 프레임워크이다.<br />
   -&gt; 자연스러운 문장으로 이어지는 특성이있어 가독성 향상이 크다.<br />
   -&gt; hamcrest 패키지에 있음</p>

<p>.assertThat();<br />
-&gt; 다양한 검증 메서드를 제공해줌<br />
-&gt; ex) .assertThat(a, is(equalTo(null)));<br />
.is();<br />
.equalTo();<br />
.notNullValue();</p>

<p><br /></p>

<p>이 외에도 JUnit 기반으로 만들어진 프레임워크에서<br />
사용할 수 있는 클래스와 메서드들이 많이 있고<br />
이 부분은 지속적으로 테스트프로그램 작성하면서 습관을 들이면서<br />
지식의 범위를 늘려야할 것 같다.</p>

<hr />

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 카레,밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[오늘따라 눈을 뜨기가 힘들었다.]]></summary></entry><entry><title type="html">TIL) Spring Transaction 2 , Event 비동기 적용</title><link href="http://localhost:4000/til/2022/11/07/til.html" rel="alternate" type="text/html" title="TIL) Spring Transaction 2 , Event 비동기 적용" /><published>2022-11-07T00:00:00+09:00</published><updated>2022-11-07T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/07/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/07/til.html"><![CDATA[<p>날씨도 선선하니 기분좋은 월요일 시작이다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRr5ZBvzQfDcRqVd7ewr_sKrKf_aakwdPGUG0DNrGrEVbVty1HB4i1wRBumj0m52CTkK1XwtsJG106ORwGHwywrqfZjUg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>주말에 공부하는게 습관이 되어지다보니<br />
게임을하는 빈도수가 부쩍 줄었다.<br />
하루도 빠짐없이하던 내가 주말에 아주 잠깐정도만 하는 쾌거를 이뤘다.</p>

<p>오늘 공부한 것도 정리하고 이외 공부도 해보자 !!</p>

<hr />
<p>오늘은 트랜잭션의 마지막 시간이다.<br />
트랜잭션의 개념자체는 어렵게 느껴지지 않는데<br />
그 안에 있는 커넥션이 어떻게 연결되어지는지..<br />
등등 DB의 접근 방법에 대해 구조를 명확히 파악하지 못했던 점이<br />
가장 힘들었던 것 같다.</p>

<p>어제는 DB를 이용해 commit(); rollback(); 쿼리를 보내<br />
실제로 세션마다 다르게 보이고 동작하는걸 확인해 볼 수 있었다.<br />
오늘은 실제 코드에 적용해서 하는법을 배워보자</p>

<h2 id="transactional">@Transactional</h2>

<h3 id="사용방법">사용방법</h3>

<p>해당 어노테이션으로 말할 것 같으면<br />
AOP 기능까지 추가된 트랜잭션이라고 보면 될 것 같다.</p>

<p>Serivce 로직, 즉 비지니스 로직에서 트랜잭션을 적용해<br />
하나의 그룹으로 묶어 최종적으로 완료하면 commit();<br />
예외가 발생하면 rollback();을 시켜주어야한다.</p>

<p>하나의 비지니스 로직 메서드에는 여러종류의 쿼리가 들어갈 수도있다.<br />
조회(findAll) 후 생성(save)을 할 수 도 있는 것이고<br />
로직에 따라 DB에 접근 수가 늘어날 수도 있다.<br />
이 모든걸 하나의 트랜잭션으로 묶어 모두성공=commit, 실패=rollback<br />
이라고 생각하면 간단할 것 같다.</p>

<p>옛날에는 트랜잭션 매니저를 이용해 직접 작성했다고한다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTUoJ37QEpejnf7c71VPSO_r3ZdbX7CNXRfzh0MNJMn-ooo0Lib8xwQrmY6RS-ZDopydl6GyJi4FTwb9ZWRKx8BfBYKUA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>DB접근 방법에따라 트랜잭션매니저 구현체를 이용해<br />
트랜잭션을 커밋하고 롤백하며 관리했었다고 한다.</p>

<p><strong>예제)</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">accountTransfer</span><span class="o">(</span><span class="nc">String</span> <span class="n">fromId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">toId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">money</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
    <span class="c1">// 트랜잭션 시작</span>
    <span class="nc">TransactionStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">transactionManager</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">(</span><span class="k">new</span> <span class="nc">DefaultTransactionDefinition</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">//비지니스 로직</span>
        <span class="n">bizLogic</span><span class="o">(</span><span class="n">fromId</span><span class="o">,</span> <span class="n">toId</span><span class="o">,</span> <span class="n">money</span><span class="o">);</span>
        <span class="n">transactionManager</span><span class="o">.</span><span class="na">commit</span><span class="o">(</span><span class="n">status</span><span class="o">);</span><span class="c1">// 성공시 커밋</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">transactionManager</span><span class="o">.</span><span class="na">rollback</span><span class="o">(</span><span class="n">status</span><span class="o">);</span> <span class="c1">// 실패시 롤백</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>하지만 이렇게될 경우 try, catch문이나<br />
트랜잭션 매니저부분의 commit,rollback 등 반복적인 코드와<br />
트랜잭션 매니저를 사용하기위한 객체를 얻어야해야해서<br />
순수한 비지니스로직의 코드만 남지 못하게되어진다.</p>

<p>이러한 배경에서 Spring AOP를 적용을 할 수도 있지만<br />
@Transactional 애노테이션을 붙여주면 AOP까지 <br />
적용되어 깔금한 코드로 변경할 수 있다.</p>

<p><strong>예제)</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">accountTransfer</span><span class="o">(</span><span class="nc">String</span> <span class="n">fromId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">toId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">money</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">SQLException</span> <span class="o">{</span>
    <span class="n">bizLogic</span><span class="o">(</span><span class="n">fromId</span><span class="o">,</span> <span class="n">toId</span><span class="o">,</span> <span class="n">money</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 애노테이션을 붙여 트랜잭션을 적용하는 방법을<br />
<strong>선언형 방식의 트랜잭션 적용</strong>이라고한다.</p>

<p>클래스 레벨에 적용하는 방법과 매서드 레벨에 적용할 수 있고<br />
레벨에따른 적용범위가 결정되어진다.<br />
해당 애노테이션이 붙은 메서드와 클래스는<br />
자동적으로 트랜잭션 기능이 적용되어 서비스 로직 실행중<br />
Exception이 발생하게되어진다면 rollback();을 실행하게되어진다.</p>

<p><br /></p>

<h3 id="예외에-따른-처리">예외에 따른 처리</h3>

<p>하지만 Checked 예외와, Unchecked 예외가 서로 다르게 동작한다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTSLAOChGCHoy9NNwgmdECsc71qVVgUeTBzTSdKGAlH5tqp6IU6uhn2g81ChpPO6kV-uUGZ2-9bBermAPtxxrtbxdvTXw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>rollback();에 대한 차이가 있고<br />
Checked 에외는 반드시 예외처리를 해주어야한다.</p>

<p><br /></p>

<h3 id="transaction-전파">Transaction 전파</h3>

<p>트랜잭션 전파는 트랜잭션 경계에서 진행중인<br />
트랜잭션이 존재할때 또는 존재하지 않을 때<br />
어떻게 동작할 것인지를 결정하는 방식을 의미한다.</p>

<p>ex) @Transactional(propagation = Propagation.REQUIRED)</p>

<ol>
  <li>
    <p>Propagation.REQUIRED<br />
-&gt; 현재 진행 중인 트랜잭션이 존재하면 해당 트랜잭션을 사용하고<br />
존재하지 않으면 새 트랜잭션을 생성하도록 해준는 속성이다<br />
즉,서로 다른 서비스에서 다른 트랜잭션을 실행시키지 않게해주는 역할</p>
  </li>
  <li>
    <p>Propagation.REQUIRES_NEW <br />
-&gt; 이미 진행중인 트랜잭션과 무관하게 새로운 트랜잭션이 시작된다.<br />
기존에 진행중이던 트랜잭션은 새로운 시작된 트랙잭션이 종료할 때까지 중지된다.</p>
  </li>
  <li>
    <p>Propagation.MANDATORY<br />
-&gt; 진행중인 트랜잭션이 없으면 예외를 발생시킨다.</p>
  </li>
  <li>
    <p>Propagation.NOT_SUPPORTED<br />
-&gt; 트랜잭션을 필요로 하지않음을 의미한다.<br />
-&gt; 트랜잭션이 있으면 메서드 실행이 종료될때까지 진행중인 트랜잭션은 중지되며<br />
메서드 실행이 종료되면 트랜잭션을 계속 진행한다.</p>
  </li>
  <li>
    <p>Propagation.NEVER<br />
-&gt; 트랜잭션을 필요로하지 않음을 의미한다.<br />
-&gt; 진행 중인 트랜잭션이 존재할 경우에는 예외를 발생시킨다.</p>
  </li>
</ol>

<h3 id="transaction-격리-수준">Transaction 격리 수준</h3>
<ol>
  <li>
    <p>UNCOMMITED  <br />
-&gt; 커밋되지 않은 읽기<br />
-&gt; 다른 트랜잭션에서 커밋하지 않은 데이터를 읽는 것을 허용</p>
  </li>
  <li>
    <p>READ COMMITTED<br />
-&gt; 커밋된 읽기  <br />
-&gt; 다른 트랜잭션에 의해 커밋된 데이터를 읽는 것을 허용합니다.</p>
  </li>
  <li>
    <p>REPEATABLE READ<br />
-&gt; 반복 가능한 읽기 <br />
-&gt; 트랜잭션 내에서 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회되도록 합니다.</p>
  </li>
  <li>
    <p>SERIALIZABLE<br />
-&gt; 직렬화 가능<br />
-&gt; 동일한 데이터에 대해서 동시에 두 개 이상의 트랜잭션이 수행되지 못하도록 합니다.</p>
  </li>
</ol>

<p><br /></p>

<h2 id="event">Event</h2>
<h3 id="event-란">Event 란?</h3>
<p>Spring 내부에는 Evnet라는 매커니즘을 가지고 있다고한다.<br />
<strong>Bean과 Bean사이에 데이터를 전달하는 방법</strong>중 하나이다.</p>

<p>일반적으로는 스프링컨테이너의 빈을 주입할때 DI를 이용한다<br />
Evnet를 이용해 객체를 넘겨줄 수도 있다는 말이다.</p>

<p><br /></p>

<h3 id="evnet-사용방법">Evnet 사용방법</h3>
<p>사용방법은 간단하다</p>
<ol>
  <li>publisher(발행)로 이벤트를 발생시킨다</li>
  <li>listener로 이벤트를 받는다.</li>
</ol>

<p>publisher로 발행시키는 방법은 <br />
ApplicationEventPublisher 클래스의 .publishEvent();<br />
메서드를 통해서 발행시킬 수 있다.</p>

<p>트랜잭션과 연동시켜 한번 예제를 만들어보자</p>

<p>간단한 예제로 Member 클래스에는 여러가지 정보가 있다고 가정하고<br />
회원가입을 눌러 POST매서드를 통해 Service로직이 호출된다 가정해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Transactional</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ApplicationEventPublisher</span> <span class="n">publisher</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Member</span> <span class="nf">createMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">savedMember</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
        <span class="n">publisher</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberCreatedEvent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">savedMember</span><span class="o">));</span> <span class="c1">// 이벤트 발생시키기</span>
        <span class="k">return</span> <span class="n">savedMember</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>간단한 코드로 ApplicationEventPublisher 객체를 스프링컨테이너를 통해<br />
주입받은 객체 publisher로 이벤트를 발생시키는 메서드를 실행시킨다.<br />
해당 객체에는 Event 정보를 담은 객체가 들어있어야한다.</p>

<p>정보를 담은 객체를 따로 만들기위해 클래스를 만들었다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberCreatedEvent</span> <span class="kd">extends</span> <span class="nc">ApplicationEvent</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MemberCreatedEvent</span><span class="o">(</span><span class="nc">Object</span> <span class="n">source</span><span class="o">,</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">member</span> <span class="o">=</span> <span class="n">member</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>MemberCreatedEvent라는 객체를 Event하여<br />
우리는 이제 Listenr를 통해 객체를 받을 수 있다.</p>

<p>Listener 클래스를 만들어보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberCreatedEventListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">EmailSender</span> <span class="n">emailSender</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>
    
    <span class="nd">@EventListener</span> <span class="c1">// EventListener로 Event 객체 가져옴</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listener</span><span class="o">(</span><span class="nc">MemberCreatedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"message test"</span><span class="o">;</span>
            <span class="n">emailSender</span><span class="o">.</span><span class="na">sendEmail</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">MailSendException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"MailSendException, rollback"</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@EventListener 어노테이션을 사용한<br />
메서드는 Event로 발행한 객체를 가져올 수 있다.</p>

<p>Service 로직이 실행되어질때 Evnet 메서드를 만나는 순간<br />
제어의 흐름이 Listener 클래스로 넘어오게 되어진다.</p>

<p>위에 예제는 간단하게 email을 보내는 예제로 작성하였고<br />
메서드를 실행하면 5초뒤에 MailSendException이라는<br />
Checked Exception을 발생하게 코드를 작성하였다.</p>

<p>실제 로직을 실행할 경우</p>
<ol>
  <li>Service로직에서 Event 발행하여 Listener 호출</li>
  <li>Listener 클래스에서 Event 타입과 맞는객체를 찾아 객체를 주입</li>
  <li>.sendEmail(message)에서 Checked Exception 발생</li>
  <li>Checked Exception은 rollback이 안되기때문에 Unchecked <br />
Exception으로 다시 예외처리(RuntimeException)</li>
  <li>최종적으로 rollback하여 기존에 처리되어진 작업 종료</li>
</ol>

<p>위와 같이 동작하는 모습을 볼 수 있다.</p>

<p><br /></p>

<h2 id="async">@Async</h2>
<p>스프링 프레임워크에서 지원하는 비동기 처리 방식이다.<br />
해당 어노테이션을 이해하기 위해선 멀티쓰레드, 동기, 비동기에<br />
이해가 필요하다.</p>

<p>정말 간단하게 정리하자면<br />
동기 - 하나의 쓰레드에서 같은 제어흐름을 가짐<br />
비동기 - 멀티쓰레드로 서로 다르게 제어흐름을가짐</p>

<p>이라고 생각해볼 수 있을 것 같다.</p>

<p>간단하게 위에서 보았던 코드 예제로 본다면<br />
MemberService에서 하나의 쓰레드로<br />
Event를 발행시키고 Listener 메서드로 호출되게 되어<br />
최종적으로 Unchecked Exception이 발생하여<br />
rollback(); 되어지는 모습을 확인할 수 있다.</p>

<p>만약 위에 코드에서 @Async를 적용하여<br />
해당 메서드를 비동기로 가져갈 수가 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@RequiredArgsConstructor</span>
<span class="nd">@Slf4j</span>
<span class="nd">@EnableAsync</span> <span class="c1">// 비동기 사용가능하도록 설정</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberCreatedEventListener</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">EmailSender</span> <span class="n">emailSender</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">MemberService</span> <span class="n">memberService</span><span class="o">;</span>

    <span class="nd">@Async</span> <span class="c1">// 비동기로 이메일 전달하도록 변경</span>
    <span class="nd">@EventListener</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">listener</span><span class="o">(</span><span class="nc">MemberCreatedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"message test"</span><span class="o">;</span>
            <span class="n">emailSender</span><span class="o">.</span><span class="na">sendEmail</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">MailSendException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"MailSendException, rollback"</span><span class="o">);</span>
            <span class="n">memberService</span><span class="o">.</span><span class="na">deleteMember</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getMember</span><span class="o">().</span><span class="na">getMemberId</span><span class="o">());</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>@EnableAsync , @Async 어노테이션을 이용해<br />
listenr라는 메서드는 비동기상태가 되었다.<br />
즉, MemberSerivce 로직에서 호출하여도 제어의 흐름은<br />
MemberSerivce는 본인 쓰레드대로 진행하고</p>

<p>listenr 메서드는 별도의 쓰레드가 생겨 진행하게된다.</p>

<hr />
<p>오늘은 이렇게 Evnet와 Transaction에 대해<br />
조금 더 알아보는 시간을 가졌다.</p>

<p>대략적인 내용과 이해는 어느정도 된 것 같다.<br />
하지만 트랜잭션 어노테이션이 해주는 기능이 너무 풍부하기때문에<br />
오히려 내지식의 한계가 보여지는 것 같다.</p>

<p>실제 내부에서 어떻게 동작하는지를 알아야<br />
트래잭션에 대해 완벽히 이해했다고 할 수 있을 것 같다.<br />
지금은 대략 적인 그림으로만 머릿속에서 그려지지만<br />
후에 어드밴스한 공부를 통해 트랜잭션을 다시 정복해보자</p>

<p>오늘 공부는 여기서 끝!!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 카레, 김치찌개</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[날씨도 선선하니 기분좋은 월요일 시작이다.]]></summary></entry><entry><title type="html">TIL) Spring Transaction 1</title><link href="http://localhost:4000/til/2022/11/04/til.html" rel="alternate" type="text/html" title="TIL) Spring Transaction 1" /><published>2022-11-04T00:00:00+09:00</published><updated>2022-11-04T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/04/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/04/til.html"><![CDATA[<p>드디어 금요일이다 !!</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTMURddp7eS9p4eU_B_kWlUW2OZXswDZohNbNZsQyulns7guaGsjqClS9QHbeeZNzRPUp9PL-pgI6FXT-9PQEqibl_29Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>주말이 되어도 공부를할 것이기 때문에<br />
월요일까지 순삭당할 것 같다.</p>

<p>하나한 알아갈 수록 좀더 알고 싶은 마성의 기능들…<br />
너무 재밌다. 계속해서 공부하게된다.</p>

<hr />

<p>오늘은 트랜잭션에 대해 공부해보는 시간이다.<br />
여러번 들어봤고 아직 어떤 의미인지를<br />
정확히 알지못하니 공부해보도록하자</p>

<p><br /></p>

<h2 id="transaction">Transaction</h2>

<h3 id="transaction-이란">Transaction 이란?</h3>
<p>트랜잭션은 여러개의 작업들을 하나의 그룹으로<br />
묶어서 처리하는 처리 단위로, 물리적으로는 여러개의 작업이지만<br />
논리적으론 마치 하나의 작업으로 인식해서<br />
전부 성공 or 실패 의 결과로 하나로만 처리되어야하는 의미를 가진다.</p>

<p>예를 들어서, 계좌이체를 한다고 가정하였을 경우<br />
A라는 사람이 B라는 사람에게 계좌이체를 했을때<br />
A는 송금을 했지만 오류로인해 B가 받지 못했을 경우<br />
A의 돈만 빠지고 B는 받지못하는 상황이 생긴다. 이런 경우가 생긴다면<br />
서비스를 하지못할 정도의 큰 일이 나기때문에 송금이라는 작업단위가 있으면<br />
최종적으로 송금완료까지 하나의 트랜잭션으로 봐야하는 것이다.</p>

<p>트랜잭션을 얘기할때는 ACID 원칙을 이용한다.</p>

<h3 id="acid-원칙">ACID 원칙</h3>
<ol>
  <li>원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다.</li>
  <li>일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.</li>
  <li>격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준 (Isolation level)을 선택할 수 있다.</li>
  <li>지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.</li>
</ol>

<h3 id="db로-확인하는-예제">DB로 확인하는 예제</h3>
<p>우선 DataBase를 통해 개념을 확인해 볼 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQSexoFyUMZWpDWivlRkoPtfcQ3EoLXbMdi9AvRnh8SV8ty8-one4e3UBrV9O3-6YBbptYiajuOe45fpQfUQ_9wPMjh=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>간단한 예제를 위해 H2 데이터베이스를 사용했고<br />
쿼리로 각자 memberA, memberB에게 10000원을 넣어두었다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTdKis6NrWIeBPyfuYe62wOBUart4GIDHJxWqR8I5AnKeGNfAzgKf7ZUzlaqBP809jTGi3lWHsipeS_Oh5wCkFc7OjBww=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>예를 들어 가정해보자, memberA라는 사람이<br />
2000원을 B에게 준다고 가정하기위해 쿼리를 이용해 <br />
왼쪽 세션의 memberA라는 사람의 돈을 2000원 차감 시켰다.<br />
<em>(자동 커밋을 꺼주는 쿼리도 같이 넣었다.)</em></p>

<p>여기서 중요한점은 왼쪽과 오른쪽은 세션으로 나타낸 것이며<br />
총 두 개의 세션으로 테스트를 하였다. <br />
세션이란 우리가 DB에 접근을 할 떄, 클라이언트와 Connection을 맺게되는데  <br />
데이터 베이스 서버는 내부에 세션이란 것을 만들어 해당 커넥션을 통한 모든 <br />
요청은 이 세션을 통해서 실행하게 된다.</p>

<p><strong>한 마디로 SQL을 전달 받으면 현재 커넥션에 연결된 세션이 SQL을 실행한다.</strong></p>

<p>이 얘기를 토대로 위를 살펴보자면, 커밋이 이루어 지지 않은 상태이고<br />
왼쪽 세션을 조회 쿼리를 날렸을때는 정상적으로 2000원이 차감되었지만<br />
오른쪽 세션에서는 조회를해도 기존의 10000원이 표시되는 것을 볼 수 있다.</p>

<p>이 말은 즉, 왼쪽 세션이 commit();되지 않아<br />
오른쪽 세션과 다르게 보이는 모습이다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmSAT0SVkFQRFSs83afh0wemUypXU-0AxB9UgUTQ_nXJ2xMQ_SWhKlueIx5wVXyuV7Z-Lp2pAuv2Otk9W-yQBG81MMnGXQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이 상황에서 왼쪽 세션에 commit(); 명령을 보낸 후<br />
왼쪽 오른쪽 세션을 조회해보면<br />
위와 같이 동일해진 모습을 볼 수 있다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQSexoFyUMZWpDWivlRkoPtfcQ3EoLXbMdi9AvRnh8SV8ty8-one4e3UBrV9O3-6YBbptYiajuOe45fpQfUQ_9wPMjh=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>반대로 왼쪽 세션에서 rollback(); 명령을 보냈을 경우에는<br />
위와 같이 원래상태로 돌아간 모습을 볼 수 있다.</p>

<p>여기서 우리는 알아야할 것이 세션에 따라<br />
서로 상태가 다르게 보이는 문제가 발생한다.<br />
그럼 수많은 사람이 이용하는 클라이언트에서 여러 요청이와<br />
쿼리가 수도 없이 날라왔을 경우에 DB조작에 있어 어려움이 생긴다.</p>

<p>그래서 트랜잭션으로 작업단위를 하나로 묶어<br />
해당 세션이 실행되었을 때 예외발생하지 않고 전부 성공했을 경우<br />
다른 세션이 이용이 가능하도록 구현할 필요가 있다.</p>

<p><br /></p>

<h3 id="db-lock">DB Lock</h3>

<p>위에서 commit();과 rollback();에 대해서 알아보았다.<br />
내가 수행하는 비지니스 로직과 쿼리가 정상적으로 모두 수행되었을때<br />
commit();을 진행하고 도중에 예외가 생기면 rollback();을 해주면된다.</p>

<p>여기서 한가지 생각해보아야할 것이 우리가 commit();을 하기전에<br />
다른 세션에서는 기존의 상태가 보여지게되어진다.</p>

<p>이러한 상태에서 다른세션에서 해당부분을 수정하는 쿼리를 보냈을 경우에는<br />
어떻게 동작이 되어지는가? 하는 의문이생긴다.</p>

<p>데이터베이스는 이런 문제를 해결하기위해<br />
DB Lock이라는 개념을 제공해준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTXbqbmqrTNq4gTfLkWf9gIJXW9eWn5HcHqjCdyoOV_OqscxzZOTWG29-j0iGltlzppk2c_rsWgRkU_IpsJvYsXvwDtfw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>memberA라는 사람의 돈을 10000으로 셋팅해두고<br />
왼쪽 세션에는 500으로 변경(commit 하지않음), 오른쪽 세션에는 기존과 동일<br />
상태로 둔다음 오른쪽 세션에서 memberA의 돈을 1000으로 바꾸었을 때</p>

<p>어떠한 일이 발생하느냐? 라는게 우리의 초점이다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTIXyEljH6kJA5qPQ9z19u5CL3sddOYEaiCJ9TFDKrv-tNNWb90ILvae9qEluwWPvwyeMvOwCfjKKnetibuOWXBRxRm=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>결과는 위와 같이 오른쪽 세션에서는 수행할 수 있는 쿼리를 실행한다.<br />
오른쪽 세션을 보면 아래에 실행된 쿼리의 로그를 볼 수 있다.</p>

<p>SET LOCK_TIMEOUT 60000; -&gt; 락 타임아웃을 60초로 설정<br />
set autocommit false; -&gt; 수동커밋으로 변경<br />
이 두가지가 실행 되었고, 궁극적으로 1000원으로 변경하는<br />
update 쿼리문이 실행되지 않은 모습이다.</p>

<p>그 말은 즉, DB에서 Lock이라는 개념을 제공해<br />
변경을 강제로 막아주고 있는 모습이다.</p>

<p>왼쪽 트랜잭션이 실행되어질 때 락을 획득하여 <br />
commit();을 하기전까지 다른 세션의 접근을 막고있는 것이다.</p>

<p>하지만 첫번쨰 쿼리로 타임아웃을 설정했기 때문에<br />
해당 트랜잭션은 60초 후에 아래와 같은<br />
알람이 발생하면서 세션이 자동적으로 종료하게된다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Timeout trying to lock table {0}; SQL statement:
    update member set money=10000 - 2000 where member_id = 'memberA' [50200-200]
    HYT00/50200
</code></pre></div></div>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQpgfd4MHVjIet62g9TxKlmVw0jeVCINrpP4pRD2xp6UdS5EnMW2uhWA9zz8uNjxKyp2cSFOriSBRFKGXI8zqUib6As1A=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>반대로 60초가 지나기 전에 왼쪽 세션에서<br />
commit();하여 락을 반납하였을 경우에는<br />
오른쪽세션에서 락을 획득하여 update 쿼리를 진행한 모습을<br />
위위 사진과 같이 확인해 볼 수 있다.</p>

<p>한 마디로 정리해보자면</p>
<ol>
  <li>세션이 실행되면 락을 획득</li>
  <li>해당 락이 반납되기 전까진 다른 세션에서는 수정 불가능</li>
  <li>락을 획득한 세션이 commit(); rollback();을 수행해야 락을 반납한다.</li>
</ol>

<hr />
<p>이렇게 오늘은 트랜잭션과 DB락에 대해 공부했다. <br />
DB락을 알기전까지는 항상 궁금해해왔다.</p>

<p>동시에 하나의 DB 레코드에 변경할때는 누가 우선권을 가지는거지?라는<br />
물음이 항상있었다. 그 이유는 이전에 PLC 프로그래밍을 하였을 때도<br />
하나의 공정에 동시작업이 물려있으면 우선순위를 처리해줘야하는<br />
로직을 작성해주어야했기 때문이다.</p>

<p>오늘 그 질문에 대한 물음은 어느정도 해결 된 것 같고<br />
최종적으로 궁금한점은 그럼 이 트랜잭션을<br />
Java코드로 어떻게 적용하는게 알맞는 것인지?라는<br />
질문이 생기지만 이후에 학습할 과정에 포함되어있는 것 같으니<br />
공부하면서 다시 깨달아봐야할 것 같다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 짜장면, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[드디어 금요일이다 !!]]></summary></entry><entry><title type="html">TIL) Spring JPA 3 (다대다 / @ManyToOne,@OneToMany)</title><link href="http://localhost:4000/til/2022/11/03/til.html" rel="alternate" type="text/html" title="TIL) Spring JPA 3 (다대다 / @ManyToOne,@OneToMany)" /><published>2022-11-03T00:00:00+09:00</published><updated>2022-11-03T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/03/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/03/til.html"><![CDATA[<p>오랜만에 시간가는지 모르고 공부한 것 같다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTXh7B366xpO46r-jW9QXzgykyRRJY1uS1iFupj0wgGjVU6tOw0-_zdw_jjWyNyLnQdZ12IU54jq9ltbiYTPW-gWDxxmw=w1512-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>어제 다대다 관계에 대한<br />
서로의 객체 참조가 이해가지 않아 새벽 3시까지<br />
밤을 새워가며 공부를 했다.<br />
졸리기도 했지만 알고자하는 마음에 집중이 오랜만에 엄청 된 것 같다.</p>

<p>어제 공부했더 다대다(N:M) 관계에 대해 공부해보자</p>

<hr />

<h3 id="다대다-관계-nm">다대다 관계 (N:M)</h3>
<p>다대다 관계는 N:N관계라고 한다.<br />
예젠에 RDBMS에서 공부 했던 것 처럼 중간에 테이블을 한개<br />
더 만들어서 1 : N : 1 로 만들어주는 방법이다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQR036vsqkAgtZouiUTcGK0jsHDhCHVUlwfI1dt3W4yY7Z-B7XgMRN-YpiyiMZ6p2eYOlql4ec=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 간단한 예제로 손님과, 주문을 다대다 관계로 맵핑하고 싶을 경우<br />
중간에 Customer_Order라는 테이블에 각자의 외래키를 두어<br />
참조할 수 있게 하는 것이다.</p>

<p>위에 그림처럼 중간에 테이블 클래스를 하나 만들어<br />
두 테이블의 ID값을 참조하면 되는 방법이다.</p>

<p><br /></p>

<p>예를 들기 위해<br />
Coffee와 Order 클래스를 만들어서 진행 하려한다.<br />
고객이라는 클래스는 빠졌지만 간단하게 하기위해<br />
두가지만 만들고 진행해보자</p>

<h3 id="manytoone-단방향">@ManyToOne 단방향</h3>

<p>Coffee는 커피의 등록정보라고하자 (커피이름,가격 등)<br />
Order은 사용자가 주문한 정보라고하자 (주문시간, 고객이름 등)<br />
서로 다대다 관계를 맺어 중간테이블을 통해 객체 참조를 해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"COFFEE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">coffeeName</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDERS"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">orderId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdAt</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>

    <span class="nd">@Column</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">personName</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCoffee</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">orderCoffeeId</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"COFFEE_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Coffee</span> <span class="n">coffee</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Order</span> <span class="n">order</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Order - OrderCoffee - Coffee (1:N:1)으로<br />
이루어진 관계이다. 현재 OrderCoffee에서만<br />
@ManyToOne으로 다대일로 연관관계를 맺고 있다.</p>

<p>이렇게 설정을 할 경우 <br />
OrderCoffee 테이블애서 coffee,order의 참조가 가능하지만<br />
Order와 Coffee는 서로 참조를 하지 못한다.</p>

<p>위와 같은 경우에는 OrderCoffee 객체 타입으로<br />
Repository를 만들어 저장해주어야한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderCoffeeRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">OrderCoffee</span><span class="o">,</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCoffeeService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">OrderCoffeeRepository</span> <span class="n">orderCoffeeRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OrderCoffeeService</span><span class="o">(</span><span class="nc">OrderCoffeeRepository</span> <span class="n">orderCoffeeRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orderCoffeeRepository</span> <span class="o">=</span> <span class="n">orderCoffeeRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">OrderCoffee</span> <span class="nf">createOrderCoffee</span><span class="o">(</span><span class="nc">OrderCoffee</span> <span class="n">orderCoffee</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">orderCoffeeRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">orderCoffee</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>OrderCoffee 클래스 타입으로 만든 객체에<br />
coffee,order 객체를 setter로 주입시켜준 다음<br />
해당 객체를 매개변수로 가진  createOrderCoffee 메서드를 호출하면<br />
JpaRepository로 인해 DB에 값이 저장되게 되어진다.</p>

<p>이렇게되면 OrderCoffee 테이블에는 order,coffe의 ID값으로 외래키로<br />
지정되어 각각 객체를 참조하여 사용이 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmSJE-aVzmVTrpdk2WiyCL7gk_eHKfofUIocw4kesvHn-RHofW9VVbBlVPoSn16R7f76yyYRKwKKoPyBtNPZriEfNJwe=w1512-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<h3 id="manytoone-onetomany-양방향">@ManyToOne @OneToMany 양방향</h3>

<p><strong>하지만 !!</strong><br />
우리는 Order와 Coffee의 다대다 관계를 보고 있는데<br />
위와 같이 사용할 경우 Order에서 Coffee를 참조하지 못하게 되는 상황이다.</p>

<p>서로 참조가 가능하도록 코드를 수정해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDERS"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">orderId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdAt</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>

    <span class="nd">@Column</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">personName</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"order"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderCoffee</span><span class="o">&gt;</span> <span class="n">orderCoffees</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"COFFEE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">coffeeName</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"coffee"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderCoffee</span><span class="o">&gt;</span> <span class="n">orderCoffees</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Order과 Coffee를 @OneToMany를 이용해<br />
양방향으로 참조가 가능하도록 설정해 주었다.</p>

<p>이렇게 설정할 경우 Order가 OrderCoffee 참조가 가능하고<br />
그로인해 OrderCoffee에서 Coffee로 참조가 가능해진다.</p>

<p>예를 들어 우리가<br />
매장에 커피가 3개가 등록되어있다고해보자 (아메리카노,카페라떼,헤이즐넛라떼)</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQqkAYU_59TIa660ZzyHtDhni-i-ZA6mBu5nz1OJ6KA6ESnFmopbQw8yfMIr85KE2cK10_Q6k6hGGFMOnu54JzpzpE5OQ=w1512-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Coffee Repository를 이용해 DB에 저장한 모습이다.</p>

<p>나라는 사람이 1개의 주문을 했는데 등록된 커피중 아메리카노를 주문했다고 가정해보자<br />
그러면 Order Controller 핸들러메서드를 통해 POST 주문을 해야할 것이다.<br />
나라는 사람의 정보과 어떤 커피인지만 알면 된다.<br />
즉, 주문(Order)을 하면 OrderCoffee 테이블까지 맵핑을 시켜줘야한다.</p>

<p>위의 내용을 토대로<br />
주문 Controller,Service를 만들었다.<br />
차근차근 아래에서 확인해보자</p>

<p>우선 핸들러 메서드를 맵핑해줄 Dto를 만들자<br />
위에서 얘기했듯이 <strong>주문하는 사람이름</strong>과, <strong>커피 목록의 번호</strong>만 알면 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderPostDto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">personName</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderCoffeeDto</span><span class="o">&gt;</span> <span class="n">orderCoffees</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCoffeeDto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 Dto를 작성했고</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQTzfqAsa2VbELiYL8VSeeVlzwfyBQO5EJfFNLAmYtp3oWyq9Z09m9MMoRQPlPdPK1nXySnEstsVlb5h3y1PvMGQQ_q=w1512-h807" alt="image" class="align-left" style="max-width: 90%" /></p>

<p>Postman을 통해 API 요청을 위와 같이 보내면 된다.<br />
이렇게 보내주었을 경우 우리는 coffeeId 1번 즉, 아메리카노라는 것을<br />
알 수 있고, 주문한사람은 “이재혁”이 되는 것이다.</p>

<p>이어서 Controller을 작성해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/api/orders"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OrderController</span><span class="o">(</span><span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orderService</span> <span class="o">=</span> <span class="n">orderService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">postOrder</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">OrderPostDto</span> <span class="n">orderPostDto</span><span class="o">){</span>

        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderCoffee</span><span class="o">&gt;</span> <span class="n">orderCoffees</span> <span class="o">=</span> <span class="n">orderPostDto</span><span class="o">.</span><span class="na">getOrderCoffees</span><span class="o">()</span>
                <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">object</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="nc">OrderCoffee</span> <span class="n">orderCoffee</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OrderCoffee</span><span class="o">();</span>
                    <span class="nc">Coffee</span> <span class="n">coffee</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Coffee</span><span class="o">();</span>
                    <span class="n">coffee</span><span class="o">.</span><span class="na">setCoffeeId</span><span class="o">(</span><span class="n">object</span><span class="o">.</span><span class="na">getCoffeeId</span><span class="o">());</span>
                    <span class="n">orderCoffee</span><span class="o">.</span><span class="na">setOrder</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
                    <span class="n">orderCoffee</span><span class="o">.</span><span class="na">setCoffee</span><span class="o">(</span><span class="n">coffee</span><span class="o">);</span>
                    <span class="n">order</span><span class="o">.</span><span class="na">getOrderCoffees</span><span class="o">();</span>
                    <span class="k">return</span> <span class="n">orderCoffee</span><span class="o">;</span>
                <span class="o">})</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

        <span class="n">order</span><span class="o">.</span><span class="na">setPersonName</span><span class="o">(</span><span class="n">orderPostDto</span><span class="o">.</span><span class="na">getPersonName</span><span class="o">());</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setOrderCoffees</span><span class="o">(</span><span class="n">orderCoffees</span><span class="o">);</span>

        <span class="nc">Order</span> <span class="n">result</span> <span class="o">=</span> <span class="n">orderService</span><span class="o">.</span><span class="na">createOrder</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">CREATED</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Mapper를 이용하지 않고 Controller에다가 프로그램을 작성했다.<br />
연습용으로만 하는 것이기에 참고 부탁바란다.</p>

<p>내용을 보면</p>
<ol>
  <li>
    <p>Order,Coffee 객체로 새로 만들어 주고 있다.</p>
  </li>
  <li>
    <p>OrderCoffee 객체를 만들어 order,coffee 객체를 setter로 주입하고 있다.<br />
-&gt; 그중 Coffee객체는 Dto로 받은 coffeeId를 넣어서 만든다.</p>
  </li>
  <li>
    <p>OrderCoffee 객체를 List로 반환해준다.</p>
  </li>
  <li>
    <p>Order 객체의 필드변수에 값을 주입하고있다. <br />
-&gt; 반환한 객체를 Order 객체의 필드변수 orderCoffees에 주입해주고 있다.<br />
-&gt; Dto로 받은 값을 personName에 주입해주고 있다.</p>
  </li>
  <li>
    <p>최종 적으로 값이 주입된 Order 객체를 Service 로직으로 전달한다.</p>
  </li>
</ol>

<p>여기서 알 수 있는 점은<br />
우리가 Order 클래스에 양방향으로 지정한
@OneToMany List<OrderCoffee> orderCoffees  
객체에 OrderCoffee 클래스의 값들이 List형태로 존재하게 된다.</OrderCoffee></p>

<p>Order 클래스에서 별도의 findOrderCoffee 쿼리를 작성하지 않더라고<br />
OrderCoffee의 List화 되어있는 객체를 참조하여 Coffee를 조회할 수 있다.</p>

<p><br /></p>

<p>이제 Service와 Repository 코드를 작성해보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CoffeeRepository</span> <span class="n">coffeeRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CoffeeService</span><span class="o">(</span><span class="nc">CoffeeRepository</span> <span class="n">coffeeRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">coffeeRepository</span> <span class="o">=</span> <span class="n">coffeeRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Coffee</span> <span class="nf">createCoffee</span><span class="o">(</span><span class="nc">Coffee</span> <span class="n">coffee</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">coffeeRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">coffee</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>
<p>간단하게 JpaRepository를 상속받아 JDBC와 같이<br />
쿼리문을 작성할 수도있고 정해진 규약대로 쿼리를 날릴 수도 있다.<br />
그중 .save();를 이용해 Order 객체를 DB에 저장하게 해주었다.</p>

<p>이제 주문을 Postman으로 실행하게 될 경우</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRnmNA4pymt_R759dyUt72jbf_Bms7zIM2lE2plqvJz05MFJIva97SO1RguJ4L9t5tVnCO3iyNdwKkoftNs1xOhfqgpUQ=w1512-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 주문이 잘 DB에 저장된 모습을 볼 수 있다.</p>

<p><br /></p>

<p>하지만 ! 여기서 OrderCoffee의 테이블에는</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmSrJSyX1h6jXCz0y0gt23p43O_gRw39Bl5G2Iqgx1reIWlR5YTZflQ3Y5cqCmK0ffMEd5izw4EkHZfAgEFYr0PMe6LKYQ=w1512-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>값이 저장되지 않는 모습을 볼 수 있다.</p>

<p>왜냐하면 우리는 Order Entity에 JPA기술을 이용해<br />
ORDER TABLE에만 값을 .save(); 해주었기 때문이다.</p>

<p>여기서 @ManyToOne, @OneToMany의 속성중<br />
Cascade라는 것으로 간단하게 해결할 수 있다.</p>

<p>Order 클래스의 Cascade 속성을 추가해주면된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDERS"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">orderId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdAt</span> <span class="o">=</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>

    <span class="nd">@Column</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">personName</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"order"</span><span class="o">,</span><span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderCoffee</span><span class="o">&gt;</span> <span class="n">orderCoffees</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위와 같이 CascadeType.PERSIST 속성을 사용하면<br />
Order객체가 .save();되어질때 ORDER_COFFEE 테이블에도<br />
값이 같이 맵핑되게 되어진다.</p>

<p><strong>Cascade란?</strong><br />
cascade 옵션이란 @OneToMany 나 @ManyToOne에 옵션으로 줄 수 있는 값이다.<br />
Entity의 상태 변화를 전파시키는 옵션이다.   <br />
만약 Entity의 상태 변화가 있으면 연관되어 있는(ex. @OneToMany, @ManyToOne)<br />
Entity에도 상태 변화를 전이시켜준다.</p>

<ol>
  <li>
    <p>Persistent: 저장을 하고나서, JPA가 아는 상태(관리하는 상태)가 된다.<br />
그러나 .save()를 했다고 해서, 이 순간 바로 DB에 이 객체에 대한 데이터가 들어가는 것은 아니다. <br />
JPA가 persistent 상태로 관리하고 있다가, 후에 데이터를 저장한다.<br />
(1차 캐시, Dirty Checking(변경사항 감지), Write Behind(최대한 늦게, 필요한 시점에 DB에 적용) 등의 기능을 제공한다)</p>
  </li>
  <li>
    <p>Removed: JPA가 관리하는 상태이긴 하지만, 실제 commit이 일어날 때, 삭제가 일어난다.</p>
  </li>
</ol>

<p>Order 클래스의 코드를 수정 후<br />
다시 Postman을 통해 주문요청을 보낼 경우</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTvAacgrE_bydZh1uUd4Y6Y1N3G477EgDw3NkdPKUeGJ3cCF4jZbLGJvWQj63OQtnOEMac5K7JDTIxk9XAgWAwdl6uA=w1512-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>비로소 ORDER_COFFEE 테이블에 외래키로<br />
값들이 저장되어지는 모습을 볼 수 있다.<br />
이렇게 연관관계를 통해 DB에 맵핑과 서로 객체 참조가 가능하다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 다대다에 대해 정리해보았다.<br />
@ManyToMany는 실무에 잘사용하지 않는다 들어서<br />
아직 공부하지 못한 상태이긴하다..<br />
사실 위의 방법으로 연관관계 맵핑하는 것은 간단하다고 생각한데<br />
서로 객체를 참조한다는? 의미가 잘 와닿지않기는한다.</p>

<p>계속 사용해보면서 익숙해질 수 밖에 !!</p>

<p>오늘 공부는 여기까지</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김치찌개라면</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[오랜만에 시간가는지 모르고 공부한 것 같다.]]></summary></entry><entry><title type="html">TIL) Spring JPA 2 (다대일, 일대다 / @ManyToOne,@OneToMany)</title><link href="http://localhost:4000/til/2022/11/02/til.html" rel="alternate" type="text/html" title="TIL) Spring JPA 2 (다대일, 일대다 / @ManyToOne,@OneToMany)" /><published>2022-11-02T00:00:00+09:00</published><updated>2022-11-02T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/02/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/02/til.html"><![CDATA[<p>일어났는데 날씨가 화창하다 !<br />
공부하기 딱 좋은 날이다.<br />
바람도 선선하니 창문을 보니 기분도 좋아지고</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTTi3iIn8dTeSBPpmgo8WFDpboB_P96FekTAmQA2_3ffEhVNvvXCKe7KMWo9-LgViok2L1403k=w3024-h1614" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>여유롭게 커피마시면서 이렇게 공부한게 얼마마인가<br />
소소한 것에 행복을 느껴본다.</p>

<hr />

<p>어제는 JPA에 대해 알아보았다.<br />
영속성 컨텍스트와 Entity 맵핑에 대해 알아보았고<br />
오늘은 Entity의 연관관계를 맵핑하는 방법을 알아보자 !</p>

<h2 id="연관-관계-mapping">연관 관계 Mapping</h2>

<p>연관 관계 맵핑은 이전에 Spring data JDBC 학습을 했을 때<br />
사용해봤던 경험이 있다. 그리고 RDBMS 공부 할 떄 1:1, 1:N, N:N 등<br />
Entity간의 연관관계를 정해 데이터를 참조할 수 있었다.</p>

<p>테스트를 위한 간단한 정의를 해보았다.<br />
Member : memberId, email, name, phone, createdAt, modifiedAt<br />
Order : orderId, orderStatus, createdAt, modifiedAt<br />
해당 엔티티에 위와 같은 Column을 가지는 클래스는 존재한다고 가정하겠다.</p>

<p>Member - Order의 연관관계를 맵핑을 연습해볼 것이다.</p>

<p><br /></p>

<h3 id="다대일-관계-n1">다대일 관계 (N:1)</h3>
<p>위에서 가정한 테이블과 클래스가 이다고 가정하고<br />
다대일 관계를 정의해보겠다.</p>

<p>한명의 손님당 여러개의 주문을 할 수 있으니  Order(N) : Member(1) <br />
관계가 정의되어질 수 있다. 즉, Order Column에서 Member를 참조할 수 있게<br />
만들어주어야한다. 마치 SQL로 JOIN을 하듯이</p>

<p><strong>@ManyToOne</strong><br />
다대일관계를 정의해주는 어노테이션이다.<br />
이름부터 직관적이라 기억하기 쉬울 것 같다.</p>

<p>사용방법을 코드로 알아보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ManyToOne</span>
<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">addOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">orders</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>해당 클래스는 Order Entity 클래스에서 추가한 모습이다.</p>

<p>기존에 Order : orderId, orderStatus, createdAt, modifiedAt <br />
총 4개의 Column을 정의 했었는데 여기에 member Column을 추가한 것이다.</p>

<p>그리고 해당 컬럼에 @ManyToOne 어노테이션과<br />
Member 타입의 객체를 만들고, @JoinColumn으로 해당 Column을 참조할<br />
외래키 Column을 적어주면 우리는 member 객체를 통해<br />
각 Order객체의 member 객체를 조회할 수 있게 되는 것이다.</p>

<p>테스트를 위해 DB에 Member 2명과, Order 1건을 만들어 테스트해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaTest</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">EntityTransaction</span> <span class="n">tx</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">CommandLineRunner</span> <span class="nf">testJpaSingleMappingRunner</span><span class="o">(</span><span class="nc">EntityManagerFactory</span> <span class="n">entityManagerFactory</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">em</span> <span class="o">=</span> <span class="n">entityManagerFactory</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">args</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">test</span><span class="o">();</span>

        <span class="o">};</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(){</span>
        <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
        <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">,</span><span class="s">"이재혁"</span><span class="o">,</span><span class="s">"010-7894-1234"</span><span class="o">);</span>
        <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"tmdghwlq@naver.com"</span><span class="o">,</span><span class="s">"염승호"</span><span class="o">,</span><span class="s">"010-1234-5623"</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
        <span class="n">order</span><span class="o">.</span><span class="na">addMember</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
        <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>

        <span class="nc">Order</span> <span class="n">findOrder</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findOrder: "</span> <span class="o">+</span> <span class="n">findOrder</span><span class="o">.</span><span class="na">getMember</span><span class="o">().</span><span class="na">getMemberId</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">findOrder</span><span class="o">.</span><span class="na">getMember</span><span class="o">().</span><span class="na">getEmail</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 출력</span>
<span class="nl">findOrder:</span> <span class="mi">2</span><span class="o">,</span> <span class="n">tmdghwlq</span><span class="nd">@naver</span><span class="o">.</span><span class="na">com</span>
</code></pre></div></div>
<p>member 객체 2개(member1,member2)와<br />
Order 객체 1개를 만들었다. Order 객체에는 Setter를 이용하여<br />
member2 객체를 member 참조변수에 참조하도록 코드를 추가했다.</p>

<p>만든 객체들을 영속성 컨텍스트의 등록후<br />
commit();을 진행하여 DB에 등록했다.</p>

<p>객체를 한번 DB에서 조회해보자</p>

<p>Order Table 조회</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRKidG95kInTT4bELfZ7GDduH3EsU_XuozzuawHn0_ZWIHVc2FQJOfOu0v9IM-CUr0uStNbAu4=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Member Table 조회
<img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmR_NXQMR6J6A7xoKPr9nv4fuFdKlFBR7Ou740yNkH2VR81uYW-aTwIpXw1daN23U3UADsI7L7g=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Table 이름은 ORDERS와 USERS로 변경해서 작업했다.<br />
실제로 조회해본 결과  member 객체 2개에 대한 데이터가 <br />
잘 저장되어있는 모습과 order 또한 잘 맵핑되어있다.</p>

<p>여기서 @JoinColumn으로 외래키를 적었는데<br />
해당 외래키가 DB Table에 적용된 모습이 확인 가능하다</p>

<p>마지막으로 코드 마지막 구문에 출력으로<br />
해당 객체를 getter를 이용해 값을 조회해보았을때도<br />
정상적으로 member2의 객체 값을 가져오는 모습을 볼 수 있다.</p>

<p><br /></p>

<p><strong>@OneToMany</strong><br />
만약 N:1이 아닌 일대다(1:N)관계를 표현할때는 어떻게해야할까?<br />
일대다 단방향 맵핑은 왜래키를 포함하지 않기때문에
사실 많이 사용하는 방법이 아니라고 들었다.</p>

<p>위에 예제로 들면 Order가 아닌 Member가 Order를 참조할 수 있어야한다.<br />
현재 상태에서는 알수 있는 정보는<br />
-&gt; 주문에서 어떤 고객이 주문했는지 알 수 있다.</p>

<p>주문을 통한 확인이 아닌<br />
어떤 고객이 무슨 주문들을 했는지를 알고 싶을때<br />
일대다 매핑을 추가해주면 <strong>양방향 관계</strong>를 만들어 줄 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">addOrder</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">orders</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Member Entity 클래스에 추가된 코드다</p>

<p>OneToMany같은 경우에는 @JoinColumn을 사용하지 않았고<br />
속성중 mappedBy를 사용했다.<br />
안에 있는 member는 우리가 @ManyToOne으로 N:1로 연결 시켜놓은<br />
필드 변수명과 동일하게 설정하면 된다.</p>

<p>양방 연관 관계 맵핑을 끝냈으니<br />
(다대다와는 다른내용이다.)</p>

<p>위에서 보았던 예제에서 test 메서드 내용만 바꾸어 보고<br />
테스트를 진행해보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">,</span> <span class="s">"이재혁"</span><span class="o">,</span> <span class="s">"010-1234-5678"</span><span class="o">);</span>
    <span class="nc">Order</span> <span class="n">order1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
    <span class="nc">Order</span> <span class="n">order2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>

    <span class="n">member</span><span class="o">.</span><span class="na">addOrder</span><span class="o">(</span><span class="n">order1</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">addOrder</span><span class="o">(</span><span class="n">order2</span><span class="o">);</span>
    <span class="n">order1</span><span class="o">.</span><span class="na">addMember</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="n">order2</span><span class="o">.</span><span class="na">addMember</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order1</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order2</span><span class="o">);</span>

    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>

    <span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>

    <span class="n">findMember</span><span class="o">.</span><span class="na">getOrders</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">findOrder</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findOrder: "</span> <span class="o">+</span> <span class="n">findOrder</span><span class="o">.</span><span class="na">getOrderId</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">findOrder</span><span class="o">.</span><span class="na">getOrderStatus</span><span class="o">());</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="c1">//출력</span>
<span class="nl">findOrder:</span> <span class="mi">1</span><span class="o">,</span> <span class="no">ORDER_REQUEST</span>
<span class="nl">findOrder:</span> <span class="mi">2</span><span class="o">,</span> <span class="no">ORDER_REQUEST</span>
</code></pre></div></div>
<p>test 메서드의 내용만 변경되었고 확인해보면<br />
Member는 1개, Order는 2개를 생성하였고</p>

<p>Member 객체의 addOrder 메서드를 통해 Order객체를 2개를<br />
List에 add 시켜 정리해주었다.</p>

<p>3개의 객체를 영속성 컨텍스트에 올린 후 commit();하여<br />
DB에 최종적으로 저장하게되어진다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRKidG95kInTT4bELfZ7GDduH3EsU_XuozzuawHn0_ZWIHVc2FQJOfOu0v9IM-CUr0uStNbAu4=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmR_NXQMR6J6A7xoKPr9nv4fuFdKlFBR7Ou740yNkH2VR81uYW-aTwIpXw1daN23U3UADsI7L7g=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>야기서 양방향이라는 것을 확인 할 수 있는 점은</p>
<ol>
  <li>Order 클래스의 member 객체를 통해 주문의 고객을 알 수 있다.</li>
  <li>Member 클래스의 orders 객체를 통해서 고객이 무슨 주문들을 했는지 알 수 있다.<br />
이렇게 연관관계 맵핑을 통해 서로 데이터를 조회할 수 있는<br />
양방향 연관관계가 형성되었다는 것을 검증해 볼 수 있다.</li>
</ol>

<p>한 가지 더 얘기해보자면 Member 클래스의 DB USERS<br />
DB의 List&lt;/Order/&gt; orders 객체는 Column으로 표시되지 않는다는 것이다.</p>

<p><br /></p>

<hr />

<p>오늘은 다대일과 일대다에 대한
어노테이션 사용 방법을 공부했다.</p>

<p>다대다 관계에 대해서는 내일 이어서 정리해보려고 한다.</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김치찌개, 계란말이, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[일어났는데 날씨가 화창하다 ! 공부하기 딱 좋은 날이다. 바람도 선선하니 창문을 보니 기분도 좋아지고]]></summary></entry><entry><title type="html">TIL) Spring JPA 1 (영속성 컨택스트, Entity Mapping)</title><link href="http://localhost:4000/til/2022/11/01/til.html" rel="alternate" type="text/html" title="TIL) Spring JPA 1 (영속성 컨택스트, Entity Mapping)" /><published>2022-11-01T00:00:00+09:00</published><updated>2022-11-01T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/01/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/01/til.html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRPFpJbXFca8pZtK4Y_xhMzczsg_7cF9aFFcOtM7nJMxG4Ts-Fz1MwFPufqbEyhDJgrM-zMotc=w3024-h1614" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>날씨가 벌써 쌀쌀해졌다.<br />
아침에 일어나면 으슬으슬하다…<br />
이제 진짜 가을은 얼마 없고 바로 겨울이되는 느낌</p>

<p>어제는 처음으로 게임을 한번도안했다.<br />
나에게는 엄청난 성과다 그 시간에 공부를 했으니..</p>

<p>이 마음가짐으로 쭉 열심히 공부해보자 !</p>

<hr />

<h2 id="jpa">JPA</h2>

<p>Java Persistence API의 약자다. <br />
현재는 Jakarta Persistence 라고도 부른다고한다.</p>

<p>JPA는 Java 진영에서 사용하는<br />
ORM(Object-Relational Mapping) 기술의 표준 사양이다.<br />
즉, JPA는 Java의 인터페이스로 사양이 정의가 되어있어<br />
구현하는 구현체가 따로 있다.</p>

<h3 id="hibernate-orm">Hibernate ORM</h3>
<p>JPA의 구현체의 하나로 EclipseLink, DataNucleus 등이 있다.<br />
우리가 주로 배우게될 JPA 구현체는 Hibernate ORM이다.</p>

<p>JPA와 Hibernate ORM은<br />
웹 애플리케이션 3계층에서 데이터 엑세스 계층에 위치한다.</p>

<h3 id="persistence-context">Persistence Context</h3>
<p>직역을하자면, 영속성 컨텍스트라고 부른다.<br />
JPA에서 P에 해당하는 부분이고, 지속한다는 의미를 가진다.</p>

<p>위에서 얘기했듯이 ORM은 객체와 DB 테이블의 맵핑을 통해 <br />
Entity 클래스 객체 안에 포함된 정보를 테이블에 저장하는 기술이다.<br />
JPA에서는 테이블과 맵팽되는 Entity 객체 정보를  <br />
영속성 컨텍스트라는 곳에 보관해서 애플리케이션 내에서 오래 지속되도록 한다.</p>

<p>그리고 보관된 Entity 정보는 DB 테이블에<br />
데이터를 CRUD하는데 사용하게된다.</p>

<ol>
  <li>Entity를 영구 저장하는 환경</li>
  <li>애플리케이션과 DB 사이에서 객체를 보관하는 논리적 개념</li>
</ol>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmT9olJAYm5HH_eKR9vzv5l7odFjODUl6jMaG1OAq2mTDBsJbcJCW4UNxMFDXlxdJ1DT4iQ9738=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>영속성 컨텍스트을 그림을 표현한 모습이다.<br />
보는 것과 같이 <strong>1차 캐시</strong> ,<strong>쓰기 지연 SQL 저장소</strong>가 있다.</p>

<p>프로그램으로 문법과 1차캐시, 쓰기 지연 SQL 저장소가 어떻게<br />
운영되는지 알아보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@Entity</span> 
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Id</span> 
    <span class="nd">@GeneratedValue</span>  
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">memberId</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Member</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">EntityTransaction</span> <span class="n">tx</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">CommandLineRunner</span> <span class="nf">testJpaBasicRunner</span><span class="o">(</span><span class="nc">EntityManagerFactory</span> <span class="n">emFactory</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// (1)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">em</span> <span class="o">=</span> <span class="n">emFactory</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>  <span class="c1">// (2)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
        
        <span class="k">return</span> <span class="n">args</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">jpatest</span><span class="o">();</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">jpatest</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@gmail.com"</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
        <span class="nc">Member</span> <span class="n">resultMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre></div></div>
<p><strong>첫번째 코드 블럭</strong>은 Member라는 데이터를<br />
우리가 데이터베이스와 연동하기위해 만들어둔 클래스이다.<br />
@Entity로 엔티티클래스를 지정하고 @Id로 기본키를 지정했다.<br />
할당전략은 GenerateValue로 값이 자동적으로 증가하게된다</p>

<p><br /></p>

<p><strong>두번째 코드 블럭</strong>부터 중요하다.</p>

<p><span style="color:#F04965"><strong>EntityManager 클래스</strong></span><br />
-&gt; JPA의 영속성 컨텍스트를 관리함.<br />
-&gt; EntityManagerFactory 클래스 객체를 DI 받을 수 있다.<br />
-&gt; 주입 받은 객체를 통해서 JPA의 API 메서드를 사용할 수 있다.</p>

<p>.persist();<br />
-&gt; 해당객체를 넣으면 영속석 컨텍스트에서 객체의 정보들이 저장된다.<br />
-&gt; 객체는 1차 캐시에 저장되고, 이 객체는 쓰기 지연 SQL 저장소에 INSERT 쿼리 형태로 등록된다</p>

<p>.find();<br />
-&gt; 컨텍스트 안의 조회할 엔티티를 불러오는 방법 (클래스타입, 식별자값)</p>

<p>.getTransaction();<br />
-&gt; EntityTransaction 클래스 타입을 반환함<br />
-&gt; JPA에서는 Transcation 객체를 기준으로 DB의 Table에 데이터를 저장한다.<br />
-&gt; EntityManger 객체에서 가져올 수 있다.</p>

<p>.getTransaction().begin();<br />
-&gt; transaction 시작하기 위한 메서드</p>

<p>.getTransaction().commit();<br />
-&gt; 메서드 호출시점에 영속성 컨텍스트에 저장되어있는 객체를 DB의 테이블에 저장함<br />
-&gt; 쓰기 지연 SQL 저장소에 INSERT 쿼리가 실행되어 저장소에서 사라진다.<br />
-&gt; 내부적으로 flush(); 메서드가 호출되어 영속성 컨택스트의 변경 내용을 반영한다.</p>

<p><span style="color:#F04965"><strong>EntityManagerFactory 클래스</strong></span><br />
.createEntityManager(); <br />
-&gt; EntityManager 타입의 변수에 해당 메서드로 만든 객체를 넣어줘야함<br />
-&gt; 만들어진 영속성 컨텍스트로 EntityManager 클래스의 기능 사용가능</p>

<p>이상 간단한 구문들만 먼저 정리해 보았고 두번째 코드블럭을 분석해보면</p>

<p>Member 클래스 타입의 객체인 member 라는 새로운 객체를 <br />
EntityManager 클래스 타입의  em이라는 참조변수의 메서드인 <br />
em.persist(member);를 실행 시켜 1차 캐시에 객체를 저장하고<br />
쓰기 지연 SQL 저장소에 INSET 쿼리 형태로 등록한다.</p>

<p>영속성 컨택스트 안에 객체가 등록되었기 때문에<br />
DB애 데이터가 저장되지 않았어도<br />
.find();라는 메서드를 이용해 객채를 찾을 수 있는 것이다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmTcXQePwbhv3jAMqEYgQFX5pommI1oXMrrIrqAFqKw6rnCzs6waOCx3Egza2_4IGpXKU2h_lEI=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><strong>결과: 영속성 컨텍스트 저장 O, 데이터베이스 저장 X</strong></p>

<p><br /></p>

<p>이제 영속성 컨택스트에 등록하는 법을 알았다.<br />
그러면 DB에는 어떻게 저장할까?</p>

<p>우선 우리는 Transaction 객체를 기준으로 데이터베이스의<br />
테이블에 데이터를 저장해야되서 .begin(); .commit();로<br />
시작과 데이터를 써줄 수 있게되어진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">jpatest</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@gmail.com"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
    
    <span class="nc">Member</span> <span class="n">resultMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위에서 얘기했듯이 .commit();라는 메서드를 호출해주면<br />
영속성 컨텍스트의 변경 사항을 테이블에 반영해주는 메서드 flush();가<br />
내부적으로 호출되어 DataBase에 데이터가 저장되고<br />
기존에 있던 <strong>쓰기 지연 SQL 저장소</strong>에는 데이터가 지워지게된다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQ-OUrKd41tUZrh_rjR1V75byfLrXEb-MLOYiZe0UAHxzD3mrTib4P50B0QHyf_O2Aq19x7qVI=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><strong>결과: 쓰기 지연 SQL 저장소 삭제, 데이터베이스 저장 O</strong></p>

<p><br /></p>

<p>만약 여러개 의 데이터를 .persist() 하여 .commit();을 하게된다면</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">jpatest</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@gmail.com"</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"tmdghwlq@naver.com"</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">member3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"bomjin128@gmail.com"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member3</span><span class="o">);</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
    
    <span class="nc">Member</span> <span class="n">resultMember1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">resultMember2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">resultMember3</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">3L</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resultMember1</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resultMember2</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resultMember3</span><span class="o">.</span><span class="na">getEmail</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>아래와 같이 쓰기 지연 SQL 저장소의 데이터는 모두 지워진다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRTieUDGVyS8Av0JyHvMlowRR3_abVmLSiqndX0tShgpS4TYJ-XcPNM3zXTI66cPgI0LTT_sVs=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 시스템 출력으로 찍어보 았을때<br />
<img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmSne7XgebEuiijpzBtS8cxs5NfzsFdUg8W-82Pq220xUsF9neETnQaJr269uLYp266sOO_h5FM=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>여전히 영속성 컨택스트 안에 객체의 값을 가져올 수 있었고</p>

<p>아래와 같이 데이터 베이스에서도 값이 저장된 모습을 확인할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmRPzF0h7qZkMllMrAs-VxRG_WymmcOoFcXCAZDWlU7vmwOqv-X0-54n4TxWISMZq2v3rzSCd7k=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<p>추가하는법과 DB에 데이터를 저장하는 법까지 알았으니<br />
영속성 컨텍스트안에 객체를 삭제한는 방법도 있다.</p>

<p>.remove(); 메서드를 이용하면 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">jpatest</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@gmail.com"</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"tmdghwlq@naver.com"</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">member3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"bomjin128@gmail.com"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member3</span><span class="o">);</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
    
    <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
    <span class="nc">Member</span> <span class="n">resultMember1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">resultMember2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">2L</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">resultMember3</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">3L</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">resultMember1</span><span class="o">);</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이렇게 트랜젝션을 두개로 나눠 진행해보자.<br />
첫번째는 우리가 위에서 배웠던 persist(); 메서드로 영속성 컨택스트의 등록 <br />
commit(); 메서드로 데이터 베이스에 저장 후 쓰기 지연 SQL 저장소에서 삭제.</p>

<p>여기서 두번째 트랜잭션은<br />
영속성 컨텍스트의 Member타입의 클래스 객체를 가져오고<br />
그 중에서 Id가 1에 해당하는 객체를 .remove((); 메서드에 담아주었다.</p>

<p>여기서 메서드를 호출하는 순간 1차 캐시에 있는 엔티티를 제거 요청을하여<br />
쓰기 지연 SQL 저장소에 DLETE 쿼리 형태로 저장하게된다.<br />
.commit();을 실행하면, 1차 캐시에 있는 엔티티를 제거하고, 쓰기 지연 SQL 저장소에<br />
등록된 DELETE 쿼리가 실행 된다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmR_ZOK3YntMqeZLhBczY47sWmQmsPC95mmw8X5FlmZAqjTiH1gWRQrqfk0PANOFuS2nNDWleU8=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같은 그림으로 실행이 이루어진다 생각하면 될 것 같고</p>

<p>그리고 DELETE 쿼리를 실행했기 때문에<br />
데이터 베이스의 해당 엔티티의<br />
레코드 값도 삭제되게 되어진다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQnbbsdDBC5VjJ19Bec6S5Ctv26CfpeA-yqaIO2xPygMKxlmn-uyU8JzEE6SKwwhUIRnLB1nrA=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<h3 id="entity-mapping">Entity Mapping</h3>

<p><strong>@Id</strong></p>

<p>우선 @Id 우리가 기본키(Primary Key)로 사용하는<br />
데이터의 여러가지 전략을 알아보자</p>

<ol>
  <li>IDENTITY : 기본키 생성을 DB한테 위임함, 대표적으로 AUTO_INCREMENT</li>
  <li>SEQUENCE : DB에서 제공하는 시퀀스를 사용해서 기본키를 생성</li>
  <li>TABLE : 별도의 키 생성 테이블을 사용하는 전략임</li>
</ol>

<p>애플리케이션 코드 상에서 기본키를 직접 할당해주는 방식을 제외 하고는<br />
위와 같은 3가지 전략을 가지고 기본키를 할당한다.</p>

<p>@GenerateValue 애노테이션이 할당하는 법을 도와주며<br />
아래와 같이 사용할 수 있다.</p>

<p>1). @GeneratedValue(strategy = GenerationType.IDENTITY)<br />
-&gt; IDENTITY 전략으로 객체를 생성하면서 별도의 기본키 값을 전달하지 않았다.<br />
-&gt; 예를들어 @Id만 있을 경우에는 기본적으로 해달 컬럼에 데이터를 우리가 직접 넣어줘야한다.<br />
하지만 이놈과 같이 사용한다면 자동으로 값이 증가됨</p>

<p>2). @GeneratedValue(strategy = GenerationType.SEQUENCE)<br />
-&gt; SEQUENCE 전략으로 객체를 생성하면서 별도의 기본키 값을 전달하지 않았다.<br />
-&gt; DB에서 제공하는 시퀀스를 이용한 키가 생성됨</p>

<p>3). @GeneratedValue(strategy = GenerationType.AUTO)<br />
-&gt; 데이터베이스의 Dialect에 따라서 적절한 전략을 자동으로 선택한다.</p>

<p><br /></p>

<p><strong>@Column</strong></p>

<p>그리고 <strong>@Column</strong>에 대해서 알아 보았다.<br />
-&gt; 엔티티 클래스의 컬럼(열)을 맵핑해주는 애노테이션이다.
-&gt; 해당 애노테이션이 없어도, 필드의 변수가 있다면 자동적으로 컬럼과 맵핑되는 필드라 간주한다.
-&gt; 속성의 기본 값은 nullable = true , updatable = true, unique = false;
-&gt; length 속성으로 문자 길이 지정가능 / default 255</p>

<p>특징은 위와 같고 default 설정을 다시 보면<br />
nullable : false = null 값 불허용 / true = null 값 허용함
updatable : false = 컬럼의 값 변경 불허용 / true = 컬럼의 값 변경 허용
unique : false = 유니크 미사용 / true = 유니크 사용, 중복 데이터 컬럼에 들어올 경우 알람발생<br />
이렇게 정리해 볼 수 있을 것 같다.</p>

<p>nullable은 간단하니 패스하고 updatable과 unique를 비교해보자</p>

<p><strong>1). 업데이트가 불가능한 설정</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">updatable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">unique</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">jpatest</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">));</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">));</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"dhfif718@naver.com"</span><span class="o">));</span>
        <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>

        <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">1L</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setEmail</span><span class="o">(</span><span class="s">"ddd@gmail.com"</span><span class="o">);</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
        <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 처럼 1번째 엔티티의 객체를 가져와<br />
setter로 수정 후 다시 등록하여도, DB에는 수정된 값이 반영되지 않는다.<br />
하지만 영속석 컨텍스트의 객체를 조회해보면<br />
변경된 객체는 persist되어있기 때문에 ddd@gmail.com 값을 가진<br />
Member 객체가 존재한다는 것을 확인해 볼 수 있다…</p>

<p>그러면 이렇게 서로 상이할경우엔..? 어떻게 해결해야하지?? 라는 의문이든다..<br />
이 부분은 오늘 아고라 스테이츠에 질문을 올려놓았다.</p>

<p><strong><em>다음날 답변 : updatable = false이라는 뜻이 읽기전용 컬럼이기 때문에<br />
Setter를 사용할 일이 없다고 한다 ! 예제를 위한 프로그램이었으니 참고 !</em></strong></p>

<p><strong>2). 유니크값 허용 설정</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Column</span><span class="o">(</span><span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">updatable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">unique</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
</code></pre></div></div>
<p>만약 동일한 값을 해당 email 컬럼에 저장을 하게된다면 <br />
아래와 같은 알람이 컴파일 중 발생할 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unique index or primary key violation: "PUBLIC.UK_6DOTKOTT2KJSP8VW4D0M25FB7_INDEX_4 ON PUBLIC.USERS(EMAIL NULLS FIRST) VALUES ( /* 1 */ 'dhfif718@naver.com' )"; SQL statement:
</code></pre></div></div>

<p><br /><br /><br /></p>

<p>이 외에 Mapping을 하기 위한 어노테이션들 몇 가지들을<br />
더 공부해보았다.</p>

<p><strong>@Temporal</strong><br />
-&gt; 날짜를 맵핑하기위한 필드에 달아주는 애노테이션<br />
-&gt; LocalDataTime 타입일 경우 생략이 가능하다.</p>

<p><strong>@Transient</strong><br />
-&gt; 이 애노테이션을 필드에 추가하면 테이블 컬럼과 매핑하지 않겠다는 의미로 JPA가 인식한다.<br />
-&gt; 따라서 데이터베이스에 저장도 하지않고, 조회할 때 역시 매핑되지 않는다.<br />
-&gt; 주로 임시 데이터를 메모리에서 사용하기위한 용도<br />
-&gt; 즉, DB에는 저장하고 싶지 않은데, 더미로 데이터 사용할 경우 이용하기 가능!</p>

<p><strong>@Enumerated</strong><br />
-&gt; enum 타입과 매핑할 때 사용하는 애너테이션이다.<br />
-&gt; 두가지 타입을 가질 수 있다.  <br />
1). EnumType.ORDINAL : enum의 순서를 나타내는 숫자를 테이블에 저장<br />
2). EnumType.STRING : enum의 이름을 테이블에 저장<br />
-&gt; ex) @Enumerated(EnumType.STRING)</p>

<hr />

<p>오늘의 JPA공부는 여기까지!<br />
확살하 JDBC를 조금 공부하고 와서 JPA를 보니까<br />
훨씬 이해가 빠르고 잘되는 것 같다.</p>

<p>아직 연관 관계 맵핑에 대해서는 배우지 않았지만<br />
기본적인 테이블과 연결되어지는 과정이라든가<br />
기본적인 개념들을 배우고 인텔리제이로 테스트해보는 과정들이<br />
너무 재밌어서 시간이 훅훅 지나간 것 같다.</p>

<p>오늘 공부는 여기서 끝!!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 짜장면 곱뺴기</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /></entry><entry><title type="html">TIL) Spring Data JDBC Pagination</title><link href="http://localhost:4000/til/2022/10/31/til.html" rel="alternate" type="text/html" title="TIL) Spring Data JDBC Pagination" /><published>2022-10-31T00:00:00+09:00</published><updated>2022-10-31T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/10/31/til</id><content type="html" xml:base="http://localhost:4000/til/2022/10/31/til.html"><![CDATA[<p>한 주가 지나고 새로운 주가 찾아왔다.<br />
내가 공부하고 있는 와중에도<br />
세상은 돌아가고 있다.</p>

<p>누군가의 시간은 느리게 가고 누군가의 시간은 빠르게 갈 것 같다.<br />
시간을 어떻게 써야 잘 썻지? 라는 물음이 요즘 자꾸 생긴다.</p>

<p>공부를 효율적으로 하기에는 의지가 가장 중요한 것 같다.<br />
주말동안 여러가지 자극을 받으면서, 다시한번 공부에 대한 의지와<br />
내가 목표로가진 내용을 상기하면서 이번주부터 다시 임해보려한다.</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQXIC8mWHwkvUJVmPkxrKAdOzOu1PCHFrLIQEOAjT3mrp4fwj0NsNUw2Pfv6Ju2EYysMjkR0rU=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<hr />

<p>오늘도 Spring data JDBC를 연습해보는 날이다.<br />
마지막으로 연습해보는 날이고<br />
내일부터는 본격적으로 JPA에 대해 공부해보는 시간이다.</p>

<p>사실 JDBC사용 방법보다는 객체간 이동<br />
Mapper, DTO, Service 등 로직 구현을 주로 연습한 것 같다.</p>

<h2 id="pagination">Pagination</h2>
<p>오늘 구현해볼 내용은 Pagination을 구현할 것이다.<br />
한글로 페이지네이션이라 부른다.<br />
페이시네이션이란?</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQ8Zaxag8YR_XCL1ZHlXct3gU2Ai1QnIiP0-1fEbT8ol69R3RStfVwuhswGxDBKzTPMB6nfwAM=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>간단한 예제로 구글을 통해 검색할 경우<br />
우리는 해당 검색어에 대한 내용이 쭉나오고, 다음 내용은<br />
페이지로 다음을 눌러 넘어가서 확인한다.</p>

<p>이에 해당하는 프로그램을 구현할 것이다.</p>

<h2 id="구현">구현</h2>

<p>문제1. RequsetParam를 통해 page, size값을 받는다<br />
-&gt; page: 몇번 페이지, size: 표시 수량</p>

<p>문제2. 아래와 같이 데이터가 담긴 Json 객체를 반환<br />
-&gt; 조회한 데이터는 memberId 내림차순으로 정렬할 것</p>

<p>참고</p>
<ol>
  <li>DB에는 20개의 데이터가 저장되어있다.</li>
</ol>

<p>Page = 1, Size = 10 일 때의 예제</p>

<pre><code class="language-JSON">{
    "data": [
        {
            "memberId": 20,
            "email": "hgd20@gmail.com",
            "name": "홍길동20",
            "phone": "010-2020-2020"
        },
        {
            "memberId": 19,
            "email": "hgd19@gmail.com",
            "name": "홍길동19",
            "phone": "010-1919-1919"
        },
        {
            "memberId": 18,
            "email": "hgd18@gmail.com",
            "name": "홍길동18",
            "phone": "010-1818-1818"
        },
        {
            "memberId": 17,
            "email": "hgd17@gmail.com",
            "name": "홍길동17",
            "phone": "010-1717-1717"
        },
        {
            "memberId": 16,
            "email": "hgd16@gmail.com",
            "name": "홍길동16",
            "phone": "010-1616-1616"
        },
        {
            "memberId": 15,
            "email": "hgd15@gmail.com",
            "name": "홍길동15",
            "phone": "010-1515-1515"
        },
        {
            "memberId": 14,
            "email": "hgd14@gmail.com",
            "name": "홍길동14",
            "phone": "010-1414-1414"
        },
        {
            "memberId": 13,
            "email": "hgd13@gmail.com",
            "name": "홍길동13",
            "phone": "010-1313-1313"
        },
        {
            "memberId": 12,
            "email": "hgd12@gmail.com",
            "name": "홍길동12",
            "phone": "010-1212-1212"
        },
        {
            "memberId": 11,
            "email": "hgd11@gmail.com",
            "name": "홍길동11",
            "phone": "010-1111-1111"
        }
    ],
    "pageInfo": {
        "page": 1,
        "size": 10,
        "totalElements": 20,
        "totalPages": 2
    }
}
</code></pre>

<p>DB에 20개의 데이터가 MEMBER Table에 저장이 되어있고<br />
우리가 해야하는 것은 page, size의 값을 받아<br />
해당 객체를 조립하여 JSON으로 반환해주어야한다.</p>

<p>그렇게 생각하여 나는 크게 6가지 과정으로 프로그램을 진행했다.</p>

<ol>
  <li>클라이언트 측 에서 데이터 요청 받은데이터를 맵핑한 객체를 만듬</li>
  <li>Service에서 Member 전체 조회한 후 필요한 데이터만 정리해 객체로 만듬</li>
  <li>1,2번에서 만든 객체로 ResponseDto 맵핑함.</li>
  <li>3번에서 맵핑하여 만든 전체 List 데이터를 JSON으로 응답</li>
</ol>

<p>해당 과정을 통해서 프로그램을 작성했고,  실제로 Pagination을 하기위해<br />
Spring에서 도움음 주는 클래스 Page, Pageable, PageRequest를 이용해<br />
자동으로 Pagination을 해줄 수 도 있다.</p>

<p>우선 나는 위방법을 안쓰고 직접 코드로 정리해서 보내는 방법을 택했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GetMapping</span>
<span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">getMembers</span><span class="o">(</span><span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"page"</span><span class="o">)</span> <span class="nd">@Positive</span> <span class="kt">int</span> <span class="n">page</span><span class="o">,</span>
                                 <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"size"</span><span class="o">)</span> <span class="nd">@Positive</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">//PageInfo 데이터 맵핑</span>
    <span class="nc">MemberPageInfoDto</span> <span class="n">memberPageInfoDto</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">dataToMemberPageInfoDto</span><span class="o">(</span><span class="n">page</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>

    <span class="c1">//Member 전체조회 서비스 로직 실행</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findMembers</span><span class="o">(</span><span class="n">memberPageInfoDto</span><span class="o">);</span>

    <span class="c1">//객체들 ResponsePageDto Mapping</span>
    <span class="nc">MemberResponsePageDto</span> <span class="n">response</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">membersToMemberResponsePageDto</span><span class="o">(</span><span class="n">members</span><span class="o">,</span><span class="n">memberPageInfoDto</span><span class="o">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nc">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">response</span><span class="o">,</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>우선 Controller의 getMembers를 작성.<br />
0이아닌 양의정수만 포함한 데이터로 page,size를 받을 수 있다.</p>

<p>여기서 첫번째 줄 PageInfo에 데이터 맵핑 하는 클래스를 만들고<br />
Mapper를 구현하여 데이터를 전달했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">default</span> <span class="nc">MemberPageInfoDto</span> <span class="nf">dataToMemberPageInfoDto</span><span class="o">(</span><span class="kt">int</span> <span class="n">page</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberPageInfoDto</span><span class="o">(</span><span class="n">page</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
<span class="o">};</span>
<span class="k">default</span> <span class="nc">MemberResponsePageDto</span> <span class="nf">membersToMemberResponsePageDto</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">,</span> <span class="nc">MemberPageInfoDto</span> <span class="n">memberPageInfoDto</span><span class="o">){</span>
    <span class="nc">MemberResponsePageDto</span> <span class="n">memberResponsePageDtos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MemberResponsePageDto</span><span class="o">(</span><span class="n">members</span><span class="o">,</span><span class="n">memberPageInfoDto</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">memberResponsePageDtos</span><span class="o">;</span>
<span class="o">};</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberPageInfoDto</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">page</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">totalElements</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">totalPages</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>page, size를 이용해 나머지 값이 0인 객체를 만들었다.<br />
그리고 아래있는 메서드는 응답할때 조립을 해주는 메서드이다.<br />
인자로는 Member를 List화한 데이터와 방금 위에서 전달한<br />
MemberPageInfoDto객체를 받는다.<br />
이 두개의 데이터를 받아 최종적으로</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberResponsePageDto</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">data</span><span class="o">;</span>
    <span class="nc">MemberPageInfoDto</span> <span class="n">pageInfo</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이 응답클래스에 데이터를 담아서 반환하게 되어진다.</p>

<p>이렇게 Mapper와 응답데이터 클래스를 만들었고<br />
이제 데이터베이스에서 Member 클래스의 데이터를 조회해<br />
우리가 원하는 page, size의 맞춰서 Member List를 반환해줘야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findMembers</span><span class="o">(</span><span class="nc">MemberPageInfoDto</span> <span class="n">memberPageInfoDto</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// member 전체 내림차순 정렬 조회</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span>  <span class="n">memberRepository</span><span class="o">.</span><span class="na">findAllByOrderByMemberIdDesc</span><span class="o">();</span>

    <span class="c1">// Pagenation Service 로직, 정리된 Member List만 반환</span>
    <span class="k">return</span> <span class="nf">executionPagenation</span><span class="o">(</span><span class="n">members</span><span class="o">,</span> <span class="n">memberPageInfoDto</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">executionPagenation</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">,</span> <span class="nc">MemberPageInfoDto</span> <span class="n">pageInfo</span><span class="o">){</span>
    <span class="c1">// page, size 가져오기</span>
    <span class="kt">int</span> <span class="n">page</span> <span class="o">=</span> <span class="n">pageInfo</span><span class="o">.</span><span class="na">getPage</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">pageInfo</span><span class="o">.</span><span class="na">getSize</span><span class="o">();</span>

    <span class="c1">// members 수량 파악 후 TotalElements, TotalPages Data 추가</span>
    <span class="n">pageInfo</span><span class="o">.</span><span class="na">setTotalElements</span><span class="o">(</span><span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
    <span class="k">if</span><span class="o">(</span><span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">()&lt;=</span><span class="n">size</span><span class="o">){</span>
        <span class="n">pageInfo</span><span class="o">.</span><span class="na">setTotalPages</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">memberSize</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">()/</span><span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">memberLeft</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">()%</span><span class="n">size</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">memberLeft</span><span class="o">!=</span><span class="mi">0</span><span class="o">)</span> <span class="n">memberSize</span><span class="o">++;</span>
        <span class="n">pageInfo</span><span class="o">.</span><span class="na">setTotalPages</span><span class="o">(</span><span class="n">memberSize</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// page, size만큼의 Data만 담은 List 반환</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">membersMakeUp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">remainPage</span> <span class="o">=</span> <span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="o">(</span><span class="n">page</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="n">size</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">to</span> <span class="o">=</span> <span class="o">(</span><span class="n">remainPage</span><span class="o">!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pageInfo</span><span class="o">.</span><span class="na">getTotalPages</span><span class="o">()==</span><span class="n">page</span><span class="o">)</span> <span class="o">?</span> <span class="n">from</span><span class="o">+</span><span class="n">remainPage</span> <span class="o">:</span> <span class="n">from</span><span class="o">+</span><span class="n">size</span><span class="o">;</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">from</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">to</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="n">membersMakeUp</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">members</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="k">return</span> <span class="n">membersMakeUp</span><span class="o">;</span>
<span class="o">}</span>
        
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">CrudRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findAllByOrderByMemberIdDesc</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이렇게 Service 로직을 구현했다.<br />
처음에 맵핑했던 PageInfo 객체에 나머지 값을을<br />
setter를 통해서 데이터를 입력해준 다음에</p>

<p>Member 테이블의 데이터를 내림차순으로 조회하여<br />
받은 데이터를 page와 size값으로 원하는 페이지에<br />
수량별로 표시가 될 수 있게끔 프로그래밍하여<br />
Member List를 최종적으로 반환하게 해주었다.</p>

<p>이렇게 되면 최종적으로 페이지에 맞는 Member List 객체와<br />
PageInfo 객체를 가지고 있기 때문에 최종적으로<br />
MemberResponsePageDto 클래스 타입으로 맵핑해서 응답데이터를<br />
ResponseEntity를 통해 반환하도록 하면 !!</p>

<p><img src="https://lh3.googleusercontent.com/drive-viewer/AJc5JmQULqdlINeqzZ_bz-zE7r0uUK9OxGxwpQRGjmUuF-O8-xqZcIe1swGHu0Z2JgvVykvTYEut4aI=w1512-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>page=1, size=2 로 하였을 경우의 반환된 Json의 모습.<br />
totalElements = 20개의 데이터<br />
totalPages = 10개의 페이지.</p>

<p>정상적으로 작동하는 모습이 확인 가능하다.<br />
<a href="https://velog.io/@bagt/0704-Spring-Pagination-API-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98">Spring Pagination API</a>를 이용해 작성하는 방법을 참고해보자<br />
해당 방법은 선배기수에서 Spring API를 이용해 간단하게 구현한 모습이다.</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️ <br />
<strong>오늘의 점심</strong>: 라면</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[한 주가 지나고 새로운 주가 찾아왔다. 내가 공부하고 있는 와중에도 세상은 돌아가고 있다.]]></summary></entry></feed>