<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-16T18:00:29+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LeeJellan</title><subtitle>안녕하세요!🙂 IT,여행,기타 등 기록을 남기기위한 블로그 입니다 !</subtitle><author><name>LEE JAEHYEOK</name></author><entry><title type="html">[Programmers] 조건에 부합하는 중고거래 댓글 조회하기 (MySQL)</title><link href="http://localhost:4000/sql/2023/03/16/sql-trade.html" rel="alternate" type="text/html" title="[Programmers] 조건에 부합하는 중고거래 댓글 조회하기 (MySQL)" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/sql/2023/03/16/sql-trade</id><content type="html" xml:base="http://localhost:4000/sql/2023/03/16/sql-trade.html"><![CDATA[<h2 id="-문제--조건에-부합하는-중고거래-댓글-조회하기">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/164673">조건에 부합하는 중고거래 댓글 조회하기</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>다음은 중고거래 게시판 정보를 담은 <code>USED_GOODS_BOARD</code> 테이블과 중고거래 게시판 첨부파일 정보를 담은 <code>USED_GOODS_REPLY</code> 테이블입니다. <code>USED_GOODS_BOARD</code> 테이블은 다음과 같으며 <code>BOARD_ID</code>, <code>WRITER_ID</code>, <code>TITLE</code>, <code>CONTENTS</code>, <code>PRICE</code>, <code>CREATED_DATE</code>, <code>STATUS</code>, <code>VIEWS</code>은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다.</p>
<table class="table">
        <thead><tr>
<th>Column name</th>
<th>Type</th>
<th>Nullable</th>
</tr>
</thead>
        <tbody><tr>
<td>BOARD_ID</td>
<td>VARCHAR(5)</td>
<td>FALSE</td>
</tr>
<tr>
<td>WRITER_ID</td>
<td>VARCHAR(50)</td>
<td>FALSE</td>
</tr>
<tr>
<td>TITLE</td>
<td>VARCHAR(100)</td>
<td>FALSE</td>
</tr>
<tr>
<td>CONTENTS</td>
<td>VARCHAR(1000)</td>
<td>FALSE</td>
</tr>
<tr>
<td>PRICE</td>
<td>NUMBER</td>
<td>FALSE</td>
</tr>
<tr>
<td>CREATED_DATE</td>
<td>DATE</td>
<td>FALSE</td>
</tr>
<tr>
<td>STATUS</td>
<td>VARCHAR(10)</td>
<td>FALSE</td>
</tr>
<tr>
<td>VIEWS</td>
<td>NUMBER</td>
<td>FALSE</td>
</tr>
</tbody>
      </table>
<p><code>USED_GOODS_REPLY</code> 테이블은 다음과 같으며 <code>REPLY_ID</code>, <code>BOARD_ID</code>, <code>WRITER_ID</code>, <code>CONTENTS</code>, <code>CREATED_DATE</code>는 각각 댓글 ID, 게시글 ID, 작성자 ID, 댓글 내용, 작성일을 의미합니다.</p>
<table class="table">
        <thead><tr>
<th>Column name</th>
<th>Type</th>
<th>Nullable</th>
</tr>
</thead>
        <tbody><tr>
<td>REPLY_ID</td>
<td>VARCHAR(10)</td>
<td>FALSE</td>
</tr>
<tr>
<td>BOARD_ID</td>
<td>VARCHAR(5)</td>
<td>FALSE</td>
</tr>
<tr>
<td>WRITER_ID</td>
<td>VARCHAR(50)</td>
<td>FALSE</td>
</tr>
<tr>
<td>CONTENTS</td>
<td>VARCHAR(1000)</td>
<td>TRUE</td>
</tr>
<tr>
<td>CREATED_DATE</td>
<td>DATE</td>
<td>FALSE</td>
</tr>
</tbody>
      </table>
<hr />

<h5>문제</h5>

<p><code>USED_GOODS_BOARD</code>와 <code>USED_GOODS_REPLY</code> 테이블에서 2022년 10월에 작성된 게시글 제목, 게시글  ID, 댓글 ID, 댓글 작성자 ID, 댓글 내용, 댓글 작성일을 조회하는 SQL문을 작성해주세요. 결과는 댓글 작성일을 기준으로 오름차순 정렬해주시고, 댓글 작성일이 같다면 게시글  제목을 기준으로 오름차순 정렬해주세요.</p>

<hr />

<h5>예시</h5>

<p><code>USED_GOODS_BOARD</code> 테이블이 다음과 같고</p>
<table class="table">
        <thead><tr>
<th>BOARD_ID</th>
<th>WRITER_ID</th>
<th>TITLE</th>
<th>CONTENTS</th>
<th>PRICE</th>
<th>CREATED_DATE</th>
<th>STATUS</th>
<th>VIEWS</th>
</tr>
</thead>
        <tbody><tr>
<td>B0001</td>
<td>kwag98</td>
<td>반려견 배변패드 팝니다</td>
<td>정말 저렴히 판매합니다. 전부 미개봉 새상품입니다.</td>
<td>12000</td>
<td>2022-10-01</td>
<td>DONE</td>
<td>250</td>
</tr>
<tr>
<td>B0002</td>
<td>lee871201</td>
<td>국내산 볶음참깨</td>
<td>직접 농사지은 참깨입니다.</td>
<td>3000</td>
<td>2022-10-02</td>
<td>DONE</td>
<td>121</td>
</tr>
<tr>
<td>B0003</td>
<td>goung12</td>
<td>배드민턴 라켓</td>
<td>사놓고 방치만 해서 팝니다.</td>
<td>9000</td>
<td>2022-10-02</td>
<td>SALE</td>
<td>212</td>
</tr>
<tr>
<td>B0004</td>
<td>keel1990</td>
<td>디올 귀걸이</td>
<td>신세계강남점에서 구입. 정품 아닐시 백퍼센트 환불</td>
<td>130000</td>
<td>2022-10-02</td>
<td>SALE</td>
<td>199</td>
</tr>
<tr>
<td>B0005</td>
<td>haphli01</td>
<td>스팸클래식 팔아요</td>
<td>유통기한 2025년까지에요</td>
<td>10000</td>
<td>2022-10-02</td>
<td>SALE</td>
<td>121</td>
</tr>
</tbody>
      </table>
<p><code>USED_GOODS_REPLY</code> 테이블이 다음과 같을 때</p>
<table class="table">
        <thead><tr>
<th>REPLY_ID</th>
<th>BOARD_ID</th>
<th>WRITER_ID</th>
<th>CONTENTS</th>
<th>CREATED_DATE</th>
</tr>
</thead>
        <tbody><tr>
<td>R000000001</td>
<td>B0001</td>
<td>s2s2123</td>
<td>구매하겠습니다. 쪽지 드립니다.</td>
<td>2022-10-02</td>
</tr>
<tr>
<td>R000000002</td>
<td>B0002</td>
<td>hoho1112</td>
<td>쪽지 주세요.</td>
<td>2022-10-03</td>
</tr>
<tr>
<td>R000000003</td>
<td>B0006</td>
<td>hwahwa2</td>
<td>삽니다. 연락주세요.</td>
<td>2022-10-03</td>
</tr>
<tr>
<td>R000000004</td>
<td>B0007</td>
<td>hong02</td>
<td>예약중</td>
<td>2022-10-06</td>
</tr>
<tr>
<td>R000000005</td>
<td>B0009</td>
<td>hanju23</td>
<td>구매완료</td>
<td>2022-10-07</td>
</tr>
</tbody>
      </table>
<p>SQL을 실행하면 다음과 같이 출력되어야 합니다.</p>
<table class="table">
        <thead><tr>
<th>TITLE</th>
<th>BOARD_ID</th>
<th>REPLY_ID</th>
<th>WRITER_ID</th>
<th>CONTENTS</th>
<th>CREATED_DATE</th>
</tr>
</thead>
        <tbody><tr>
<td>반려견 배변패드 팝니다</td>
<td>B0001</td>
<td>R000000001</td>
<td>s2s2123</td>
<td>구매하겠습니다. 쪽지 드립니다.</td>
<td>2022-10-02</td>
</tr>
<tr>
<td>국내산 볶음참깨</td>
<td>B0002</td>
<td>R000000002</td>
<td>hoho1112</td>
<td>쪽지 주세요.</td>
<td>2022-10-03</td>
</tr>
</tbody>
      </table>
<hr />

<h5>주의사항</h5>

<p><code>CREATED_DATE</code>의 포맷이 예시의 포맷과 일치해야 정답처리 됩니다.</p>

<blockquote>
  <p>출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges</p>
</blockquote>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<pre><code class="language-RoomSql">SELECT b.TITLE, 
    b.BOARD_ID, 
    r.REPLY_ID, 
    r.WRITER_ID, 
    r.CONTENTS, 
    DATE_FORMAT(r.CREATED_DATE,'%Y-%m-%d') AS CREATED_DATE
    FROM USED_GOODS_BOARD b
INNER JOIN USED_GOODS_REPLY r 
ON b.BOARD_ID = r.BOARD_ID
WHERE DATE_FORMAT(b.CREATED_DATE, '%Y-%m') = '2022-10'
ORDER BY r.CREATED_DATE ASC, b.TITLE ASC;
</code></pre>

<p>문제에서 출력되어야하는 항목은 BOARD의 <code class="language-plaintext highlighter-rouge">TITLE</code>, <code class="language-plaintext highlighter-rouge">BOARD_ID</code><br />
REPLY의 <code class="language-plaintext highlighter-rouge">WRITER_ID</code>, <code class="language-plaintext highlighter-rouge">CONTENTS</code>, <code class="language-plaintext highlighter-rouge">CREATED_DATE</code> 이다.</p>

<p>BOARD_ID로 INNER JOIN을 하여 BOARD와 REPLY의 모두 있는 데이터를 뽑는다. <br />
즉, 댓글이 달린 게시판의 데이터만 추출해오게 된다. 날짜같은 경우는 주어진 것 처럼 <br />
DATE_FORMAT을 이용해 변경해주고</p>

<p>2022년 10월에 해당하는 데이터를 WHERE절로 걸러준다.<br />
그리고 ORDER BY를 통해 오름차순 정렬을 해주면 되는데 <br />
여기서 정렬조건은 2개이다. 댓글의 날짜(<code class="language-plaintext highlighter-rouge">CREATED_DATE</code>)를 기준으로 오름차순을 하고 <br />
만약 같은 날짜일 경우에는 게시판의 제목(<code class="language-plaintext highlighter-rouge">TITLE</code>)을 기준으로 오름차순 정렬을 해야한다.</p>

<p>ORDER BY 문법에 첫번째 정렬값이 같다면 콤마(,)로 다음 조건을 적어주면 <br />
해당 기준으로 정렬을 진행해준다.</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="SQL" /><category term="SQL" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 조건에 부합하는 중고거래 댓글 조회하기]]></summary></entry><entry><title type="html">[Programmers] 소수 찾기 (Java)</title><link href="http://localhost:4000/algorithm/2023/03/16/algo-prime.html" rel="alternate" type="text/html" title="[Programmers] 소수 찾기 (Java)" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2023/03/16/algo-prime</id><content type="html" xml:base="http://localhost:4000/algorithm/2023/03/16/algo-prime.html"><![CDATA[<h2 id="-문제--소수-찾기">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/42839">소수 찾기</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.</p>

<p>각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.</p>

<h4 id="제한사항">제한사항</h4>

<ul>
<li>numbers는 길이 1 이상 7 이하인 문자열입니다.</li>
<li>numbers는 0~9까지 숫자만으로 이루어져 있습니다.</li>
<li>"013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.</li>
</ul>

<h4 id="입출력-예">입출력 예</h4>

<table class="table">
        <thead><tr>
<th>numbers</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>"17"</td>
<td>3</td>
</tr>
<tr>
<td>"011"</td>
<td>2</td>
</tr>
</tbody>
      </table>

<h4 id="입출력-예-설명">입출력 예 설명</h4>

<p>예제 #1<br />
[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.</p>

<p>예제 #2<br />
[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.</p>

<ul>
<li>11과 011은 같은 숫자로 취급합니다.</li>
</ul>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<h3 id="️-풀이-방법">☀️ 풀이 방법</h3>

<p>이번문제는 String으로 주어지는 문자열을 주어지는데 <br />
문자열 하나씩 만들 수 있는 모든 조합을 소수를 찾아 소수의 <br />
개수를 반환하는 문제이다.</p>

<p>예제로 <code class="language-plaintext highlighter-rouge">17</code>이라는 값이 주어졌을때<br />
<code class="language-plaintext highlighter-rouge">1</code>,<code class="language-plaintext highlighter-rouge">17</code>,<code class="language-plaintext highlighter-rouge">7</code>,<code class="language-plaintext highlighter-rouge">71</code>과 같이 총 4개의 조합을 구할 수 있고 <br />
이 중에 <code class="language-plaintext highlighter-rouge">17</code>,<code class="language-plaintext highlighter-rouge">7</code>,<code class="language-plaintext highlighter-rouge">71</code>이 소수기 때문에 정답은 소수의 개수인 <code class="language-plaintext highlighter-rouge">3</code>을 리턴하면 된다.</p>

<p>여기서 만약 조합을 구하는 길이가 정해져 있다면 <br />
다중 for문을 이용해 풀 수 있지만 지금과 같은 경우에는 <br />
numbers라는 문자열이 1~7개의 길이를 가진 예제가 주어지기 때문에 <br />
재귀를 통한 완전탐색으로 풀어야겠다라는 결론에 도달했다.</p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">012</code>라는 문자열이 주어졌다고 가정하고 아래의 순서를 살펴보자  <br />
해당 예제의 조합에서는 <code class="language-plaintext highlighter-rouge">2</code>라는 값만 소수이기 때문에 리턴값은 <code class="language-plaintext highlighter-rouge">1</code>이어야한다.<br />
<em>(편의상 true=⭕️ / false=❌ 로 표현하겠습니다.)</em></p>

<p><img src="https://user-images.githubusercontent.com/95069395/225528468-38bd539f-096f-411f-bc3f-c7e3edb77f9a.gif" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우선 주어진 문자열을 <code class="language-plaintext highlighter-rouge">int[] arr</code>라는 배열로 쪼개었고 <br />
재귀를 통해 탐색한 곳을 관리하는 <code class="language-plaintext highlighter-rouge">boolean[] visit</code>라는 배열을 만들어 <br />
탐색할 때 해당 배열의 조건을 이용해 조합을 구하였다.  <br />
재귀를 호출하면서 <code class="language-plaintext highlighter-rouge">Set&lt;Integer&gt; answer</code>에 소수인 값들은 담도록하였고 <br />
중복된 값이 들어갈 수 있기 때문에 Collection의 Set을 이용하였다.</p>

<p>위의 그림에서 알 수 있듯이 <br />
arr 배열을 순회할때 재귀함수를 호출하고 호출된 재귀함수에서 <br />
또다시 순회하면서 재귀함수를 호출하는 반복적인 모습을 볼 수 있다.</p>

<p>문제 풀이를 위한 5가지를 살펴보자</p>
<ol>
  <li>arr에서 순회할때 재귀함수가 호출되면 true로 체크한다.</li>
  <li>방문하지 않은 인덱스만 재귀한다.</li>
  <li>재귀할때 현재 본인 인덱스 값을 String 타입 number 변수에 더해 매개변수로 넘겨준다.</li>
  <li>순회한 인덱스는 false로 변경한다.</li>
  <li>재귀 탈출조건은 number 길이와 arr 배열길이가 같을때 입니다.</li>
</ol>

<p>해당 조건을 토대로 코드를 살펴보면서 이해해보자.</p>

<p><br /></p>

<h3 id="-코드">👨🏻‍💻 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 만들수 있는 조합 중 소수의 갯수를 구하는 문제</span>
        <span class="c1">// String 길이가 달라지기 때문에 재귀로 풀어야하는 문제</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span> <span class="c1">// 소수인 값만 담게되는 HashSet</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">recursion</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">answer</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">visit</span><span class="o">);</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span><span class="o">,</span> <span class="nc">String</span> <span class="n">number</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">answer</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visit</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 해당 index 재귀 호출시 방문 체크\</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>  <span class="c1">// String -&gt; int</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="n">num</span><span class="o">))</span> <span class="n">answer</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> <span class="c1">// 소수인 숫자는 Set에 추가 (중복인 것은 제거)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> <span class="c1">// 탈출조건 , number의 문자열길이와 배열길이가 같아질때</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">recursion</span><span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">number</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">answer</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">visit</span><span class="o">);</span> <span class="c1">// number값을 이어붙여서 호출</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 소수일경우 true, 아닐경우 false</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>우선 재귀함수인 <code class="language-plaintext highlighter-rouge">recursion</code> 메서드를 하나 만들었고 <br />
소수를 판단해 소수면 true를 반환하는 메서드인 <code class="language-plaintext highlighter-rouge">isPrime</code>을 만들었다.</p>

<p>처음부터 보면 arr배열을 순회하는 for문이 존재하고 <br />
재귀함수를 호출한다. 0번 인덱스부터 조합을 구하기위해서 재귀함수가 호출되고 <br />
재귀함수를 호출한 후에 방문여부를 표시하는 <code class="language-plaintext highlighter-rouge">visit[index]</code>의 값을 true 설정한다. <br />
그리고 소수인지판단해 Set에 값을 저장하고 아니면 if문을 통과하게 되어진다.</p>

<p>재귀함수 탈출조건을 설정해주고, 본격적으로 조합을 구하기 위한 재귀함수안에 <br />
for문을 한번 더 실행 시킨다. 방문하지않은 곳만 다시 재귀함수를 호출하기 위해서 <br />
if문으로 <code class="language-plaintext highlighter-rouge">!visit[i]</code>라는 조건을 걸어 재귀함수를 호출하게된다.</p>

<p>이렇게 0번 인덱스에 false로 되어있는 곳을 방문하게되고 <br />
재귀함수가 호출될때 <code class="language-plaintext highlighter-rouge">number + arr[i]</code>를 하여 현재 탐색중인 문자열을 <br />
계속 이어붙이면서 현재 어떤 값을 찾고 있는지 알 수 있고 해당조건을 통해서 <br />
재귀함수를 탈출하는 조건으로도 사용할 수 있다.</p>

<p>이렇게 쭉 재귀함수가 탐색을 마치고 탈출조건에 걸리게되면 <br />
<code class="language-plaintext highlighter-rouge">visit[i] = false;</code>를 통해 방문했던 곳을 다시 방문하지 않았다고 변경하고 <br />
탐색중이던 for문을 순회할떄는 다시 원래상태의 visit배열이 되어진다. <br />
이러한 원리로 완전탐색을 통해 조합을 구한뒤 풀이에 맞는 값을 반환해주면 문제해결!</p>

<p>재귀라는 개념이 아직 어색하고 잘 보이지 않기에 연습이 많이 필요해보인다.</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="Algorithm" /><category term="Algorithm" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 소수 찾기]]></summary></entry><entry><title type="html">[Programmers] 과일로 만든 아이스크림 고르기 (MySQL)</title><link href="http://localhost:4000/sql/2023/03/16/sql-icecream.html" rel="alternate" type="text/html" title="[Programmers] 과일로 만든 아이스크림 고르기 (MySQL)" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/sql/2023/03/16/sql-icecream</id><content type="html" xml:base="http://localhost:4000/sql/2023/03/16/sql-icecream.html"><![CDATA[<h2 id="-문제--과일로-만든-아이스크림-고르기">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/133025">과일로 만든 아이스크림 고르기</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>다음은 아이스크림 가게의 상반기 주문 정보를 담은 <code>FIRST_HALF</code> 테이블과 아이스크림 성분에 대한 정보를 담은 <code>ICECREAM_INFO</code> 테이블입니다. <code>FIRST_HALF</code> 테이블 구조는 다음과 같으며, <code>SHIPMENT_ID</code>, <code>FLAVOR</code>, <code>TOTAL_ORDER</code> 는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. <code>FIRST_HALF</code> 테이블의 기본 키는 <code>FLAVOR</code>입니다.</p>
<table class="table">
        <thead><tr>
<th style="text-align: left">NAME</th>
<th style="text-align: left">TYPE</th>
<th>NULLABLE</th>
</tr>
</thead>
        <tbody><tr>
<td style="text-align: left">SHIPMENT_ID</td>
<td style="text-align: left">INT(N)</td>
<td>FALSE</td>
</tr>
<tr>
<td style="text-align: left">FLAVOR</td>
<td style="text-align: left">VARCHAR(N)</td>
<td>FALSE</td>
</tr>
<tr>
<td style="text-align: left">TOTAL_ORDER</td>
<td style="text-align: left">INT(N)</td>
<td>FALSE</td>
</tr>
</tbody>
      </table>
<p><code>ICECREAM_INFO</code> 테이블 구조는 다음과 같으며, <code>FLAVOR</code>, <code>INGREDITENT_TYPE</code> 은 각각 아이스크림 맛, 아이스크림의 성분 타입을 나타냅니다. <code>INGREDIENT_TYPE</code>에는 아이스크림의 주 성분이 설탕이면 <code>sugar_based</code>라고 입력되고, 아이스크림의 주 성분이 과일이면 <code>fruit_based</code>라고 입력됩니다. <code>ICECREAM_INFO</code>의 기본 키는 <code>FLAVOR</code>입니다. <code>ICECREAM_INFO</code>테이블의 <code>FLAVOR</code>는 <code>FIRST_HALF</code> 테이블의  <code>FLAVOR</code>의 외래 키입니다.</p>
<table class="table">
        <thead><tr>
<th style="text-align: left">NAME</th>
<th style="text-align: left">TYPE</th>
<th>NULLABLE</th>
</tr>
</thead>
        <tbody><tr>
<td style="text-align: left">FLAVOR</td>
<td style="text-align: left">VARCHAR(N)</td>
<td>FALSE</td>
</tr>
<tr>
<td style="text-align: left">INGREDIENT_TYPE</td>
<td style="text-align: left">VARCHAR(N)</td>
<td>FALSE</td>
</tr>
</tbody>
      </table>
<hr />

<h5>문제</h5>

<p>상반기 아이스크림 총주문량이 3,000보다 높으면서 아이스크림의 주 성분이 과일인 아이스크림의 맛을 총주문량이 큰 순서대로 조회하는 SQL 문을 작성해주세요.</p>

<hr />

<h5>예시</h5>

<p>예를 들어 <code>FIRST_HALF</code> 테이블이 다음과 같고</p>
<table class="table">
        <thead><tr>
<th style="text-align: left">SHIPMENT_ID</th>
<th style="text-align: left">FLAVOR</th>
<th>TOTAL_ORDER</th>
</tr>
</thead>
        <tbody><tr>
<td style="text-align: left">101</td>
<td style="text-align: left">chocolate</td>
<td>3200</td>
</tr>
<tr>
<td style="text-align: left">102</td>
<td style="text-align: left">vanilla</td>
<td>2800</td>
</tr>
<tr>
<td style="text-align: left">103</td>
<td style="text-align: left">mint_chocolate</td>
<td>1700</td>
</tr>
<tr>
<td style="text-align: left">104</td>
<td style="text-align: left">caramel</td>
<td>2600</td>
</tr>
<tr>
<td style="text-align: left">105</td>
<td style="text-align: left">white_chocolate</td>
<td>3100</td>
</tr>
<tr>
<td style="text-align: left">106</td>
<td style="text-align: left">peach</td>
<td>2450</td>
</tr>
<tr>
<td style="text-align: left">107</td>
<td style="text-align: left">watermelon</td>
<td>2150</td>
</tr>
<tr>
<td style="text-align: left">108</td>
<td style="text-align: left">mango</td>
<td>2900</td>
</tr>
<tr>
<td style="text-align: left">109</td>
<td style="text-align: left">strawberry</td>
<td>3100</td>
</tr>
<tr>
<td style="text-align: left">110</td>
<td style="text-align: left">melon</td>
<td>3150</td>
</tr>
<tr>
<td style="text-align: left">111</td>
<td style="text-align: left">orange</td>
<td>2900</td>
</tr>
<tr>
<td style="text-align: left">112</td>
<td style="text-align: left">pineapple</td>
<td>2900</td>
</tr>
</tbody>
      </table>
<p><code>ICECREAM_INFO</code> 테이블이 다음과 같다면</p>
<table class="table">
        <thead><tr>
<th style="text-align: left">FLAVOR</th>
<th>INGREDIENT_TYPE</th>
</tr>
</thead>
        <tbody><tr>
<td style="text-align: left">chocolate</td>
<td>sugar_based</td>
</tr>
<tr>
<td style="text-align: left">vanilla</td>
<td>sugar_based</td>
</tr>
<tr>
<td style="text-align: left">mint_chocolate</td>
<td>sugar_based</td>
</tr>
<tr>
<td style="text-align: left">caramel</td>
<td>sugar_based</td>
</tr>
<tr>
<td style="text-align: left">white_chocolate</td>
<td>sugar_based</td>
</tr>
<tr>
<td style="text-align: left">peach</td>
<td>fruit_based</td>
</tr>
<tr>
<td style="text-align: left">watermelon</td>
<td>fruit_based</td>
</tr>
<tr>
<td style="text-align: left">mango</td>
<td>fruit_based</td>
</tr>
<tr>
<td style="text-align: left">strawberry</td>
<td>fruit_based</td>
</tr>
<tr>
<td style="text-align: left">melon</td>
<td>fruit_based</td>
</tr>
<tr>
<td style="text-align: left">orange</td>
<td>fruit_based</td>
</tr>
<tr>
<td style="text-align: left">pineapple</td>
<td>fruit_based</td>
</tr>
</tbody>
      </table>
<p>상반기 아이스크림 총주문량이 3,000보다 높은 아이스크림 맛은 chocolate, strawberry, melon, white_chocolate입니다. 이 중에 아이스크림의 주 성분이 과일인 아이스크림 맛은 strawberry와 melon이고 총주문량이 큰 순서대로 아이스크림 맛을 조회하면 melon, strawberry 순으로 조회되어야 합니다. 따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다. </p>
<table class="table">
        <thead><tr>
<th style="text-align: left">FLAVOR</th>
</tr>
</thead>
        <tbody><tr>
<td style="text-align: left">melon</td>
</tr>
<tr>
<td style="text-align: left">strawberry</td>
</tr>
</tbody>
      </table>

<blockquote>
  <p>출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges</p>
</blockquote>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<p><code class="language-plaintext highlighter-rouge">FIRST_HALF</code>, <code class="language-plaintext highlighter-rouge">INGREDIENT_TYPE</code>라는 두개의 테이블이 있다.<br />
두개의 테이블을 JOIN한 다음에 <code class="language-plaintext highlighter-rouge">FIRST_HALF</code> 테이블에서 주문수량이 3000보다 큰값을 찾고  <br />
<code class="language-plaintext highlighter-rouge">INGREDIENT_TYPE</code> 테이블에서는 과일을 나타내는 fruit_based를 찾아 내림차순으로 정렬하면된다.</p>

<pre><code class="language-RoomSql">SELECT F.FLAVOR FROM FIRST_HALF F
LEFT JOIN ICECREAM_INFO I ON I.FLAVOR = F.FLAVOR
WHERE F.TOTAL_ORDER &gt; 3000 AND I.INGREDIENT_TYPE = 'fruit_based'
ORDER BY F.TOTAL_ORDER DESC;
</code></pre>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="SQL" /><category term="SQL" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 과일로 만든 아이스크림 고르기]]></summary></entry><entry><title type="html">[Programmers] 자동차 대여 기록에서 장기/단기 대여 구분하기 (MySQL)</title><link href="http://localhost:4000/sql/2023/03/15/sql-carrent.html" rel="alternate" type="text/html" title="[Programmers] 자동차 대여 기록에서 장기/단기 대여 구분하기 (MySQL)" /><published>2023-03-15T00:00:00+09:00</published><updated>2023-03-15T00:00:00+09:00</updated><id>http://localhost:4000/sql/2023/03/15/sql-carrent</id><content type="html" xml:base="http://localhost:4000/sql/2023/03/15/sql-carrent.html"><![CDATA[<h2 id="-문제--자동차-대여-기록에서-장기단기-대여-구분하기">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/151138">자동차 대여 기록에서 장기/단기 대여 구분하기</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 <code>CAR_RENTAL_COMPANY_RENTAL_HISTORY</code> 테이블입니다. <code>CAR_RENTAL_COMPANY_RENTAL_HISTORY</code> 테이블은 아래와 같은 구조로 되어있으며, <code>HISTORY_ID</code>, <code>CAR_ID</code>, <code>START_DATE</code>, <code>END_DATE</code> 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다.</p>
<table class="table">
        <thead><tr>
<th>Column name</th>
<th>Type</th>
<th>Nullable</th>
</tr>
</thead>
        <tbody><tr>
<td>HISTORY_ID</td>
<td>INTEGER</td>
<td>FALSE</td>
</tr>
<tr>
<td>CAR_ID</td>
<td>INTEGER</td>
<td>FALSE</td>
</tr>
<tr>
<td>START_DATE</td>
<td>DATE</td>
<td>FALSE</td>
</tr>
<tr>
<td>END_DATE</td>
<td>DATE</td>
<td>FALSE</td>
</tr>
</tbody>
      </table>
<hr />

<h5>문제</h5>

<p><code>CAR_RENTAL_COMPANY_RENTAL_HISTORY</code> 테이블에서 대여 시작일이 2022년 9월에 속하는 대여 기록에 대해서 대여 기간이 30일 이상이면 '장기 대여' 그렇지 않으면 '단기 대여' 로 표시하는 컬럼(컬럼명: <code>RENT_TYPE</code>)을 추가하여 대여기록을 출력하는 SQL문을 작성해주세요. 결과는 대여 기록 ID를 기준으로 내림차순 정렬해주세요.</p>

<hr />

<h5>예시</h5>

<p>예를 들어 <code>CAR_RENTAL_COMPANY_RENTAL_HISTORY</code> 테이블이 다음과 같다면</p>
<table class="table">
        <thead><tr>
<th>HISTORY_ID</th>
<th>CAR_ID</th>
<th>START_DATE</th>
<th>END_DATE</th>
</tr>
</thead>
        <tbody><tr>
<td>1</td>
<td>4</td>
<td>2022-09-27</td>
<td>2022-11-27</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2022-10-03</td>
<td>2022-11-04</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2022-09-05</td>
<td>2022-09-05</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>2022-09-01</td>
<td>2022-09-30</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>2022-09-16</td>
<td>2022-10-15</td>
</tr>
</tbody>
      </table>
<p>2022년 9월의 대여 기록 중 '장기 대여' 에 해당하는 기록은 대여 기록 ID가 1, 4인 기록이고, '단기 대여' 에 해당하는 기록은 대여 기록 ID가 3, 5 인 기록이므로 대여 기록 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다.</p>
<table class="table">
        <thead><tr>
<th>HISTORY_ID</th>
<th>CAR_ID</th>
<th>START_DATE</th>
<th>END_DATE</th>
<th>RENT_TYPE</th>
</tr>
</thead>
        <tbody><tr>
<td>5</td>
<td>3</td>
<td>2022-09-16</td>
<td>2022-10-13</td>
<td>단기 대여</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>2022-09-01</td>
<td>2022-09-30</td>
<td>장기 대여</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>2022-09-05</td>
<td>2022-09-05</td>
<td>단기 대여</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>2022-09-27</td>
<td>2022-10-26</td>
<td>장기 대여</td>
</tr>
</tbody>
      </table>
<hr />

<h5>주의사항</h5>

<p><code>START_DATE</code>와 <code>END_DATE</code>의 경우 예시의 데이트 포맷과 동일해야 정답처리 됩니다.</p>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<pre><code class="language-RoomSql">SELECT 
    c.HISTORY_ID, 
    c.CAR_ID, 
    DATE_FORMAT(c.START_DATE, '%Y-%m-%d') AS START_DATE, 
    DATE_FORMAT(c.END_DATE, '%Y-%m-%d') AS END_DATE,
    CASE 
        WHEN DATEDIFF(END_DATE,START_DATE) + 1 &gt;= 30 THEN '장기 대여' 
        ELSE '단기 대여' END AS RENT_TYPE
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY c
WHERE START_DATE BETWEEN '2022-09-01' AND '2022-09-30'
ORDER BY HISTORY_ID DESC;
</code></pre>

<p>여기서 생각해봐야할 것들을 정리해본다.</p>

<ol>
  <li>DATE 형식을 YYYY-MM-DD로 변경하여 출력할 것</li>
  <li>대여시작일 30일을 기준으로 장기대여, 단기대여를 구분하여 RENT_TYPE 칼럼추가</li>
  <li>9월에 속하는 대여기간만 조회해야한다.</li>
  <li>최종 출력된 목록에서 HISTORY_ID 기준으로 내림차순 정렬하기</li>
</ol>

<p>1번은 <code class="language-plaintext highlighter-rouge">DATA_FORMAT</code>을 사용해 변경해주었고</p>

<p>2번은 CASE 문법을 이용해서 일수의 차이를 구한다음 구분이 가능하다.  <br />
시간의 차이를 구할때는 <code class="language-plaintext highlighter-rouge">DATEDIFF(종료날짜,시작날짜)</code>를 사용해 차이를 구해주었고 <br />
차이의 +1을 해야 한달이 된다는 사실을 까먹지말자!</p>

<p>3번은 <code class="language-plaintext highlighter-rouge">BETWEEN</code> 문법으로 9월에 해당하는 것들만 찾고</p>

<p>마지막으로 <code class="language-plaintext highlighter-rouge">ORDER BY</code>를 통해서 정렬해주면 문제는 통과!</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="SQL" /><category term="SQL" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 자동차 대여 기록에서 장기/단기 대여 구분하기]]></summary></entry><entry><title type="html">[Programmers] 조건에 맞는 도서 리스트 출력하기 (MySQL)</title><link href="http://localhost:4000/sql/2023/03/14/sql-book.html" rel="alternate" type="text/html" title="[Programmers] 조건에 맞는 도서 리스트 출력하기 (MySQL)" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/sql/2023/03/14/sql-book</id><content type="html" xml:base="http://localhost:4000/sql/2023/03/14/sql-book.html"><![CDATA[<h2 id="-문제--조건에-맞는-도서-리스트-출력하기">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/144853">조건에 맞는 도서 리스트 출력하기</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>다음은 어느 한 서점에서 판매중인 도서들의 도서 정보(<code>BOOK</code>) 테이블입니다.</p>

<p><code>BOOK</code> 테이블은 각 도서의 정보를 담은 테이블로 아래와 같은 구조로 되어있습니다.</p>
<table class="table">
        <thead><tr>
<th>Column name</th>
<th>Type</th>
<th>Nullable</th>
<th>Description</th>
</tr>
</thead>
        <tbody><tr>
<td>BOOK_ID</td>
<td>INTEGER</td>
<td>FALSE</td>
<td>도서 ID</td>
</tr>
<tr>
<td>CATEGORY</td>
<td>VARCHAR(N)</td>
<td>FALSE</td>
<td>카테고리 (경제, 인문, 소설, 생활, 기술)</td>
</tr>
<tr>
<td>AUTHOR_ID</td>
<td>INTEGER</td>
<td>FALSE</td>
<td>저자 ID</td>
</tr>
<tr>
<td>PRICE</td>
<td>INTEGER</td>
<td>FALSE</td>
<td>판매가 (원)</td>
</tr>
<tr>
<td>PUBLISHED_DATE</td>
<td>DATE</td>
<td>FALSE</td>
<td>출판일</td>
</tr>
</tbody>
      </table>
<hr />

<h5>문제</h5>

<p><code>BOOK</code> 테이블에서 <code>2021년</code>에 출판된 <code>'인문'</code> 카테고리에 속하는 도서 리스트를 찾아서 도서 ID(<code>BOOK_ID</code>), 출판일 (<code>PUBLISHED_DATE</code>)을 출력하는 SQL문을 작성해주세요. <br />
결과는 출판일을 기준으로 오름차순 정렬해주세요.</p>

<hr />

<h5>예시</h5>

<p>예를 들어 <code>BOOK</code> 테이블이 다음과 같다면</p>
<table class="table">
        <thead><tr>
<th>BOOK_ID</th>
<th>CATEGORY</th>
<th>AUTHOR_ID</th>
<th>PRICE</th>
<th>PUBLISHED_DATE</th>
</tr>
</thead>
        <tbody><tr>
<td>1</td>
<td>인문</td>
<td>1</td>
<td>10000</td>
<td>2020-01-01</td>
</tr>
<tr>
<td>2</td>
<td>경제</td>
<td>2</td>
<td>9000</td>
<td>2021-02-05</td>
</tr>
<tr>
<td>3</td>
<td>인문</td>
<td>2</td>
<td>11000</td>
<td>2021-04-11</td>
</tr>
<tr>
<td>4</td>
<td>인문</td>
<td>3</td>
<td>10000</td>
<td>2021-03-15</td>
</tr>
<tr>
<td>5</td>
<td>생활</td>
<td>1</td>
<td>12000</td>
<td>2021-01-10</td>
</tr>
</tbody>
      </table>
<p>조건에 속하는 도서는 도서 ID 가 3, 4인 도서이므로 다음과 같습니다.</p>
<table class="table">
        <thead><tr>
<th>BOOK_ID</th>
<th>PUBLISHED_DATE</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>2021-04-11</td>
</tr>
<tr>
<td>4</td>
<td>2021-03-15</td>
</tr>
</tbody>
      </table>
<p>그리고 출판일 오름차순으로 정렬하여야 하므로 다음과 같은 결과가 나와야 합니다.</p>
<table class="table">
        <thead><tr>
<th>BOOK_ID</th>
<th>PUBLISHED_DATE</th>
</tr>
</thead>
        <tbody><tr>
<td>4</td>
<td>2021-03-15</td>
</tr>
<tr>
<td>3</td>
<td>2021-04-11</td>
</tr>
</tbody>
      </table>
<hr />

<h5>주의사항</h5>

<p><code>PUBLISHED_DATE</code>의 데이트 포맷이 예시와 동일해야 정답처리 됩니다.</p>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<p>Book 테이블에서 <code class="language-plaintext highlighter-rouge">CATEGORY = 인문</code>, <code class="language-plaintext highlighter-rouge">PUBLISHED_DATE = 2021</code>의 값을 <br />
오름차순으로 출력해주는 문제이다.</p>

<p>여기서 주어지는 타입의 DATE가 시간을 포함해주기 때문에<br />
DATE_FORMAT을 사용하여 출력의 날짜 형식과 맞춰줘야한다.</p>

<p>WHERE절을 이용해 인문이라는 카테고리와 <br />
BETWEEN을 이용해 2021년도에 있는 데이터만 추출해온다음 <br />
오름차순으로 정렬해주면 문제 풀이 완료!</p>

<pre><code class="language-RoomSql">SELECT b.BOOK_ID, DATE_FORMAT(b.PUBLISHED_DATE, '%Y-%m-%d') 
AS PUBLISHED_DATE FROM BOOK b
WHERE CATEGORY = '인문' 
AND PUBLISHED_DATE BETWEEN '2021-01-01' AND '2021-12-31'
ORDER BY PUBLISHED_DATE ASC; 
</code></pre>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="SQL" /><category term="SQL" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 조건에 맞는 도서 리스트 출력하기]]></summary></entry><entry><title type="html">[Programmers] 특정 옵션이 포함된 자동차 리스트 구하기 (MySQL)</title><link href="http://localhost:4000/sql/2023/03/14/sql-carlist.html" rel="alternate" type="text/html" title="[Programmers] 특정 옵션이 포함된 자동차 리스트 구하기 (MySQL)" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/sql/2023/03/14/sql-carlist</id><content type="html" xml:base="http://localhost:4000/sql/2023/03/14/sql-carlist.html"><![CDATA[<h2 id="-문제--특정-옵션이-포함된-자동차-리스트-구하기">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/157343">특정 옵션이 포함된 자동차 리스트 구하기</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>다음은 어느 자동차 대여 회사에서 대여중인 자동차들의 정보를 담은 <code>CAR_RENTAL_COMPANY_CAR</code> 테이블입니다. <code>CAR_RENTAL_COMPANY_CAR</code> 테이블은 아래와 같은 구조로 되어있으며, <code>CAR_ID</code>, <code>CAR_TYPE</code>, <code>DAILY_FEE</code>, <code>OPTIONS</code> 는 각각 자동차 ID, 자동차 종류, 일일 대여 요금(원), 자동차 옵션 리스트를 나타냅니다.</p>
<table class="table">
        <thead><tr>
<th>Column name</th>
<th>Type</th>
<th>Nullable</th>
</tr>
</thead>
        <tbody><tr>
<td>CAR_ID</td>
<td>INTEGER</td>
<td>FALSE</td>
</tr>
<tr>
<td>CAR_TYPE</td>
<td>VARCHAR(255)</td>
<td>FALSE</td>
</tr>
<tr>
<td>DAILY_FEE</td>
<td>INTEGER</td>
<td>FALSE</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>VARCHAR(255)</td>
<td>FALSE</td>
</tr>
</tbody>
      </table>
<p>자동차 종류는 '세단', 'SUV', '승합차', '트럭', '리무진' 이 있습니다. 자동차 옵션 리스트는 콤마(',')로 구분된 키워드 리스트(옵션 리스트 값 예시: '열선시트', '스마트키', '주차감지센서')로 되어있으며, 키워드 종류는 '주차감지센서', '스마트키', '네비게이션', '통풍시트', '열선시트', '후방카메라', '가죽시트' 가 있습니다.</p>

<hr />

<h5>문제</h5>

<p><code>CAR_RENTAL_COMPANY_CAR</code> 테이블에서 '네비게이션' 옵션이 포함된 자동차 리스트를 출력하는 SQL문을 작성해주세요. 결과는 자동차 ID를 기준으로 내림차순 정렬해주세요.</p>

<hr />

<h5>예시</h5>

<p>예를 들어 <code>CAR_RENTAL_COMPANY_CAR</code> 테이블이 다음과 같다면</p>
<table class="table">
        <thead><tr>
<th>CAR_ID</th>
<th>CAR_TYPE</th>
<th>DAILY_FEE</th>
<th>OPTIONS</th>
</tr>
</thead>
        <tbody><tr>
<td>1</td>
<td>세단</td>
<td>16000</td>
<td>가죽시트,열선시트,후방카메라</td>
</tr>
<tr>
<td>2</td>
<td>SUV</td>
<td>14000</td>
<td>스마트키,네비게이션,열선시트</td>
</tr>
<tr>
<td>3</td>
<td>SUV</td>
<td>22000</td>
<td>주차감지센서,후방카메라,네비게이션</td>
</tr>
</tbody>
      </table>
<p>'네비게이션' 옵션이 포함된 자동차는 자동차 ID가 2, 3인 자동차이고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같은 결과가 나와야 합니다.</p>
<table class="table">
        <thead><tr>
<th>CAR_ID</th>
<th>CAR_TYPE</th>
<th>DAILY_FEE</th>
<th>OPTIONS</th>
</tr>
</thead>
        <tbody><tr>
<td>3</td>
<td>SUV</td>
<td>22000</td>
<td>주차감지센서,후방카메라,네비게이션</td>
</tr>
<tr>
<td>2</td>
<td>SUV</td>
<td>14000</td>
<td>스마트키,네비게이션,열선시트</td>
</tr>
</tbody>
      </table>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<p>OPTIONS 칼럼의 네비게이션이라고 되어있는 단어를 포함한 <br />
칼럼들을 찾아 ID로 내림차순으로 표현해주는 문제이다.</p>

<pre><code class="language-RoomSql">SELECT CAR_ID, CAR_TYPE, DAILY_FEE, OPTIONS 
FROM CAR_RENTAL_COMPANY_CAR
WHERE OPTIONS LIKE '%네비게이션%'
ORDER BY CAR_ID DESC;
</code></pre>

<p>LIKE 문법과 와일드카드의 이해를 알면 간단하게 풀리는 문제이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">WILDCARD</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">%</td>
      <td>0개 이상의 문자를 대신 표현할 수 있음.</td>
    </tr>
    <tr>
      <td style="text-align: center">_</td>
      <td>1개의 문자를 표현할 수 있음.</td>
    </tr>
  </tbody>
</table>

<p><strong>% 와일드카드의 예제</strong></p>
<ul>
  <li>%m (앞에 어떤글자가 오든 맨마지막이 m으로 끝나는 문제)<br />
-&gt; ex) ham, storm</li>
  <li>m% (맨처음에 시작하는 문자열이 m이되는 모든 문자열) <br />
-&gt; ex) mama, monster</li>
  <li>%m% (문자열 중간에 m이 들어간 모든 문자) <br />
-&gt; ex) aaamaaa, aamaaa, m</li>
</ul>

<p><br /></p>

<p><strong>_ 와일드카드의 예제</strong></p>
<ul>
  <li>_012 (4개의 문자열에서 첫번째는 모든문자열허용, 2~4는 012로 고정인 값)<br />
-&gt; ex) t012, m012, 1012 , 44012(오답)</li>
</ul>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="SQL" /><category term="SQL" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 특정 옵션이 포함된 자동차 리스트 구하기]]></summary></entry><entry><title type="html">네트워크 기초와 TCP/IP 4계층 모델</title><link href="http://localhost:4000/cs/2023/03/08/it-etc-network.html" rel="alternate" type="text/html" title="네트워크 기초와 TCP/IP 4계층 모델" /><published>2023-03-08T00:00:00+09:00</published><updated>2023-03-08T00:00:00+09:00</updated><id>http://localhost:4000/cs/2023/03/08/it-etc-network</id><content type="html" xml:base="http://localhost:4000/cs/2023/03/08/it-etc-network.html"><![CDATA[<h3 id="네트워크-기초">네트워크 기초</h3>

<h4 id="네트워크란">네트워크란?</h4>

<p>노드(node)와 링크(link)가 서로 연결되어 있거나 연결되어 있으며<br />
리소스를 공유하는 집합을 의미한다. 여기서 노드란 서버,라우터,스위치 등 네트워크 <br />
장치를 의미하고 링크는 유선 또는 무선을 의미한다.</p>

<p><br /></p>

<h4 id="처리량">처리량</h4>

<p>네트워크를 구축할 때는 ‘좋은’ 네트워크로 만드는 것이 중요하다. <br />
조은 네트워크란 많은 처리량을 처리할 수 있으며 지연 시간이 짧고 장애 빈도가 <br />
적으며 좋은 보안을 갖춘 네트워크를 말한다.</p>

<p>처리량(throughput)은 링크 내에서 성공적으로 전달된 데이터의 양을 말하고<br />
보통 얼만큼의 트래픽을 처리했는지를 나타낸다.</p>

<p><em><strong>많은 트래픽을 처리한다 = 많은 처리량을 가진다.</strong></em></p>

<p><img src="https://user-images.githubusercontent.com/95069395/223918518-917aeb8f-f620-401e-94c3-a582ab9869bc.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>단위로는 bps(bits per second)를 쓴다. 초당 전송 또는 수신되는 비트수라는 의미이다. <br />
처리량은 사용자들이 많이 접속할 때마다 커지는 트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에<br />
발생하는 에러, 장치의 하드웨어 스펙에 영향을 받는다.</p>

<ul>
  <li>트래픽이 많아졌다 = 흐르는 데이터가 많아졌다.</li>
  <li>처리량이 많아졌다 = 처리되는 트래픽이 많아졌다.</li>
</ul>

<p><br /></p>

<h4 id="지연-시간">지연 시간</h4>

<p>지연시간이란 요청이 처리되는 시간을 말하며 어떤 메세지가 두 장치 사이를 왕복하는 데 걸리는 시간을 말한다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223918992-2c50b9a0-204f-4bea-9aee-d96fa4720cee.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>해당 그림의 지연시간은 1.7초이다. <br />
지연 시간은 매체 타입(무선,유선), 패킷 크기, 라우터의 패킷 처리 시간에 영향을 받는다.</p>

<p><br /></p>

<h4 id="네트워크-토폴로지">네트워크 토폴로지</h4>

<p>네트워크 토폴로지는 노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태를 의미한다.   <br />
네트워크 토폴로지 방식에는 트리,버스,스타,링형,메시 등이 있다.</p>

<p><strong><em>❗️링크와 노드란 ?</em></strong><br />
링크는 네트워크의 연결매체를 얘기하고, 노드는 네트워크 연결 대상이다.(컴퓨터 등)</p>

<p><strong>1). 트리 토폴로지</strong></p>

<p><img src="https://user-images.githubusercontent.com/95069395/223926751-9841a69b-abdb-41be-9509-d9bf89e54a60.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>장점 : 노드의 추가, 삭제가 쉽다.<br />
단점 : 트래픽이 몰릴 때, 하위 노드에 영향을 끼칠 수 있다.</p>

<p><strong>2). 버스 토폴리지</strong></p>

<p><img src="https://user-images.githubusercontent.com/95069395/223926756-9bcefb65-3304-4f6c-b2ac-7de1db6063bf.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>장점 : 신뢰성이 우수하며, 설치 비용이 적다. 중앙 통신 회선에 노드를 추가하거나 삭제하기 쉽다. <br />
단점 : 스푸핑이 가능하다.   핑</p>

<p><em><strong>❗️스푸핑 ?</strong></em> <br />
LAN 상에서 송신부의 패킷을 관련 없는 수신부의 호스트로 가지 않도록 하는 기능을 못하게 하는 현상. <br />
올바르게 수신부로 가야할 패킷이 의도치 않은 노드로 가게 된다.</p>

<p><strong>3). 스타 토폴로지</strong></p>

<p><img src="https://user-images.githubusercontent.com/95069395/223926759-9e6ad865-4199-4fee-8f96-69daa6387735.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>장점 : 노드를 추가하거나, 에러를 탐지하기가 쉽다. 패킷의 충돌 발생 가능성이 적다. <br />
어떠한 노드에 장애가 발생했을 때, 이를 발견하기가 쉽다. <br />
단점 : 중앙 노드에 장애가 발생시, 전체 네트워크에 영향을 준다.</p>

<p><strong>4). 링형 토폴로지</strong></p>

<p><img src="https://user-images.githubusercontent.com/95069395/223926760-b057979e-22fe-4900-9dd4-3ceeca729aa8.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>장점 : 노드의 수가 늘어나도 네트워크 상의 손실이 거의 없다. 충돌이 발생할 가능성이 적다.
단점 : 한 노드 및 회선에 문제가 발생 시 네트워크 전체에 영향을 미친다.</p>

<p><strong>5). 메시 토폴로지</strong></p>

<p><img src="https://user-images.githubusercontent.com/95069395/223926761-40a387bc-5dbf-46c0-ab45-66a773e2ac35.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>장점 : 한 노드에서 장애가 발생해도 경로가 여러개이기 때문에 네트워크 유지가 된다.<br />
트래픽의 분산처리가 용이하다. <br />
단점 : 노드의 추가 및 제거가 어렵고, 구축 및 운용 비용이 비싸다.</p>

<p><br /></p>

<h4 id="네트워크-분류">네트워크 분류</h4>

<p>네트워크는 규모를 기반으로 분류할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223925633-73f52c7a-9029-4d10-bac5-2eba3951a1c3.png" alt="image" class="align-left" style="max-width: 70%" /><br />
<a href="http://www.differencebetween.net/technology/difference-between-lan-wan-and-man/">그림 출처 - differencebetween.net</a></p>

<p>사무실과 개인적으로 소유 가능한 규모인 LAN (Local Area Network) <br />
서울시 등 시 정도의 규모인 MAN (Metropolitan Area Network) <br />
세계 규모의 WAN (Wide Area Network)</p>

<p>규모에 따라 전송속도의 혼잡도가 증가한다. (LAN &lt; MAN &lt; WAN)</p>

<p><br /></p>

<h4 id="네트워크-성능-분석-명령어">네트워크 성능 분석 명령어</h4>

<p>애플리케이션 코드상에는 전혀 문제가 없는데, 사용자가 서비스로부터 데이터를 가져오지 못하는 <br />
상황이 발생하기도 한다. 이는 네트워크 병목 현상일 가능성이 있고, 네트워크로부터 발생한 문제점 <br />
인지를 확인 후 네트워크 성능 분석을 해봐야 한다. 이때 사용하는 명령어들을 적어보자.</p>

<p><strong>1). ping</strong></p>

<p>ping(Packet INternet Groper)은 네트워크 상태를 확인하려는 대상 노드를 향해 <br />
일정 크기의 패킷을 전송하는 명령어이다.</p>

<p>리눅스를 기준으로 구글 IP(66.249.64.97)로 5번의 핑 테스트를 하고 싶다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ping 66.249.64.97 <span class="nt">-c</span> 5
PING 66.249.64.97 <span class="o">(</span>66.249.64.97<span class="o">)</span>: 56 data bytes
64 bytes from 66.249.64.97: <span class="nv">icmp_seq</span><span class="o">=</span>0 <span class="nv">ttl</span><span class="o">=</span>114 <span class="nb">time</span><span class="o">=</span>238.246 ms
64 bytes from 66.249.64.97: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>114 <span class="nb">time</span><span class="o">=</span>246.734 ms
64 bytes from 66.249.64.97: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>114 <span class="nb">time</span><span class="o">=</span>237.321 ms
64 bytes from 66.249.64.97: <span class="nv">icmp_seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>114 <span class="nb">time</span><span class="o">=</span>236.923 ms
64 bytes from 66.249.64.97: <span class="nv">icmp_seq</span><span class="o">=</span>4 <span class="nv">ttl</span><span class="o">=</span>114 <span class="nb">time</span><span class="o">=</span>238.359 ms
</code></pre></div></div>
<p>위와 같이 테스트 결과가 표시된다.<br />
해당 노드의 패킷 수신 상태와 도달하기까지 시간등을 알 수 있으며<br />
네트워크가 잘 연결되어 있는지 확인할 수 있습니다.</p>

<p><br /></p>

<p><strong>2). netstat</strong></p>

<p>접속되어 있는 서비스들의 네트워크 상태를 표시하는 명령어이다. <br />
네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 등 리스트를 보여줍니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>netstat
Active Internet connections
Proto Recv-Q Send-Q  Local Address          Foreign Address        <span class="o">(</span>state<span class="o">)</span>
tcp4       0      0  192.168.219.106.51923  tp-in-f109.1e100.imaps ESTABLISHED
tcp4      50      0  192.168.219.106.51916  125.209.238.153.imaps  CLOSE_WAIT
tcp4       0      0  192.168.219.106.51915  162.247.243.29.https   ESTABLISHED
tcp4       0      0  192.168.219.106.51914  server-54-230-61.https ESTABLISHED
</code></pre></div></div>

<p><br /></p>

<p><strong>3). nslookup</strong></p>

<p>DNS에 관련된 내용을 확인하기 위해 쓰는 명령어이다. <br />
특정 도메인에 맵핑된 IP를 확인하기 위해 사용한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nslookup
<span class="o">&gt;</span> google.com
Server:		61.41.153.2
Address:	61.41.153.2#53

Non-authoritative answer:
Name:	google.com
Address: 172.217.24.78
</code></pre></div></div>

<p><br /></p>

<p><strong>4). tracert</strong></p>

<p>윈도우에서는 tracert이고 리눅스에서는 traceroute라는 명령어이다.<br />
노드까지 네트워크 경로를 확인할 때 사용하는 명령어이다. 목적지 노드까지 구간들 중 <br />
어느 구간에서 응답 시간이 느려지는지 등을 확인할 수 있다.</p>

<p>구글 노드까지의 경로를 확인하는 예제를 보자.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>traceroute 172.217.24.78
traceroute to 172.217.24.78 <span class="o">(</span>172.217.24.78<span class="o">)</span>, 64 hops max, 52 byte packets
 1  192.168.219.1 <span class="o">(</span>192.168.219.1<span class="o">)</span>  2.039 ms  2.223 ms  2.153 ms
 2  180.230.197.1 <span class="o">(</span>180.230.197.1<span class="o">)</span>  4.158 ms  5.895 ms  5.859 ms
 3  10.240.241.189 <span class="o">(</span>10.240.241.189<span class="o">)</span>  5.620 ms  11.481 ms  5.485 ms
 4  10.204.44.93 <span class="o">(</span>10.204.44.93<span class="o">)</span>  3.383 ms  3.860 ms  3.336 ms
 5  1.213.16.169 <span class="o">(</span>1.213.16.169<span class="o">)</span>  3.285 ms
    61.43.176.9 <span class="o">(</span>61.43.176.9<span class="o">)</span>  2.534 ms
    61.43.207.13 <span class="o">(</span>61.43.207.13<span class="o">)</span>  2.882 ms
 6  <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>
 7  <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>
 8  1.208.167.5 <span class="o">(</span>1.208.167.5<span class="o">)</span>  8.190 ms
    1.213.115.13 <span class="o">(</span>1.213.115.13<span class="o">)</span>  14.300 ms  4.141 ms
 9  61.42.0.26 <span class="o">(</span>61.42.0.26<span class="o">)</span>  41.057 ms
    1.208.167.38 <span class="o">(</span>1.208.167.38<span class="o">)</span>  43.814 ms
    1.208.106.174 <span class="o">(</span>1.208.106.174<span class="o">)</span>  47.441 ms
10  210.107.126.38 <span class="o">(</span>210.107.126.38<span class="o">)</span>  80.176 ms
    1.208.178.26 <span class="o">(</span>1.208.178.26<span class="o">)</span>  63.977 ms
    61.43.220.22 <span class="o">(</span>61.43.220.22<span class="o">)</span>  43.209 ms
11  142.250.168.244 <span class="o">(</span>142.250.168.244<span class="o">)</span>  51.090 ms  58.378 ms  43.391 ms
12  <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>
13  108.170.233.30 <span class="o">(</span>108.170.233.30<span class="o">)</span>  38.043 ms
    142.250.230.198 <span class="o">(</span>142.250.230.198<span class="o">)</span>  42.186 ms
    108.170.241.97 <span class="o">(</span>108.170.241.97<span class="o">)</span>  47.815 ms
14  108.170.241.79 <span class="o">(</span>108.170.241.79<span class="o">)</span>  47.372 ms
    142.251.245.23 <span class="o">(</span>142.251.245.23<span class="o">)</span>  47.688 ms
    108.170.241.80 <span class="o">(</span>108.170.241.80<span class="o">)</span>  47.576 ms
15  sin10s06-in-f14.1e100.net <span class="o">(</span>172.217.24.78<span class="o">)</span>  40.511 ms
    209.85.142.26 <span class="o">(</span>209.85.142.26<span class="o">)</span>  46.256 ms
    sin10s06-in-f14.1e100.net <span class="o">(</span>172.217.24.78<span class="o">)</span>  39.145 ms
</code></pre></div></div>

<p><br /></p>

<h4 id="네트워크-프로토콜-표준화">네트워크 프로토콜 표준화</h4>

<p>네트워크 프로토콜이란 다른 장치들끼리 데이터를 주고받기 위해 설정된 공통된 인터페이스를 <br />
말한다. 이러한 프로토콜은 기업이나 개인 발표에서 정하는 것이 아니라 IEEE 또는 IETF라는 <br />
표준화 단체가 이를 정한다.</p>

<p>IEEE802.3은 유선 LAN 프로토콜로 유선으로 LAN을 구축할 때 쓰이는 프로토콜이다. <br />
이를 통해 만든 기업이 다른 장치라도 서로 데이터를 수신할 수 있는 것이다.</p>

<p><br /></p>

<h3 id="tcpip">TCP/IP</h3>

<h4 id="계층-구조">계층 구조</h4>

<p><strong>TCP/IP는 데이터가 의도된 목적지에 닿을 수 있도록 보장해주는 프로토콜(통신규약)이다.</strong></p>

<p><img src="https://user-images.githubusercontent.com/95069395/224016057-b541b0fc-87b3-49a7-b18a-83941944e0fd.png" alt="image" class="align-left" style="max-width: 70%" /><br />
<a href="https://velog.io/@pixelstudio/TCPIP%EC%99%80-OSI-7-%EB%A0%88%EC%9D%B4%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">그림 출처 - pixelstudio</a></p>

<p><br /></p>

<p>OSI 7계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말한다. <br />
두 가지 네트워크 모델 중 가장 큰 차이점은 OSI는 개념적 모델로 통신에는 실질적으로 <br />
사용되지 않지만 TCP/IP는 통신에 실질적으로 사용하고있다.</p>

<p>OSI 7계층은 단계별로 통신을 일어나는 과정을 파악하기 용이하고<br />
특정 계층에 이상이 생긴다면 해당 계층만 수정해 문제를 해결할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223934632-1b6ab954-869f-411d-a2a9-878088db0223.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>TCP/IP 모델은 OSI 모델에 맵핑이 가능하다.<br />
TCP/IP 4계층에서 애플리케이션 계층은 <br />
OSI 7계층에서는 3계층을(애플리케이션 계층, 프레젠테이션 계층, 세션 계층)</p>

<p>마찬가지로 TCP/IP 링크(네트워크) 계층은 <br />
OSI 7계층에서는 2계층을(데이터 링크 계층, 물리 계층) 맵핑할 수 있다.</p>

<p>이 계층들은 특정 계층이 변경되었을 때, 다른 계층이 영향을 받지 않도록 설계되어있다. <br />
예를들어서 전송 계층에서 TCP를 UDP로 변경했다고 해서 인터넷 웹 브라우저를 다시 설치해야 하는<br />
것이 아니듯 유연하게 설계되어진 계층들이다.</p>

<p><br /></p>

<h4 id="osi-7계층">OSI 7계층</h4>

<p><strong>1). 물리 계층</strong></p>

<p>이름 그대로 물리적인 계층이다. 주로 전기적, 기계적, 기능적인 특성을 이용해 <br />
통신 케이블로 데이터를 전송한다. 이 계층에서는 데이터를 전송하려는 데이터가 무엇인지<br />
에러가 있는지 등에는 전혀 신경 쓰지 않는 계층이다.</p>

<p>해당 계층에 속하는 대표적인 장비는 통신 케이블(랜선), 허브, 리피터가 있다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224021103-0fd98a2e-f607-4e36-a510-efd75d44a0fc.png" alt="image" class="align-left" style="max-width: 40%" /></p>

<p><span style="color:#F04965"><strong>한줄 정리 : 통신 케이블, 리피터, 허브 등을 통해 데이터를 데이터 링크 계층으로 전송한다.</strong></span></p>

<p><br /></p>

<p><strong>2). 데이터 링크 계층</strong></p>

<p>송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보를 전달할 수 있도록 해주는 계층이다.<br />
이 계층에서는 맥 주소를 가지고 통신하게 된다. 이 계층에 전송되는 단위를 프레임이라하고 <br />
대표적인 장비에는 브리지, 스위치 등이 있다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224020739-82a629f2-4132-486f-ae08-331cbd311ea2.png" alt="image" class="align-left" style="max-width: 40%" /></p>

<p>즉, 브리지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 네트워크 계층으로 전달한다.<br />
<span style="color:#F04965"><strong>한줄정리 : 에러검층, 재전송, 흐름제어를 하는 계층</strong></span></p>

<p><strong><em>❗️스위치와 허브의 차이</em></strong> <br />
허브가 스위치와 다른점은 연결된 기기 중 하나에서 전송된 패킷이 허브에<br />
연결된 모든 기기로 브로드캐스팅된다는 점이다. 반면 스위치는 패킷의 목적지 주소로<br />
지정된 기기로 이어지는 포트로만 패킷이 전달된다.</p>

<p><strong><em>❗️브로드캐스팅이란?</em></strong><br />
송신 호스트가 전송한 데이터가 네트워크에 연결된 호스트에 전송되는 방식<br />
(방송처럼 불특정 다수에게 보내는 형식)</p>

<p><strong><em>❗패킷이란?️</em></strong><br />
컴퓨터 네트워크가 전달하는 데이터의 형식화된 블록</p>

<p><strong><em>❗MAC 주소?️</em></strong><br />
컴퓨터나 노트북 등 각 장치에는 네트워크에 연결하기 위한 장치(LAN카드)가 있는데<br />
이를 구별하기위한 식별번호를 말한다. 6바이트로 구성된다.
️</p>

<p><br /></p>

<p><strong>3). 네트워크 계층</strong><br />
이 계층에서는 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)이다.<br />
경로를 선택하고 주소(IP)를 정하고 경로에 따라 패킷을 전달해주는 것이 이계층의 역할이다.<br />
여기에 사용되는 프로토콜의 종류도 다양하고, 라우팅하는 기술도 다양하다.</p>

<p><span style="color:#F04965"><strong>한줄정리 : 주소부여(IP), 경로설정(Route)의 역할을 맡는다</strong></span></p>

<p><br /></p>

<p><strong>4). 전송 계층</strong><br />
통신을 활성화하기 위한 계층이다. 보통 TCP 프로토콜을 이용하고, 포트를 열어서 응용프로그램들이<br />
전송을 할 수 있게 한다. 만약 데이터가 왔다면 해당 데이터를 하나로 합쳐서 5계층에 던져준다. <br />
즉, 전송 계층은 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것을 뜻한다.</p>

<p>TCP 프로토콜?</p>
<ul>
  <li>순서를 보장한다.</li>
  <li>연결지향 프로토콜을 사용하여 연결한다.</li>
  <li>가상 패킷 교환 방식을 사용한다.
    <ul>
      <li>가상회선 패킷 교환 방식은 각 패킷에는 가상회선 식별자가 포함되며 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 <code class="language-plaintext highlighter-rouge">순서대로</code> 도착하는 방식을 말한다.</li>
    </ul>
  </li>
</ul>

<p>UDP 프로토콜?</p>
<ul>
  <li>순서를 보장하지 않는다.</li>
  <li>수신 여부를 확인하지 않으며 비연결성을 가진다.</li>
  <li>데이터그래매 패킷 교환 방식을 사용한다.
    <ul>
      <li>패킷이 독립적으로 이동하며 최적의 경로를 선택하여 가는데 하나의 메세지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있으며 도착한 <code class="language-plaintext highlighter-rouge">순서가 다를</code> 수 있는 방식을 뜻한다.</li>
    </ul>
  </li>
</ul>

<p><strong><em>❓순서도 보장되지 않고 비연결을 지향하는데 어디에 쓰는가?</em></strong> <br />
UDP 통신 프로토콜은 신뢰성을 보장하지는 않지만 TCP에 비해 빠른 속도를 제공한다.<br />
비연결성을 지향하기 때문에 데이터를 재전송할 필요도 없고, 흐름 제어나 에러체크도 항상 필요하진 않다. <br />
이러한 이유로 신뢰성보다 연속성,성능이 더욱 중요시되는 서비스에서 UDP를 사용한다. <br />
ex) 멀티미디어 스트리밍, 인터넷 전화 등</p>

<p><span style="color:#F04965"><strong>한줄정리 : 패킷생성 및 세션계층에 전송</strong></span></p>

<p><br /></p>

<p><strong>5). 세션 계층</strong><br />
데이터가 통신하기 위한 논리적연결을 말한다. 통신을 하기위한 대문이라 보면된다. <br />
이 계층에서는 TCP/IP 세션을 만들고 없애는 책임을 가진다.<br />
즉, 세션 계층은 응용 프로그램 간의 대화를 유지하기 위한 구조를 제공하고, 이를 처리하기 위해<br />
프로세스들의 논리적인 연결을 담당하는 계층이다.</p>

<p><span style="color:#F04965"><strong>한줄정리 : 통신을 하기 위한 세션 확립, 유지, 중단을 수행한다.</strong></span></p>

<p><br /></p>

<p><strong>6). 표현 계층</strong><br />
이 계층은 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다르는 부담을<br />
응용 계층으로부터 덜어준다. MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.</p>

<p>예를 들면 해당 데이터가 TEXT인지, GIF인지, JPG인지의 구분 등이 표현 계층의 몫이다.</p>

<p><span style="color:#F04965"><strong>한줄정리 : 사용자의 명령어를 완성 및 결과 표현</strong></span></p>

<p><br /></p>

<p><strong>7). 애플리케이션(응용) 계층</strong><br />
최종 목적지로서 HTTP, FTP, SMTP, POP3, IMAP, Telnet등과 같은 프로토콜이 있다. <br />
사용자가 네트워크에 엑세스 할 수 있도록 하는 응용 프로그램 그룹이다.</p>

<p><span style="color:#F04965"><strong>한줄정리 : 응용 프로세스 간의 정보교환, 파일 전송 등의 서비스를 제공한다.</strong></span></p>

<p><br /></p>

<h4 id="tcpip-4계층">TCP/IP 4계층</h4>

<p><strong>1). 링크 계층(네트워크 엑세스)</strong><br />
OSI 7계층의 물리계층, 데이터 링크 계층에 해당한다. <br />
데이터를 전기신호로 변환한 , 물리적인 주소인 MAC 주소를 사용해, 알맞는 기기로<br />
데이터를 전달하는 계층이다.</p>

<p><br /></p>

<p><strong>2). 인터넷 계층</strong> <br />
OSI 7계층의 네트워크 계층에 해당한다.<br />
패킷을 최종 목적지까지 라우팅하는 계층이다.</p>

<p><br /></p>

<p><strong>3). 전송 계층</strong>  <br />
OSI 7계층의 전송 계층에 해당한다.<br />
통신 노드 간 신뢰성 있는 데이터 전송을 보장하는 계층이다.</p>

<p><br /></p>

<p><strong>4). 애플리케이션 계층</strong><br />
OSI 7계층의 세션 계층, 표현 계층, 응용 계층에 해당한다.<br />
사용자와 가장 가까운 계층으로, 사용자-소프트웨어 간 소통을 담당하는 계층이다.<br />
애플리케이션을 실행하기 위한 데이터 형식이 작성된다.</p>

<p><br /></p>

<h4 id="tcpip-vs-osi">TCP/IP vs OSI</h4>

<table>
  <thead>
    <tr>
      <th>항목</th>
      <th>OSI 7계층</th>
      <th>TCP/IP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>계층</td>
      <td>7계층 모델</td>
      <td>4계층 모델</td>
    </tr>
    <tr>
      <td>구성</td>
      <td>역할 기반 계층 구성</td>
      <td>프로토콜의 집합 기반</td>
    </tr>
    <tr>
      <td>기술</td>
      <td>통신전반 기술 표준화</td>
      <td>데이터 전송기술 특화</td>
    </tr>
    <tr>
      <td>활용</td>
      <td>통신 모델 표준 제시</td>
      <td>실무적 통신기술 구현</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h4 id="tcp-연결-성립-과정">TCP 연결 성립 과정</h4>

<p>TCP는 신뢰성을 확보할 때 3-way handshake라는 작업을 진행한다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224047350-494f0558-eee5-453f-a1bf-0f99fc6e6745.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보낸다.<br />
SYN + ACK 단계 : 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로<br />
클라이언트의 ISN + 1을 보냅니다.<br />
ACK 단계 : 클라이언트는 서버의 ISN + 1 한 값인 승인번호를 담아 ACK를 서버에 보낸다.</p>

<p>위의 과정 이후 신뢰성이 구축되고 데이터 전송을 시작한다.</p>

<p><strong><em>❗️ISN ?</em></strong>  <br />
Initial Sequence Numbers의 약어이며<br />
새로운 TCP연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말하며 이는 장치마다 다를 수 있다.</p>

<p><br /></p>

<h4 id="tcp-연결-해제-과정">TCP 연결 해제 과정</h4>

<p>TCP가 연결을 해제할 때는 4-way handshake 과정이 발생한다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224054280-9cc960ab-27b1-40a2-b348-2e22f3f6693d.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>1번 : 먼저 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보낸다. <br />
그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다립니다.</p>

<p>2번 : 서버는 클라이언트로 ACK라는 승인 세그먼트를 보낸다. 그리고 CLOSE_WAIT<br />
상태에 들어간다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어간다.</p>

<p>3번 : 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보내다.</p>

<p>4번 : 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED  <br />
상태가 된다. 이후 클라이언트는 어느 정도의 시간을 대기한 후 연결이 닫히고 클라이언트와<br />
서버의 모든 자원의 연결이 해제된다.</p>

<p>TIME_WAIT을 눈여겨 봐야한다. 4번에서 연결을 바로 닫지 않고 일정 시간 뒤에 닫는 이유는<br />
지연 패킷이 발생할 경우를 대비하기 위함이고, 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면<br />
데이터 무결성 문제가 발생하기때문이다. 마지막으로 두 장치가 연결이 닫혔는지 확인하기 위해서이다. <br />
LAST_ACK 상태에서 닫히게되면 다시 새로운 연결을 하려고 할때 장치는 줄곧 LAST_ACK로 되어있기 떄문에 <br />
접속 오류가 나타날 수 있기 때문에 TIME_WAIT라는 일정 시간이 필요하다고한다.</p>

<p><br /></p>

<h4 id="계층-간-데이터-송수신-과정">계층 간 데이터 송수신 과정</h4>

<p>HTTP를 통해 웹서버에 있는 데이터를 요청할 경우 아래와 같은 과정이 발생한다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224226896-ae323226-5c8d-4366-8039-ad940fc94f70.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>보내는 요청들은 캡슐화 과정을 거쳐 전달되고, 다시 링크 계층을 통해 해당 서버와 통신을하고<br />
해당 서버의 링크 계층으로부터 애플리케이션까지 비캡슐화 과정을 거쳐 데이터가 전송된다.<br />
최종적으로 사용자에게는 PDU인 메세지로 전달됩니다.</p>

<p>1). 캡슐화 과정<br />
상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 포함시키고 해당 계층의<br />
헤더를 삽입하는 과정을 말한다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224228665-0c3da47a-0928-4479-84ac-308166a69be7.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>2). 비캡슐화 과정<br />
하위 계층에서 상위 계층으로 가며 각 계층의 헤더 부분을 제거하는 과정을 말한다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/224228697-89a69997-c7c5-4c0d-857b-027ae6b42b8d.png" alt="image" class="align-left" style="max-width: 70%" /></p>

<p><br /></p>

<h4 id="pdu">PDU</h4>

<p>네트워크의 어떠한 계층에서 계층으로 데이터가 전달될 때 한 덩어리의 단위를 <br />
PDU(Protocol Data Unit)라고 한다. 제어 관련 정보들이 포함된 <code class="language-plaintext highlighter-rouge">헤더</code><br />
데이터를 의미하는 <code class="language-plaintext highlighter-rouge">페이로드</code>로 구성되어 있으며, 계층마다 부르는 명칭이 다르다.</p>

<ul>
  <li>애플리케이션 계층 : 메세지</li>
  <li>전송 계층 : 세그먼트(TCP), 데이터그램(UDP)</li>
  <li>인터넷 계층 : 패킷</li>
  <li>링크 계층 : 프레임(데이터 링크 계층), 비트(물리 계층)</li>
</ul>

<p><br /><br />
<br /></p>

<p>✨ 참고 사이트</p>
<ul>
  <li><a href="https://www.javatpoint.com/osi-vs-tcp-ip">javatpoint.com</a></li>
  <li><a href="https://devowen.com/344">devowen님</a></li>
  <li><a href="https://wooono.tistory.com/507">wooono님</a></li>
</ul>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="CS" /><category term="ComputerScience" /><summary type="html"><![CDATA[네트워크 기초]]></summary></entry><entry><title type="html">[Programmers] K 번째수 (Java)</title><link href="http://localhost:4000/algorithm/2023/03/08/algo-knumber.html" rel="alternate" type="text/html" title="[Programmers] K 번째수 (Java)" /><published>2023-03-08T00:00:00+09:00</published><updated>2023-03-08T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2023/03/08/algo-knumber</id><content type="html" xml:base="http://localhost:4000/algorithm/2023/03/08/algo-knumber.html"><![CDATA[<h2 id="-문제--k-번째수">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/42748">K 번째수</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.</p>

<p>예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면</p>

<ol>
<li>array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다.</li>
<li>1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다.</li>
<li>2에서 나온 배열의 3번째 숫자는 5입니다.</li>
</ol>

<p>배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>

<h4 id="제한사항">제한사항</h4>

<ul>
<li>array의 길이는 1 이상 100 이하입니다.</li>
<li>array의 각 원소는 1 이상 100 이하입니다.</li>
<li>commands의 길이는 1 이상 50 이하입니다.</li>
<li>commands의 각 원소는 길이가 3입니다.</li>
</ul>

<h4 id="입출력-예">입출력 예</h4>

<table class="table">
        <thead><tr>
<th>array</th>
<th>commands</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[1, 5, 2, 6, 3, 7, 4]</td>
<td>[[2, 5, 3], [4, 4, 1], [1, 7, 3]]</td>
<td>[5, 6, 3]</td>
</tr>
</tbody>
      </table>

<h4 id="입출력-예-설명">입출력 예 설명</h4>

<p>[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.<br />
[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.<br />
[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다.</p>

<h4 id="입출력-예-설명-1">입출력 예 설명</h4>

<ul>
<li>1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.</li>
<li>4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.</li>
<li>5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.</li>
</ul>

<p>※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.</p>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<h3 id="️-풀이-방법">☀️ 풀이 방법</h3>

<p>이번 문제이해해는 크게 어려운 점은 없었다.<br />
주어진 배열에 <code class="language-plaintext highlighter-rouge">i</code>,<code class="language-plaintext highlighter-rouge">j</code>의 길이만큼 추출한다음 그 배열에서<br />
<code class="language-plaintext highlighter-rouge">k</code>번째의 숫자를 새로운 배열에 만들어 담아 반환하면 되는 문제이다.</p>

<p>문제 풀이를 위해서 그림으로 설명해보자</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223741523-81c10d79-a5fc-4441-8d50-4c73fc79c709.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우선 반환되는 배열을 <code class="language-plaintext highlighter-rouge">int[] answer</code>선언해주었다. 반환하는 배열의 길이는<br />
<code class="language-plaintext highlighter-rouge">int[][] commands</code> 2차원 배열의 길이만큼 만들어주면된다. <br />
즉 3개의 배열이 존재하기 때문에 3칸으로 만들어준다.</p>

<p>이제 2차원 배열을 순회하면서 배열의 길이를 추출하면된다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223741531-7953e433-aa93-4d68-a6fe-9f48221acdd9.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>첫번째 배열 <code class="language-plaintext highlighter-rouge">i = 2</code>, <code class="language-plaintext highlighter-rouge">j = 5</code>, <code class="language-plaintext highlighter-rouge">k = 3</code>으로 <code class="language-plaintext highlighter-rouge">int[] array</code>배열에서 <br />
2번째 부터 5번째까지 추출하면 <code class="language-plaintext highlighter-rouge">[5,2,6,3]</code>과 같이 추출할 수 있다.<br />
추출된 배열중 낮은값부터 <code class="language-plaintext highlighter-rouge">k</code>번째인 3번째를 추출하기 위해서는 <code class="language-plaintext highlighter-rouge">.sort</code>로 내림차순으로 <br />
배열을 정령한다음 3번째 값을 <code class="language-plaintext highlighter-rouge">int[] asnwer</code> 배열 첫번째에 넣는다.</p>

<p><br /></p>

<p>이후 과정은 동일하다.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223741537-733833a0-a3cd-4586-af89-63f7e5350507.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>2번째 배열 순회를하고 같은 과정을 거치는데 한가지 다른점이 있자면 <br />
배열의 길이가 1개일 때는 <code class="language-plaintext highlighter-rouge">.sort</code>를 진행할 필요가 없기 때문에 생략하게 하였다.</p>

<p><br /></p>

<p>이렇게 마지막까지 순회를 하면</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223741543-42080ea7-b831-4e43-acf5-494b809633cc.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>최종적으로 <code class="language-plaintext highlighter-rouge">int[] answer</code>에 문제요구사항에 맞는 값이 들어가고 <br />
반환해주게된다면, 문제 풀이는 끝난다.</p>

<p><br /></p>

<h3 id="-코드">👨🏻‍💻 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">commands</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 반환할 배열을 만든다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">commands</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="c1">// commands 배열 길이만큼 순회를 한다.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">commands</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">cutArray</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOfRange</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">commands</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]-</span><span class="mi">1</span><span class="o">,</span> <span class="n">commands</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cutArray</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;=</span><span class="mi">2</span><span class="o">)</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">cutArray</span><span class="o">);</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">cutArray</span><span class="o">[</span><span class="n">commands</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>해당 코드에서는 <code class="language-plaintext highlighter-rouge">Arrays.copfOfRange();</code> 메서드의 사용법만 알면 <br />
크게 어렵지 않은 코드이다. 위에 문제 풀이에서는 인덱스값이아닌 1번부터 진행하여 <br />
해당 부분만 신경써서 배열에 맞는 값을 추출하면 끝!</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="Algorithm" /><category term="Algorithm" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : K 번째수]]></summary></entry><entry><title type="html">함수형 프로그래밍이란? - Java</title><link href="http://localhost:4000/cs/2023/03/07/it-etc-paradigm.html" rel="alternate" type="text/html" title="함수형 프로그래밍이란? - Java" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><id>http://localhost:4000/cs/2023/03/07/it-etc-paradigm</id><content type="html" xml:base="http://localhost:4000/cs/2023/03/07/it-etc-paradigm.html"><![CDATA[<h3 id="프로그래밍-패러다임">프로그래밍 패러다임</h3>

<p>프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론이다.<br />
어떤 언어는 특정한 패러다임을 지원한다. (ex: 자바=객체지향, 하스켈=함수형) <br />
여러 패러다임을 지원하는 언어도 존재한다. (ex: 파이썬, C++, 자바스크립트)<br />
자바는 jdk 1.8부터 함수형 프로그래밍 패러다임을 지원하기 위해 람다식, 생성자 레퍼런스<br />
메서드 레퍼런스를 도입했고, 선언형 프로그래밍을 위해 스트림 같은 표준 API들도 추가하였다.</p>

<p>프로그래밍 패러다임은 크게 아래와 같이 나뉜다.</p>

<p>선언형 -&gt; 함수형<br />
명령형 -&gt; 객체지향형, 절차지향형</p>

<p><br /></p>

<h3 id="함수형-프로그래밍">함수형 프로그래밍</h3>

<h4 id="함수형-프로그래밍의-특징">함수형 프로그래밍의 특징</h4>

<p>무엇을 풀어내는가에 집중하는 패러다임이다.<br />
프로그램은 함수로 이루어진 것이다라는 명제가 담겨있는 패러다임이기도 하다.</p>

<p>객체지향 프로그래밍이 객체간 메세지와 협력 관계의 정의로 이루어져있다면, 함수형 프로그래밍은<br />
단순히 함수들의 조합으로 이루어 진다. 함수들의 조합이라는 말은 쉽지만 실제로 함수형 코딩을<br />
잘 하는데 꽤 높은 러닝커브를 요구한다. 객체지향의 4대원칙, SOILD와 같이 함수형 프로그래밍에도<br />
몇 가지 특징들이 있다. 아래에서 알아보자.</p>

<p><img src="https://user-images.githubusercontent.com/95069395/223608704-9f5ca7e8-bbbb-4774-b25c-5e8dc858f488.png" alt="image" class="align-left" style="max-width: 70%" /><br />
<a href="https://warpgate3.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%B3%B4%EB%8A%94-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Functional-Programming-in-Java">그림출처 - https://warpgate3.tistory.com</a></p>

<p><br /></p>

<p><strong>1). Immutable Data (불변하는 데이터)</strong><br />
데이터가 함수 밖에서 변형하지 않는 원칙이다. 다만, 함수의 반환 값은 함수 내에서 수행된 작업을 반영해야한다.</p>

<p><strong>2). Pure Functions (순수함수)</strong><br />
함수형 프로그래밍의 이상은 순수함수라고 알려져 있다. <span style="color:#F04965"><strong>입력 파라미터에만 의존하며 부수 효과(side effect)를 일으키지 않는 함수</strong></span>를 뜻한다. 순수함수를 통해 불변하는 데이터의 특징을 가질 수 있다. 이러한 차이가 객체지향 프로그래밍과 다른 점이다. 객체의 메서드가 객체의 상태와 상호작용을 하며, 외부 상태가 함수 내에서 조작되고는 한다.</p>

<p>순수함수의 예제를 살펴보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pure</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">greeting</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">greeting()</code>이라는 메서드가 호출되었을 때, 매개변수의 따라 리턴되어 지는 값이 달라진다.<br />
호출할 때 매개변수가 동일하면 아무리 호출해도 동일한 값이 반환되고 함수의 값이 밖에서 변형되거나 <br />
하는일은 발생하지 않는 코드이다. 즉 데이터가 불변하는 특징을 가지고 있다.</p>

<p><br /></p>

<p>그럼 순수함수의 반대 예제를 살펴보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonPure</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"이재혁"</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">greeting</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello "</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>필드 변수에 “이재혁”이라는 <code class="language-plaintext highlighter-rouge">name</code>값이 String 형태로 지정되어 있다. <br />
여기서 중요한점은 name이라는 값을 조작하게 된다면 함수의 호출시 반환값이 변경되어진다.<br />
즉, 전역변수의 값이 조작 되면 부수효과(side effect)가 발생된다.</p>

<p><br /></p>

<p><strong>3). No foreach (반복문 사용 X)</strong><br />
for, while문과 같은 반복문을 사용하지 않는다. 반복문 안에는 가변적인 값들과 처리에 대한 코드가 섞여 있다. 함수형 프로그래밍에서는 반복문 대신에 map,filter 같은 함수를 매개변수로 받는 메서드를 이용한다.</p>

<p>예제로 살펴보자, 우선 일반적인 for문의 사용 경우다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Noiterate</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"홍씨"</span><span class="o">,</span> <span class="s">"김씨"</span><span class="o">,</span> <span class="s">"이씨"</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">names</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위와 같이 for문을 사용해 리스트의 이름을 출력하였다.</p>

<p><br /></p>

<p>함수형 프로그래밍 예제를 살펴보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Noiterate</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"홍씨"</span><span class="o">,</span> <span class="s">"김씨"</span><span class="o">,</span> <span class="s">"이씨"</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">names</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">name</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Iterable&lt;T&gt;</code> 인터페이스를 상속하고 있는 List에서<br />
<code class="language-plaintext highlighter-rouge">forEach(Consumer&lt;? super T&gt; action)</code>를 호출하여<br />
<code class="language-plaintext highlighter-rouge">Consumer&lt;T&gt;</code> 함수형 인터페이스를 이용해 반복문을 이용한 예제이다.</p>

<p><br /></p>

<p><strong>4). High Order Function (고차함수)</strong> <br />
함수를 인자로 받거나 함수를 반환 값으로 이용할 수 있는 것을 말한다.<br />
클로저라는 개념도 나오는데 클로저는 부모 함수가 실행되었더라도 부모 함수의 <br />
변수에 접근할 수 있는 내부 함수(inner function)을 뜻한다.</p>

<p>고차함수와 특징을 포함한 자바 예제코드를 살펴보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HigherOrderFunctionExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 함수형 인터페이스 Function을 사용하여 고차 함수를 구현합니다.</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">add</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">;</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">subtract</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">;</span>

        <span class="c1">// 함수를 호출하여 결과를 출력합니다.</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">add</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>       <span class="c1">// 5</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">subtract</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">5</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>  <span class="c1">// 3</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위에코드는 고차함수의 함수를 반환값으로 이용할 수 있는 예제이다.<br />
<code class="language-plaintext highlighter-rouge">add.applay(2);</code>를 호출하게 될 경우 <code class="language-plaintext highlighter-rouge">Function&lt;Integer, Integer&gt;</code>타입의 메서드로 반환하게된다.<br />
반환된 함수를 다시 <code class="language-plaintext highlighter-rouge">.add(3);</code>하였을 경우 <code class="language-plaintext highlighter-rouge">y -&gt; x + y</code>를 계산한 Integer타입으로 반환하게되어 <br />
이전에 호출했을때 매개변수로 전달된 2값과 더해져 5라는 값이 출력되게 되어진다.</p>

<p>즉, <code class="language-plaintext highlighter-rouge">Function&lt;Integer, Integer&gt;</code>는 정수값을 받아 반환하는 함수이고,<br />
해당함수를 반환값으로 이용하고 있어, 고차함수라고 할 수 있다.</p>

<p><br /></p>

<p>❗️<strong>일급객체란?</strong>  <br />
고차 함수를 쓰기 위해서는 해당 언어가 일급객체라는 특징을 가져야한다.</p>

<p>일급객체의 충족 조건 3가지</p>
<ol>
  <li>모든 일급 객체는 변수나 데이터에 담을 수 있어야 한다.</li>
  <li>모든 일급 객체는 함수의 파라미터로 전달 흘 수 있어야 한다.</li>
  <li>모든 일급 객체는 함수의 리턴값으로 사용 할 수 있어야 한다.</li>
</ol>

<p>자바의 람다 표현식을 배우다보면 ‘일급객체’라는 단어를 접하게 된다. <br />
뜻은 사용할 때 다른 요소들과 아무런 차별이 없다는걸 뜻한다. <br />
일급 객체는 어떠한 특정 언어에 국한되는 문법 단어가 아니다. 프로그래밍 언어론의 개념이다.</p>

<p>Java에서의 일급객체 를 알아보자.<br />
첫번째, 객체는 변수나 데이터에 담을 수 있어야한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">a</span> <span class="o">=</span> <span class="n">hello</span><span class="o">;</span> <span class="c1">// 메서드를 변수에 할당 불가능</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>위의 예제를 보면 메서드는 변수에 할당하거나 그럴수가 없다.</p>

<p><br /></p>

<p>두번쨰, 객체는 함수의 파라미터로 전달 할 수 있어야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Object</span> <span class="n">func</span><span class="o">)</span> <span class="o">{</span>
    	<span class="n">func</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">((</span><span class="nc">Object</span><span class="o">)</span> <span class="n">hello</span><span class="o">);</span> <span class="c1">// static 메서드를 함수 매개변수로 전달 불가능</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>자바는 메서드를 다른메서드의 매개변수로 전달이 불가능하다.</p>

<p><br /></p>

<p>세번째 객체는 함수의 리턴값으로 사용 할 수 있어야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OneObject</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">hello</span> <span class="nf">print</span><span class="o">((</span><span class="nc">Object</span><span class="o">)</span> <span class="n">func</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">func</span><span class="o">;</span> <span class="c1">// 리턴값을 메서드 자체를 반환이 불가능</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hello</span> <span class="n">result</span> <span class="o">=</span> <span class="n">print</span><span class="o">((</span><span class="nc">Object</span><span class="o">)</span> <span class="n">hello</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>역시 자바는 메서드 자체를 리턴값을 메서드 자체를 반환하는 행위가 불가능하다.</p>

<p>이러한 관점에서 자바의 메서드는 함수인데 일급 객체라고 부르지 않고, 자바스트립트의 함수는<br />
일급 객체라 부르는지 차이를 볼 수 있다.</p>

<p>자바에서는 람다식, 익명 클래스에서 변수나 매개변수에 할당 할 수 있고, <br />
리턴값으로도 사용할 수 있기때문에 일급 객체의 요건을 충족한다.</p>

<p><br /></p>

<h4 id="함수형-프로그래밍의-장점과-한계">함수형 프로그래밍의 장점과 한계</h4>

<p>✅ <strong>장점</strong></p>
<ol>
  <li>헷갈리는 문제와 오류를 피할 수 있다.</li>
  <li>테스트와 디버깅에 용이하다.</li>
  <li>더 나은 모듈화와 짧은 코드를 제공한다.</li>
  <li>개발 생산성이 높일 수 있다.</li>
  <li>가독성이 높은 코드를 작성하기 쉽다.</li>
  <li>부수효과를 제거할 수 있다.</li>
  <li>함수 단위의 코드 재사용이 쉽다.</li>
  <li>프로그램의 동작을 예측하기 쉽다.</li>
</ol>

<p>✅ <strong>한계점</strong></p>
<ol>
  <li>개념을 이해하기 쉽지 않다.</li>
  <li>프로그래밍을 진행하며 수 많은 함수들을 파악하고 유지 관리하기 힘들어진다.</li>
  <li>광범위한 환경 설징이 필요할 수 이싿.</li>
  <li>함수가 많아질수록 함수를 조합하기 복잡해지면 꾸준한 리펙토링이 필요할 수 있다.</li>
</ol>

<p><br />
<br /></p>

<p>✨참고 블로그<br />
<a href="https://warpgate3.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%B3%B4%EB%8A%94-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-Functional-Programming-in-Java">https://warpgate3.tistory.com</a>, <a href="https://code-lab1.tistory.com/245">https://code-lab1.tistory.com</a>, <a href="https://inpa.tistory.com/entry/CS-%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4first-class-object">https://inpa.tistory.com</a></p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="CS" /><category term="ComputerScience" /><summary type="html"><![CDATA[프로그래밍 패러다임]]></summary></entry><entry><title type="html">[Programmers] 주식가격 (Java)</title><link href="http://localhost:4000/algorithm/2023/02/22/algo-stockprice.html" rel="alternate" type="text/html" title="[Programmers] 주식가격 (Java)" /><published>2023-02-22T00:00:00+09:00</published><updated>2023-02-22T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2023/02/22/algo-stockprice</id><content type="html" xml:base="http://localhost:4000/algorithm/2023/02/22/algo-stockprice.html"><![CDATA[<h2 id="-문제--주식가격">📌 문제 : <a href="https://school.programmers.co.kr/learn/courses/30/lessons/42584">주식가격</a></h2>

<h3 id="-문제-설명">📖 문제 설명</h3>

<p>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.</p>

<h4 id="제한사항">제한사항</h4>

<ul>
<li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li>
<li>prices의 길이는 2 이상 100,000 이하입니다.</li>
</ul>

<h4 id="입출력-예">입출력 예</h4>
<table class="table">
        <thead><tr>
<th>prices</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[1, 2, 3, 2, 3]</td>
<td>[4, 3, 1, 1, 0]</td>
</tr>
</tbody>
      </table>

<h4 id="입출력-예-설명">입출력 예 설명</h4>

<ul>
<li>1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.</li>
<li>4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.</li>
<li>5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.</li>
</ul>

<p>※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.</p>

<hr />

<h2 id="-문제-풀이">🗝 문제 풀이</h2>

<h3 id="️-풀이-방법">☀️ 풀이 방법</h3>

<p>해당 문제를 이중 for문을 이용해 풀면 간단하다. <br />
순환하는 값과 다음값을 비교해 작은 값이 있으면 <br />
위치를 계산해서 리턴해주면 간단하게 풀리는 문제이다.</p>

<p>이중 반복문을 사용하게 될 경우 O(n²)의 시간 복잡도를 가지며 <br />
prices 배열의 길이가 늘어날수록 시간 복잡도가 배로 증가하기때문에 좋지 않다.</p>

<p>해당 문제에서 요구하는 <code class="language-plaintext highlighter-rouge">Stack</code> 자료구조를 이용해 풀어보자.</p>

<p><br /></p>

<p>우선 문제를 이해하기위해서 아래의 그림을 살펴보자</p>

<p><img src="https://user-images.githubusercontent.com/95069395/220566032-10c63ebf-fc8b-48ce-bab4-3830706e8c81.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>prices라는 가격이 담긴 배열을 주어준다음에 해당 가격이 언제 떨어지는지 체크하는 문제이다.  <br />
떨어지지 않을 경우에는 배열 끝까지 시간초를 더한값을 담아줘야한다. <br />
해당 예제에서는 3번째 그림인 3에서 2로 넘어갈때 가격이 떨어지므로 1이란 값이 반환된 것이다.</p>

<p><br /></p>

<p>이제 문제를 이해했으니, Stack을 이용해 문제를 풀어보자</p>

<p><img src="https://user-images.githubusercontent.com/95069395/220570853-d38f6244-e89d-48a3-8678-e81489c86221.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>answer라는 배열을 만들어 리턴할 것인데, 어떻게 만들어줘야할지 정해보자</p>

<ol>
  <li><strong>주식가격이 떨어지지 않는 가격들</strong> -&gt; <code class="language-plaintext highlighter-rouge">[배열길이 - 1 - 인덱스번호]</code></li>
  <li><strong>주식가격이 떨어진 가격들</strong> -&gt; <code class="language-plaintext highlighter-rouge">[떨어진 가격의 인덱스번호 - 높은가격의 인덱스번호]</code></li>
</ol>

<p>이렇게 정의할 수 있을 것 같다. 여기서 <span style="color:#F04965"><strong>중요한건 주식가격이 떨어지지</strong> </span><br />
<span style="color:#F04965"><strong>않는 가격들만 Stack 안에 저장할 예정이다.</strong></span><br />
즉, 떨어진 가격은 Stack에서 제외시킬 것이다.</p>

<p>여기서 1번을 보충 설명하보자면 현재 <code class="language-plaintext highlighter-rouge">int[] prices</code>의 배열의 길이는 <code class="language-plaintext highlighter-rouge">5</code>이다.<br />
만약 주식가격이 떨어지지 않았다면 배열의 끝까지 초를 더할 것이다.<br />
그렇다는건 (배열의 길이 - 1)에서 본인의 인덱스번호만 뺴주게된다면 <br />
몇초가 걸리는지 계산을 할 수 있다.</p>

<p><br /></p>

<p>처음부터 시작해보자</p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564078-60d4352f-fed8-4dd6-ab48-f6853d835f73.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Stack에는 떨어지지않는 가격의<br />
인덱스 번호를 차례대로 쌓아올릴 예정이다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564084-969fd14d-7cd6-4d42-9241-cf4c507375e8.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>첫번쨰로 전에 있는 값들을 while문을 돌려 비교할 것이다.<br />
현재는 아무런 값이 없기때문에 다음 가격으로 넘어갈 것이다.</p>

<p>넘어가기전에  가격이 <code class="language-plaintext highlighter-rouge">1</code>인 인덱스 번호인 <code class="language-plaintext highlighter-rouge">0</code>값을 Stack에 저장한다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564090-9b076766-0a72-4a44-81ef-fb7375b2402f.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>두번째 사이클이다. 첫번째와 동일하게 <br />
숫자 <code class="language-plaintext highlighter-rouge">2</code>값의 전에 값중 높은값이 있는지 찾아낸다.<br />
만약 없을 경우 또 다음 가격으로 넘어간다.</p>

<p>물론 똑같이 인덱스 번호를 Stack에 저장한다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564093-4dcbc4a3-8d79-47c1-bc91-cc994f7dcadb.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>세번째 사이클도 두번째 사이클과 동일하다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220570858-bb8b794c-f4a6-49ec-a79d-c8da3d78ec61.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>네번째 사이클에서는 숫자 <code class="language-plaintext highlighter-rouge">2</code>인 값보다 높은 값(<code class="language-plaintext highlighter-rouge">3</code>)이 존재한다. <br />
높은 값이 존재하므로 Stack에서는 높은 가격의 인덱스 번호를 <code class="language-plaintext highlighter-rouge">pop();</code>으로 제거한다.  <br />
(앞에 있는 0,1인덱스의 값도 비교해서 높은가격이 있다면 제거한다.)</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">int[] answer</code> 배열에는 가격이 몇초안에 떨어졌는지 담아줘야한다. <br />
처음에 얘기했던 공식을 적용하면 된다. 여기서는</p>

<p>떨어진 가격 : <code class="language-plaintext highlighter-rouge">2</code> -&gt; 인덱스 번호 : <code class="language-plaintext highlighter-rouge">3</code><br />
높은가격 : <code class="language-plaintext highlighter-rouge">3</code> -&gt; 인덱스 번호 : <code class="language-plaintext highlighter-rouge">2</code> <br />
와 같이 볼 수 있고 <code class="language-plaintext highlighter-rouge">떨어진 가격 - 본인 인덱스번호(높은가격)</code>의 차이인 <code class="language-plaintext highlighter-rouge">1</code>초를 <br />
반환하는 배열에 담아줄 수 있다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564100-5f78c105-1835-4357-a63e-bcdbf05a1f3f.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 다음 사이클에서 비교할 수 있게, Stack에 <br />
낮은 가격이였던 2의 인덱스값 <code class="language-plaintext highlighter-rouge">3</code>을 저장해준다.</p>

<p>위에서도 얘기했듯이 가격의 떨어진 인덱스들만 Stack에서 제외시키는 작업이다.<br />
즉, 낮은 가격인 2의 값도 다음 사이클에서 비교할 수 있게 저장해줘야한다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564102-3b24ed7d-41be-4742-8f11-140ea961385b.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이후부터는 전의 사이클들과 동일하게 진행되고 <br />
마지막 사이클이기 때문에 Stack에 떨어지지 않은 가격의 <br />
인덱스 번호들만 남은 상태이며, <code class="language-plaintext highlighter-rouge">int[] answer</code> 배열에는 떨어진 가격의 <br />
시간이 담겨 있기 때문에 이제 남은 작업은 떨어지지 않은 가격을 배열에 담아주면된다.</p>

<p><br /></p>

<p><img src="https://user-images.githubusercontent.com/95069395/220564105-7cb76078-2c4d-40b8-b7dc-1525755d179c.png" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>담아주는 과정은 맨위에서 설명했던 내용과 동일하다.  <br />
떨어지지 않은 가격들은 배열을 끝까지 순회하기 때문에 <br />
<code class="language-plaintext highlighter-rouge">[배열길이 - 1 - 인덱스번호]</code>를 한값을 <code class="language-plaintext highlighter-rouge">int[] answer</code>배열에 담아주면된다. <br />
<code class="language-plaintext highlighter-rouge">Stack</code> 자료구조 특성상 마지막의 값부터 <code class="language-plaintext highlighter-rouge">peek()</code>,<code class="language-plaintext highlighter-rouge">pop()</code>해올 수 있기 때문에  <br />
배열의 마지막부터 값을 계산해서 반환해주면 문제 풀이는 끝난다.</p>

<p><br /></p>

<h3 id="-코드">👨🏻‍💻 코드</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">];</span> <span class="c1">// 반환할 배열</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 값이 떨어지는 주식의 시간을 저장</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()])</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span> <span class="c1">// 반환배열에 떨어지는 시간 초 저장</span>
                <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span> <span class="c1">// 값이 떨어진 초는 제거</span>
            <span class="o">}</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="c1">// 값이 떨어지지않은 주식의 시간초를 저장</span>
        <span class="o">}</span>

        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 값이 떨어지지않은 주식들, 마지막 인덱스부터 차례대로 빼오기</span>
            <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">last</span><span class="o">]</span> <span class="o">=</span> <span class="n">prices</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>여기서 유의 깊게 봐야할 부분은 <code class="language-plaintext highlighter-rouge">stack.push(i);</code><br />
순회가 끝나면 Stack에 인덱스값을 저장해주는 부분이다.</p>

<p>그리고 while문의 조건을 통해서 현재 순회하는 인덱스의 값보다 <br />
전에 Stack에 쌓여있는 인덱스 번호의 값중 큰값이 존재한다면 <br />
<code class="language-plaintext highlighter-rouge">answer[stack.peek()] = i - stack.peek();</code>를 하여 초값을 계산하고 <br />
<code class="language-plaintext highlighter-rouge">stack.pop();</code>하여 Stack에서 제거시켜주게된다. 위에 그림에서 설명했던 부분과 동일하다.</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="Algorithm" /><category term="Algorithm" /><category term="Programmers" /><summary type="html"><![CDATA[📌 문제 : 주식가격]]></summary></entry></feed>