<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-19T10:44:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LeeJellan</title><subtitle>안녕하세요!🙂 IT,여행,기타 등 기록을 남기기위한 블로그 입니다 !</subtitle><author><name>LEE JAEHYEOK</name></author><entry><title type="html">H2 Database 다운로드 및 실행</title><link href="http://localhost:4000/db/2022/12/19/h2setting.html" rel="alternate" type="text/html" title="H2 Database 다운로드 및 실행" /><published>2022-12-19T00:00:00+09:00</published><updated>2022-12-19T00:00:00+09:00</updated><id>http://localhost:4000/db/2022/12/19/h2setting</id><content type="html" xml:base="http://localhost:4000/db/2022/12/19/h2setting.html"><![CDATA[<p><a href="http://www.h2database.com/html/main.html">h2 database 홈페이지</a>에 접속하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPOrBmDtNszJ_Se_BYJ0vhdj-G60PCOB3B50Ji348fVE1atvLYUpkqGJ0N3UIoVdUdQJi6ntxmw2_tX-ptIe5Vzm4kz-Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같은 화면이 나오는데<br />
나는 MacOS를 쓰고있어 All Platforms를 눌러주면된다.<br />
그럼 zip파일 하나가 다운받아진다. <br />
여기서 버젼확인을 꼭해주자. 의존라이브러리를 추가할때 해당버젼과 일치해야한다.</p>

<p><strong>Gradle의 경우</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">h2database</span><span class="o">:</span><span class="nl">h2:</span><span class="mf">2.1</span><span class="o">.</span><span class="mi">214</span><span class="err">'</span>
</code></pre></div></div>
<p>와 같이 설정해 줄 수있다. 일반적으로 버전을 제외하고</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">h2database</span><span class="o">:</span><span class="n">h2</span>
</code></pre></div></div>
<p>로 설정하면 자동으로 가장 최신의 버전이 추가되는 것 같다.</p>

<p><br /></p>

<p><strong>Maven의 경우</strong></p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;dependencies&gt;</span>
        <span class="c">&lt;!-- H2 데이터베이스 --&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>com.h2database<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>h2<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>2.1.214<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div></div>
<p>와 같은식으로 설정해줄 수 있다.</p>

<p>해당 zip파일을 풀면 폴더하나가 나오게되는데<br />
그안에서 bin -&gt; h2.sh 스크립트를 실행 시켜주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNFlqigR274WJL2PPsEN4JlD7veQFTYLJYTVb8j7I5GyT6XrqeEGzG4Mb0D9CUpT_kRJ1fmVmzGr155UxFE0eUMn4L9WQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>해당 파일 위치에서</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./h2.sh
</code></pre></div></div>
<p>를 실행 시켜주면 h2 data base 팝업이 발생하고  <br />
<img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gODtoeY1H6bGiUOZQj8oP90Qh8CXysYw8Yu6BZ8MowLG0_yUB2ClmKn464zQMWxzYpitSiaI6ktPMoRVMZ1dDX72Npngg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /> 아이콘이 상단에 떠있을 것이다.</p>

<p>만약 종료시키고 싶으면 <code class="language-plaintext highlighter-rouge">Ctrl + C</code>를 눌러주면된다.</p>

<p>만약 스크립트가 권한에 의해 실행되지 않는다면 chmod 명령어로 권한을 <br />
부여해주면 쉽게 해결할 수 있다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ll
</code></pre></div></div>
<p>권한 확인 진행을 먼저해주고</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod </span>755 h2.sh
</code></pre></div></div>
<p>를 해주게되면 정상적으로 진입할 수 있을 것이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMidCvQtnMFbQLRjWIfa1fgZLuIwDoOjR6himZX4bWnbhTxm4nKQEIfD20j3PcwRSuHB4kUfP1o8IMDOdHUObIgPKYHTA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>접속 URL 같은 정보들의 경우는<br />
gradle과 maven에 따라다르지만 resources에 정보를 설정해주면된다.<br />
혹시나 만약 해당 화면이 발생하지 않고 하얀화면만 나오면서<br />
진입이 안되는 분이 있으시다면<br />
포트번호 <code class="language-plaintext highlighter-rouge">:8082</code>앞에 localhost를 붙여보면 접속이 가능할 것이다.</p>

<p>gradle 같은 경우에는</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.datasource.url</span><span class="p">=</span><span class="s">jdbc:h2:tcp://localhost/~/test</span>
<span class="py">spring.datasource.username</span><span class="p">=</span><span class="s">sa</span>
<span class="py">spring.datasource.password</span><span class="p">=</span>
</code></pre></div></div>
<p>application.properties 설정을 통해<br />
접속 관련 정보를 설정해주면 된다.</p>

<p><br /></p>

<p>Maven 같은 경우에도 마찬가지다</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;persistence</span> <span class="na">version=</span><span class="s">"2.2"</span>
             <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/persistence"</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
             <span class="na">xsi:schemaLocation=</span><span class="s">"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;persistence-unit</span> <span class="na">name=</span><span class="s">"hello"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;properties&gt;</span>
            <span class="c">&lt;!-- 필수 속성 --&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.driver"</span> <span class="na">value=</span><span class="s">"org.h2.Driver"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.user"</span> <span class="na">value=</span><span class="s">"sa"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.password"</span> <span class="na">value=</span><span class="s">""</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.url"</span> <span class="na">value=</span><span class="s">"jdbc:h2:tcp://localhost/~/test"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.dialect"</span> <span class="na">value=</span><span class="s">"org.hibernate.dialect.H2Dialect"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/properties&gt;</span>
    <span class="nt">&lt;/persistence-unit&gt;</span>
<span class="nt">&lt;/persistence&gt;</span>
</code></pre></div></div>
<p>과 같은 방식으로 <code class="language-plaintext highlighter-rouge">persistence.xml</code> 설정을 통해<br />
정보를 입력해줄 수 있다.</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="DB" /><category term="DB" /><category term="H2" /><summary type="html"><![CDATA[h2 database 홈페이지에 접속하면]]></summary></entry><entry><title type="html">TIL) PreProject 진행, 팀장일지 (22.12.15 ~ 23.01.02)</title><link href="http://localhost:4000/til/2022/12/15/til.html" rel="alternate" type="text/html" title="TIL) PreProject 진행, 팀장일지 (22.12.15 ~ 23.01.02)" /><published>2022-12-15T00:00:00+09:00</published><updated>2022-12-15T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/15/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/15/til.html"><![CDATA[<p>모든 교육이 끝나고 프리 프로젝트를 시작했다.<br />
프로젝트에 대한 기대가 너무 컸고, 얼른 내가 알고있는 기술들을<br />
사용해보면서 구현을 해보고 싶었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM7IwaAHpSs2lWQYI6BcrMZcXkn_DBo79TmhoStn5-uQdph_KvSSgobXbkXQnqLaqKHyV1uR_VTXtXj6doGp_jWLEEmGQ=w1920-h921" alt="image" class="align-left" style="max-width: 50%" /></p>

<p>그런 마음에서 그런지 이번 프리프로젝트에서는 무조건 <strong>팀장</strong>을 해야겠다고 <br />
생각했었고, 프론트엔드 쪽에서 진행되는 상황이나 팀적으로 <br />
어떻게 프로세스를 진행해야 원할할지에 대한 고민을 많이해보고 싶었다.</p>

<p>프리프로젝트가 끝나고는 메인프로젝트에서는 기능개발의<br />
중점을 두어 팀원으로 새로 모르는 기술에 대한 탐구와 적용에 대한<br />
고민을 주로 해볼 것 같다.</p>

<hr />

<p>다행히 팀원들에 동의를 받아<br />
이번 프로젝트는 내가 팀장으로 진행하게 되었다.<br />
부담감은 물론있다. 하지만 그만큼 열심히해서 잘할 자신도 있다.</p>

<p>그때그때 감정과 팀장으로서의 역할을 제대로 수행하고있는지?<br />
프로젝트 진행상황과 여러가지를 적어가보려고한다.</p>

<p><br /></p>

<h3 id="20221215-목">2022.12.15 (목)</h3>

<h4 id="팀-빌딩과-시작">팀 빌딩과 시작</h4>

<p>팀 빌딩이 시작되는 날이었다.<br />
기술적인 능력은 부족하지만, 어필을 통해 팀장을 해보려한다.<br />
(그렇다고 프로세스를 아예 모르는것도 아니라고 생각한다 ㅎ;)</p>

<p>Frontend 3명, Backend 3명<br />
이렇게 인원 배정을 받았고 모두 처음만나 너무나도 어색한상황..</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOQudLSy7P_TZzLCcIJmbtfqdFJ6woTP9ODYtA-5bifd3cOr8WgKWJkC94ezFJNbP1UdVMDUYwZuex5wBbRhPNdntVgug=w1920-h864" alt="image" class="align-left" style="max-width: 40%" /></p>

<p>이런 어색함을 참지 못하 나는 자체적으로 사회자가 되어버렸다 ㅋㅋ<br />
사회자가 된김에 팀장을 정하는 시간에 하고싶다는 의사를 표했고<br />
우리 팀원분들은 대부분이 내향적인 분들이 많아, 자연스럽게 하고싶었던 내가 팀장이되었다.</p>

<p>지난 회사생활 7년간 가장 중요했던 의사소통 관련해서<br />
외향적인 내가 내향적인분들과 소통하는건 항상 쉽지는 않았다.<br />
이해를 해주고 기다려줘야하는 부분도 많았고, 원하는 의견의 표출에 소극적이었던 것을 <br />
많이 경험했어서, 여러 충돌이 있었던 경험도 있다.</p>

<p>이러한 부분을 잘 조율해서 팀원의 성격을 먼저 천천히 파악해보고<br />
그에 맞는 소통방식을 찾아 프로젝트를 진행해보려한다.</p>

<p><br /></p>

<h4 id="협업에-대한-셋팅">협업에 대한 셋팅</h4>

<p>처음 만나고 진행할 일은 어느 플랫폼을 이용해서 소통할지 였다.<br />
<code class="language-plaintext highlighter-rouge">Slack</code>,<code class="language-plaintext highlighter-rouge">ZEP</code>,<code class="language-plaintext highlighter-rouge">Discord</code>,<code class="language-plaintext highlighter-rouge">Google Meet</code>,<code class="language-plaintext highlighter-rouge">Zoom</code>등 여러가지 얘기가 나왔는데<br />
우선은 프로젝트에 대한 집중이 중요다는 팀원들의 만장일치로 Discord를 사용하기로 했다.</p>

<p>그리고 기본적으로 notion을 이용해 팀 프로젝트에 대한 정리를 하기로 했다.<br />
예를들어 컨벤션에 대한 정리라든가, 일정에 대한 정보, 회의록 등.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMPekYO6zZLz9f4INnHGhUgXXdwGoNnAb-1nfr1EM0mZ60FBvs1g9weSpzPjXBvPpMC-eGt4vHBVxOZ1Sfz3wayxhQI=w1920-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPBqfazQbtLum7WVBESroZ2q5rm7QI6Racu11IOWAE_R5gWYKhl5AR2JLibpvfPJhxsqjGCUwxd-mOOz8uk63OlYdE3TA=w1920-h864" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같은식으로 하나씩 정리해갈 예정이다.</p>

<p>팀명은 37℃ 라는 이름으로 정했다. 
큰 의미는 없었다 배정받은 조가 37조였고<br />
사람의 정상체온인 37도만큼만 하자라는 의미를 담았다.</p>

<p><br /></p>

<p>그리고 디스코드 방을 개설했다.<br />
전체적인 소통과 공지, 회의는 디스코드로 진행할 예정이고<br />
해당 내용들을 notion에 정리하는 느낌으로하려한다.</p>

<p>차가운 분위기를 바꾸기 위해서 디스코드 팀방 아이콘을 바꾸면 그래도<br />
기분이 살아날 것 같아서 간단한 그림을 그려 팀방 아이콘을 꾸몄다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPGDw8Eo9qmjsoawvmOXI5p3vfhSDZkTAq_76poy7sygTwXAfzk-0oquEnfJcO32XLjhZEpgG7epGZIHUSJM1vgc0rgGw=w1920-h864" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>정말 아무런 의미도없지만 디스코드 입장할때 한번씩 보면 그래도<br />
상징적인 것을 두면 단합이 더이루어지지 않을까?라는 소망이였다.</p>

<p>그리고 Discord 기능 중 웹후크라는 기능이 있다. <br />
GitHub와 연동해서 우리가 프로젝트로 사용하는 Repository의<br />
Push가 이루어질 때마다 Discord에 알림을 주는 봇을 만들었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOJcqlxn5j6wdoGyu8V-IiJHZNtJ3wfGm82UpaXns7Jr6KRZM_hws75-M-RfLeGfGzmZTG-OXadGhSEBxrI3dy_yYIqxA=w1920-h921" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>혹시나 누군가 실수로 Push를 계속한다든가, 아직 초보자인 우리들이<br />
어떻게 작업을 할지 모르기 때문에 최소한 알림이라도 오도록 추가해두었다.</p>

<p>이렇게 첫날은 지나갔고<br />
내일 부터는 모두 Github 협업에 대한 개인적인 공부시간을 가지는 날이다.<br />
정확히 일정은 다음주 월요일 오후부터 시작될 것 같다.</p>

<p><br /></p>

<h3 id="20221216-금">2022.12.16 (금)</h3>

<h4 id="github-관련-협업-지식습득">GitHub 관련 협업 지식습득</h4>

<p>오늘은 코드스테이츠측에서 제공하는 GitHub 협업 프로세스에 대한 공부를 하는 날이다.<br />
나는 코스과정중 스터디원들이랑 친해져 같이 미리 협업 연습을 여러번 했었다. <br />
그래서 어느정도 익숙했고 지금 팀원들이랑 합을 맞춰보는게 중요하다고 생각했다.</p>

<p>Project 칸반과 issue를 잘 이용하는 것을 목적으로 둘 것이고<br />
브랜치 전략을 정해 어떻게 진행할지 의견을 맞춰보는게 핵심이다.<br />
다음주 월요일에 어떤 브랜치 전략으로 해볼지 얘기해보고 최종으로 정해보려한다.<br />
(Git관련 컨벤션도 마찬가지)</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM-1VdH_kFqctfjRS6-B8tYK4FNPMHYUnZIp6UgjW1eOU0rNyuPYH1DCxJNVBtAbZyobQGsmzJtE9fEEc9uo7oBshdphw=w1920-h864" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>issue를 라벨할 수 있게 우선 파트별로 간단하게 나누었다.</p>

<p>그리고 브랜치 전략은 여러 사이트를 돌아디니다 보면서</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPRcd6ABuDdMcynR6HuiG9x19VUEIEgZ22ux_TWOCwIbb_0bOlWJc1Ka7Ut_ljdzInElTXQf-IT1A-UnqGNjx5CTdse=w1920-h864" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>내가 직접 그려가지고 이렇게 작업해보면 어떨까? 하는 생각이 들었다.<br />
백엔드와 프론트엔드가 다른 브랜치에서 개발하다가 <br />
통합 릴리즈 브랜치에 merge를 하여 확인후에 최종적으로 main 브랜치에<br />
통합하는 방식으로 진행하는 방식이다.</p>

<p>사실 이렇게 하는 방법이 맞는지는 모르겠다.<br />
워낙 작은 규모의 프로젝트이고 어떻게 적용을 해야된다는 답을 찾지는 못했지만<br />
우선은 이렇게 먼저 그려보고 팀원과 의견을 나눠보면 어떨가싶었다.</p>

<p>모두가 Github을 이용한 협업을 처음해보기 때문에<br />
합을 마춰보면 어떨가하여 오늘 저녁 7시에 가능한분들만<br />
위 브랜치 전략대로 연습하는 시간을 가지면 어떨까하여 공지를 했었다.</p>

<p><br /></p>

<h4 id="첫번째-모임과-github-협업-연습">첫번째 모임과 GitHub 협업 연습</h4>

<p>갑작스러운 모임 요청이었고, 가능하신분들만 연락을 달라고 조심스럽게 얘기를 했는데<br />
6명중 5분이 참여해주셨다. 정말이지 너무 감사했다. <br />
어떻게 보면 비공식적으로 모두가 만나서 처음 합을 맞춰보는 과정이었다.</p>

<p>결과는 대만족.<br />
오늘 처음으로 같이 얘기해보면서 어떻게 할지?<br />
순서를 정하고 퍼즐맞추듯이 진행을 해보았는데<br />
너무 합이 잘맞게 진행을 했고, 저녁늦은시간까지 다들 지친기색없이<br />
배움에 재미에빠져서 몰두하다보니 늦은시간까지 계속 작업을 했다.  ㅎ</p>

<p>위있는 전략을 적용하기전에<br />
main, develop, feat 브랜치로만 구성해 각자 개발해보면서 <br />
PR 보내고, Merge도 진행하면서 테스트를 했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNEZSbt1PzTLzvvmDqShzTLdqnan6wqOgNt_H-dPSuMGY9AVOoVCyrElw0k0WeIONLxpND79iJGIBrtX83_XTFE9nq-1g=w1920-h921" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>처음에 살짝 삐걱대긴 했지만 어느정도 모두 감을 익히는데는 충분했다.<br />
아직 Git 컨벤션 관련해 정의한 것이 없기때문에<br />
이름은 막지으면서 스터디를 했지만 다음주 월요일 부터는 <br />
FM으로 이름을 정하고 진행하기로 얘기를 마무리했다.</p>

<p>갑작스러운 요청에도 다들 모여서 이렇게 연습을 할 수 있었다는 것에<br />
너무 팀원들에게 감사했고 처음으로 맞춰보는 합이 잘맞아서 시작이 좋은 것 같다.</p>

<p>시작이 반이라는데 이미 반 이상을 넘어온 것 같은 느낌이다.</p>

<p><br /></p>

<h3 id="20221218-일">2022.12.18 (일)</h3>

<p>다음주부터 본격적인 협업이 시작될 것 같으니<br />
미리 준비해서 팀원들과 소통일 잘되어야할 것 같아<br />
미리 여러 컨벤션을 어떻게 사용할지?<br />
정리가 필요할 것 같아 주말을 이용해 정리를 해보았다.</p>

<p>정확히 어떻게 해야하는 것이 맞는 것인지?를 가늠하지 못해<br />
여러 선배기수의 프로젝트를 탐방하기 시작했다.</p>

<p>어느정도 비스한 형태안에서 컨벤션을 사용하는 것을 보았고<br />
첫번째 프로젝트인 만큼 가장 많이 사용하는 컨벤션 느낌으로 팀원에게 제안해보려한다.</p>

<h4 id="github-관련-정리">GitHub 관련 정리</h4>

<p>첫번째로 Git Commit 컨벤션이다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[feat] : 새로운 기능을 추가할 경우
[fix] : 버그를 고친 경우
[design] : CSS 등 사용자 UI 디자인 변경
[!breaking change] : 커다란 API 변경의 경우
[!hotfix] : 치명적인 버그를 고쳐야하는 경우
[style] : 코드 포맷변경, 세미콜론 누락, 코드수정이 없는 경우.
[refactor] : 프로덕션 코드 리펙토링할 경우
[comment] : 필요한 주석 추가 및 변경
[docs] : 문서를 수정한 경우
[test] : 테스 추가 테스트 리펙토링
[chore] : 빌드 테스트 업데이트, 패키지 매니저를 설정하는 경우
[rename] : 파일 혹은 폴더명을 수정하거나 옮기는 작업만 하는 경우
[remove] : 파일을 삭제하는 작업만 수행한 경우
</code></pre></div></div>
<p>커밋에 대한 규칙이 필요하기 때문에 앞에 이러한 형식으로<br />
작업 내용에 대한 구분을 하는 것이 좋을 것 같다고 생각했다.</p>

<p><br /></p>

<p>두번째로는 Git Branch 컨벤션이다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main : 메인 배포 브랜치 
release : 릴리즈 브랜치
dev_front : 프론트엔드 브랜치
dev_back : 백엔드 브랜치
feat_프로젝약자+번호 : 기능개발 브랜치 ex) feat_STC001
</code></pre></div></div>
<p>금요일에 팀원들 거의 전부가 브랜치 전략으로 내가 구성한 전략을<br />
사용하기로 거의 채택?이 되어진 느낌이었다.<br />
그래서 해당 브랜치 전략으로 Git Branch 컨벤션을 만들었다.<br />
아마 기능 개발구현 feat에 대한 내용만 잘 통일시키면 큰 문제는 없어 보인다.</p>

<p><br /></p>

<p>세번째로는 GitHub Issue 컨벤션이다.<br />
우리는 GitHub를 이용해 칸반보드를 관리할 생각이다.<br />
Issue를 이용해 라벨을 붙여 작업내용에 대한 내용과 정리를 할 수 있어<br />
칸반보드에 사용하기 유용하다고 판단해 Issue 제목 작성에 대한 컨벤션이 필요해 보였다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[FE] 해야할 작업 제목 or 이슈 제목 ex) [FE] 회원가입 화면 구현
[BE] 해야할 작업 제목 or 이슈 제목 ex) [BE] OAuth2 인증 구현
</code></pre></div></div>

<p>제목은 프론트엔드와 벡엔드 작업으로 구분하려한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPPj9_5nw9srv0aXXeZ-ulIZy-Cw9svEZ01OaqvC3MpGSv962jD-R5H_7RBHr87E_DGlVL35Gpfyr70zW4628NHEV12=w1920-h975" alt="image" class="align-left" style="max-width: 80%" /></p>

<p>상세 내용은 작성자의 이름 라벨과 어떠한 작업인지 표시해주는 라벨을<br />
붙여서 issue에 대한 내용을 관리하려고 한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMu6ih-YmXAN-eKxRdDb6d5E-n-CxkPPLmpJhGpTZg6KojPCU8mE6rTuYfBQ0GkgQfMQUWppWg94tOPGq2igqF_oBdKTw=w1920-h975" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPlAg-qlvom9hlzDG9GSZ9tQCk8NAKWq6rbAGY4jNlS6k_gkcCMWdkM-JnX4vsLKfsW87tv-Tp_2L-77iWpqycOif2Mdw=w1920-h975" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>대략 이러한 느낌으로 관리를 진행해보려한다.<br />
우선 나의 생각으로만 준비한 것이기 때문에, 월요일에 팀원들의 의견을 들어보고<br />
더 여러가지 방향으로 컨벤션관리하는 것을 적용해보려한다.</p>

<p><br /></p>

<h4 id="java-컨벤션-정리">Java 컨벤션 정리</h4>

<p>마지막으로 Java 컨벤션 관련이다.<br />
클라이언트 컨벤션관련해서는 프론트엔드 측에 우선 얘기는 해두었다.<br />
아무래도 내가 프론트엔드쪽 지식이 풍부하지 않다보니… 프론트엔드 인원에서<br />
우선 정의를 해보고 같이 의논해보는게 좋을 것 같다.</p>

<p>Java 컨벤션 관련해서는 <a href="https://naver.github.io/hackday-conventions-java/">자바 컨벤션 정리 사이트</a>를 참조해서<br />
적어 보았다. 우선 간단한 컨벤션들만 먼저 정리해두었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMftLqoXCoYCbYxdbxGYh-mmCDo5av5JiMiwQIBMIYq7UN5XI1Tv1a-uVPyGyc60cg0eKsy8MFl-eYkSLouva99kSeL=w1920-h975" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>그리고 알아보니까 컨벤션관련해서<br />
SonarLint라는 좋은 Plugin이 있는 것 같아<br />
팀원들끼리 같이 사용해보면 어떨까? 라는 생각이 들어 정리했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNXf0fjuWaSX475JeJFOgpA07CpvmLxcEmy8CoxOQi1_a23PcmloY9a8U5CVDEAcZPo24-TlGJTPlo-l62UQn9GB7fgUQ=w1920-h975" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>한번 사용해보니 콘솔로 위치를 알려주고 노란색으로 밑줄도 그어줘서<br />
처음에 컨벤션이 헷갈리는 우리들에게는 정말 좋은 플러그인이 아닐까?<br />
라는 생각을 해봤다.</p>

<p><br /></p>

<p>이렇게 주말에 잠깐 간단하게 컨벤션을 정리했고<br />
월요일에 다같이 회의할때 차질없는 진행을 하고싶어 미리 정리를 하였다.<br />
어느정도 정리하고나니까 마음이 편안.. 이제 다음주에 회의를 통해<br />
컨벤션을 확정시키고, 협업에 대한 룰을 각자 지키면서 어플리케이션을 작업하는<br />
일만 남은 것 같아 어느정도 속이 후련해졌다.</p>

<p><br /></p>

<h3 id="20221219-월">2022.12.19 (월)</h3>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[모든 교육이 끝나고 프리 프로젝트를 시작했다. 프로젝트에 대한 기대가 너무 컸고, 얼른 내가 알고있는 기술들을 사용해보면서 구현을 해보고 싶었다.]]></summary></entry><entry><title type="html">TIL) 네달차 회고</title><link href="http://localhost:4000/til/2022/12/14/til.html" rel="alternate" type="text/html" title="TIL) 네달차 회고" /><published>2022-12-14T00:00:00+09:00</published><updated>2022-12-14T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/14/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/14/til.html"><![CDATA[<p>4달 동안의 교육과정이 끝났다. <br />
아직 2달이라는 프로젝트 기간이 남았지만<br />
코드스테이츠의 정식적인 교육 기간은 종료되었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMPl-U5WSVnl2X_QlCFUFldb2dx62RGh-lw8AoRL2iVdE009mPfIjWddWnl9JK--dj78_kgJ-GdjDTkk40rN2z6SM7UMg=w3024-h1614" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>길면 길었고 짧으면 짧았지만 4개월간 새로운 내용들을<br />
계속해서 배워가고 찾아보고 공부하는 과정이 정말 즐거웠다.</p>

<p>평일,주말 가릴 것 없이 수업 진도를 따라가기 위해서<br />
거의 점심,저녁 먹는 시간을 제외하고는<br />
계속 공부했던 것 같다. 주말에는 조금 더쉬긴 했지만<br />
공부하는 습관이 길들여진게 가장 중요한 것 같다.</p>

<p>아직 배울 것도 까마득하고.. 시간이 모자라다는 생각이 정말 많이 들었다. <br />
프로젝트에 앞서 어떤 기술을 배웠는지 회고해보고<br />
어떻게 이용할 수 있을지? 공부를 앞으로 어떻게 할지를 적어보려한다.</p>

<hr />

<h3 id="네달차에는-어떤걸-배웠었지">네달차에는 어떤걸 배웠었지?</h3>

<p>섹션1 에서는 웹에 대한 CS지식과 Java에 익숙해지기<br />
섹션2 에서는 Java를 활용한 알고리즘 풀이와 Spring 맛보기<br />
섹션3 에서는 Spring을 씹고 뜯으면서 즐기기<br />
섹션4 에서는 Spring에 대한 인증과 보안에 대해 공부했고<br />
빌드와 배포 과정을 배우면서 여태 배운걸 모든걸 적용해 웹을 만들고 배포하는<br />
그러한 시간을 한달동안 가졌었다.</p>

<p>이번 섹션에서는 정말로… Spring Security를 배우면서<br />
배움의 깊이가 깊어지고 어떻게 공부를 해야할지 깨닫는 시간이었다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMb-GiTXNgFjwEFGssz9apOx8arCoSKe-OLIvTZ8FApzMK52-lE-5lXWb9LnJatBaqnGYRBIop7J17uy-uFoOOFVkuuDQ=w3024-h1614" alt="image" class="align-left" style="max-width: 60%" /></p>

<p>사실 이전까지는 그냥 만들어진 기능만 잘 사용하면 그만아닌가? 라는 생각을 했다. <br />
Spring Seucrity를 배우면서 내가 사용하려는 프레임워크에 대한 이해도가 깊어야<br />
비로소 내가 구현하고자하는 것을 자유롭게 사용할 수 있다라는걸 느꼈다.</p>

<p>보안관련된 부분과 CI/CD에 대해 배웠었는데<br />
모든걸 당장 적용해보라하면 당연히 할 수 없다.<br />
하지만 이번에 확실히 배운건.. 보안과 CI/CD에서 몰랏던 용어들이 친숙해진점과<br />
어떤 기능들이 어디에 있는지..? 그림이 머릿속에 그려지는 것, 그리고<br />
이제는 어떤 것을 찾아봐야하는지 안다는 점이다.</p>

<p><br /></p>

<h3 id="여태까지의-회고-앞으로의-계획">여태까지의 회고, 앞으로의 계획</h3>

<p>네달이라는 긴 시간동안 공부하면서<br />
한번도 빠지지 않고 지킨 것들이 2개가 있다.</p>

<ul>
  <li><strong>하루에 한번씩 커밋하기</strong> 🌱</li>
</ul>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMZ4F4mz3R-zJl8c9FppemfvEnqseVjc7mmB0bGlDHpZjio9pwt_lZVQJr1PM5BBMTdRiwOt_jIBXqYRUno7OIEZXpbCQ=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>정말 평일 주말 빠짐없이 커밋을 했다. (물론 의미있는 내용으로 !!) <br />
주로한 커밋은 섹션중 배운 코드 정리한 내용들과 Github 블로그 커밋<br />
그리고 알고리즘 풀이 커밋 등이 있었다.<br />
앞으로도 계속 잔디를 심어갈 예정이다.</p>

<p><br /></p>

<ul>
  <li><strong>TIL 꾸준히 작성하기</strong> 📖</li>
</ul>

<p>TIL 작성하느라 대부분 시간을 쏟은 것 같다.<br />
정규시간이 끝나면 배운내용 정리하는 일이 정말 쉬운일이 아니였다.<br />
하지만 내가 오늘 배운 내용을 다시 정리해보는 일은<br />
대충 넘어갔던 내용이라든가 제대로 이해하지 못했던 것들이라든가..<br />
개념을 다시한번 정립하는 시간을 가짐으로서 기초가 조금더 탄탄해진 느낌이 들었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNO2ubkWSA2QpXYZeuEW9qjrZow1SA61qggtuXAJsTN7eOZYUryE0HZJSPt1VTDrtCWB9yYUw92K7w9x4_j6vIr_RpWvA=w3024-h1728" alt="image" class="align-left" style="max-width: 70%" /></p>

<p>오늘 글을 기점으로 TIL은 종료하려고한다.<br />
부트캠프에서 배우는 내용을 정리하고자 시작했던 일이었고<br />
이제 프로젝트때 공부한 내용이라든가, 에러 처리 글이라든가<br />
각각 카테고리에 맞게 글을 써서 작성해보려한다.</p>

<p>다시말해 이제는 정말 프로젝트에 집중해 기술을 익히고 공부해서<br />
정리가 필요하다고 생각하는 부분만 정리하려는 것이다.</p>

<p><br /></p>

<p>모두가 공감하겠지만…<br />
사람이 정말 부지런하고 꾸준하다는 것은 정말 힘든 것 같다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOP9T1JWo1M3EWlE2ddf1M5nv446f916LELnYwnbL7L23TGpLExKsbBfp9uNkCTKh2WhQdLOXpEg0dKWmj2Y-hOXOH1MA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>몸이 자꾸 침대로 먼저 가있는 나를 보면서.. 정말 나태하구나<br />
라는 생각을 했던적이 많은 것 같다.</p>

<p>처음엔 뭐든 할 것 같은 포부로 덤벼들 었지만 2~3달차가 정말 고비였다.<br />
물론 게을리 놀고만 있진 않았지만, 시간을 내서 공부하는일이 쉽지는 않았다.</p>

<p>회의감이 들 때 쯔음에 정신을 바짝 차리고 강의라도 듣자는 마음에<br />
큰돈을 들여 인프런 강의를 구매했다. 돈을 주고 구매했다보니<br />
계속 듣는 습관이 생기고 지속적으로 나를 그러한 환경에 노출시키다 보니<br />
어느 순간 내가 알아서 찾아서 공부하는 단계까지 온 것 같다.</p>

<p>아마 혼자 계속 공부를 했으면 정말 힘들었을 것 같다.<br />
다행이 우리 1일1커밋 스터디원들과 떠들기도 하고<br />
지식공유도하고 서로 의견들 나눠가면서 공부를 하다보니까<br />
동기부여도되고 앞으로 나아가는데 추진력을 준 것 같아서 스터디 활동하길 잘했다고 생각했다.</p>

<p><br /></p>

<p>이제는 본격적으로 프로젝트에서 사용하는 기능들을<br />
체득해야하는 시간이 다가왔다. 여태까지는 한번씩 사용해보고 <br />
머리로만 이해를 했다면, 이제는 사용해보고 체득해야한다.</p>

<p>앞으로의 2달을 알차게 보내기 위해<br />
내가 정말 깊이있게 공부해보고 자연스럽게 사용하고 싶은 항목들을 쭉 적어본다.</p>

<ol>
  <li><strong>Spring MVC</strong><br />
-. Spring MVC 계층에 대한 깊은 공부 ex) DispatcherServlet, HandlerMapping …등<br />
-. 항상 사용하는 어노테이션과 클래스 외에 여러 방법으로 처리해보기</li>
  <li><strong>Spring JPA</strong><br />
-. 연관관계 맵핑하는 것이 자연스러워 질때까지 연습과 공부<br />
-. Transaction에 대한 깊은 이해<br />
-. JPA 기술을 이용하지않고 구현해보는 연습 ex) JDBC만 이용하기.. 등  <br />
-. JPA - JDBC - DataBase 까지의 관계도를 그려보고 큰 아키텍쳐를 깊숙히 이해해보기</li>
  <li><strong>Spring AOP</strong><br />
-. AOP 기술 적용을 자연스럽게할 수 있을때까지 체득하고 공부하기<br />
-. 아직 어색한 포인트컷 지시자에 대해 공부</li>
  <li><strong>Spring Validation</strong><br />
-. 유효성 검증에 대한 어노테이션 및 문법을 체득할떄까지 연습<br />
-. 정규 표현식에 대한 공부</li>
  <li><strong>JUnit</strong><br />
-. 계층별 테스트에 대한 코드를 익숙하게 작성할 수 있게 연습<br />
-. API 문서 자동화에 대한 연습</li>
  <li><strong>Docker</strong><br />
-. Docker를 이용하는 법이 익숙하게 체득하여 여러가지 용도로 활용해보고 싶음<br />
(로컬환경 통일화, 프론트엔드 테스트 이미지 전송하여 테스트하도록.. 등)</li>
  <li><strong>CI/CD</strong><br />
-. AWS S3, EC2, RDS 등 인스턴스 만드는 것이 자유롭도록 연습<br />
-. 수동으로 배포하는 과정을 수시로 연습 및 EC2 초기 환경에 필요한 목록들 정리<br />
-. GitHub Action을 통한 빌드, 배포 자동화하는 과정에 대한 깊은 이해하기<br />
-. 여유가 된다면 AWS 파이프라인까지 공부</li>
</ol>

<p><br /></p>

<p>이렇게 크게 파트를 나눠서 적어보긴 했지만 분명 더 공부해야하는 범위들이 생길 것이다.  <br />
내가 이렇게 적어놓은 이유는 적어도 2달동안 위에 있는 내용들에 대해<br />
자연스럽게 술술 코드를 작성하거나 잠깐만 찾아봐도 할 수 있는 정도까지 체득하려고하는 것이다.<br />
그래야 앞으로 더 깊이있는 내용을 공부할 수 있을 것 같고<br />
추가적인 사항에 대한 공부를 지속할 수 있을 것 같기 떄문이다.</p>

<p>위에 있는 7가지의 목표를 가지고 2달동안 진짜 죽어라 다시 공부에 전념해볼 생각이다.<br />
이상 여태까지 부트캠프에 대한 회고와 앞으로의 계획을 적어보았다.</p>

<p><br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[4달 동안의 교육과정이 끝났다. 아직 2달이라는 프로젝트 기간이 남았지만 코드스테이츠의 정식적인 교육 기간은 종료되었다.]]></summary></entry><entry><title type="html">TIL) Ngrok 사용하여 로컬에서 서버 실행</title><link href="http://localhost:4000/til/2022/12/13/til.html" rel="alternate" type="text/html" title="TIL) Ngrok 사용하여 로컬에서 서버 실행" /><published>2022-12-13T00:00:00+09:00</published><updated>2022-12-13T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/13/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/13/til.html"><![CDATA[<p>오늘은 어제 만들었던 TODO List 프로젝트를<br />
로컬환경에 띄우고 외부에서 접속할 수 있도록 하려한다.<br />
AWS EC2같은 클라우딩 서비스에 배포를 하지 않아도<br />
외부에서 접속이가능하니 프론트엔드쪽과 협업할때 매우 좋을 것 같다.</p>

<h3 id="ngrok-설치-및-사용">Ngrok 설치 및 사용</h3>

<p>우리가 사용중인 네트워크 방화벽과 NAT를 손보면<br />
외부IP에서 우리의 로컬환경에 접속이 가능하다. 하지만 그렇게 될 경우<br />
보안적으로는 매우 위험할 것이고, 이러한 상황에 Ngrok라는 툴을 사용하면<br />
상대적으로 안전하게 개발환경을 구축할 수 있다.</p>

<p>Ngrok은 네트워크 설정을 하지 않아도<br />
방화벽을 넘어 외부에서 로컬 환경에 접근할 수 있게 해주는 터널링 프로그램이다.<br />
무료 플랜의 경우 연결 세선이 2시간 가량 유지 된다고한다.</p>

<p><a href="https://ngrok.com/download">Ngrok 설치</a>방법은 하이퍼링크를 참조하자.<br />
Mac 유저인 경우는 homebrew로 설치도 가능하고<br />
ZIP파일을 다운받아 사용도 가능하다.</p>

<p>ZIP파일을 다운 받으면 다운받은 경로에서 <br />
관리자 권한으로 unzip을 해주면 된다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo unzip ~/Downloads/ngrok-v3-stable-darwin-amd64.zip -d /usr/local/bin
</code></pre></div></div>
<p>나와 같은 경우는 <code class="language-plaintext highlighter-rouge">~/Desktop/Download</code>의 경로에 파일이 있었기에<br />
앞에 경로만 변경해서 <code class="language-plaintext highlighter-rouge">sudo unzip</code>을 실행해주면 된다.</p>

<p>설치가 완료되고</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ngrok <span class="nt">-h</span>
</code></pre></div></div>
<p>를 입력하면 옵션에 대한 설명이 나올 것이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gObsmscGnFyEnA0dNsZKusGOpCI7AOhWbFj1xP9TzarKyjkfZMV-kWxLwuaaRfu64X9e7Q1sSuOtTyx8BVyQ9p_5EUkrQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그렇다면 정상적으로 설치가 완료된 것이다.</p>

<p>터미널에서</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ngrok http 8080
</code></pre></div></div>
<p>을 입력해주게 되면 <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>로 연결해주는</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOjwMrGdUi75T-RxvGdlsyritWRjFkORgi8EGTcO4k5XEjRyV_7wWkDoXIAkOjbTp5yImsdeNeBI5fcDNuEaklMf9u4iQ=w1920-h888" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>url을 하나 제공해준다. 해당 url로 협업하는 프론트엔드 측에<br />
서버를 띄워주면 이것으로 임시적으로 테스트가 가능하다.</p>

<p>해당 세션은 2시간이고, 종료했다 다시 시작하면 2시간이 채워지니<br />
한번씩 껏다키는 번거로움을 제외하고는 정말 좋은 프로그램인 것 같다.</p>

<p><code class="language-plaintext highlighter-rouge">http://127.0.0.1:4040/</code> 로 접속하게 된다면<br />
현재 요청,응답에 대한 내용들이 보기 편하게 나오니 참고해보면 좋을 것 같다.</p>

<p><br /></p>

<h3 id="tomcat-서버-띄우기">Tomcat 서버 띄우기</h3>

<p>위에서 Ngrok를 사용해 외부에서 내 로컬서버로 터널링하는 것을 배웠다.<br />
근데 만약 내가 개발중이라면 계속 스프링 부트 애플리케이션을 실행 시켜놓을 수는<br />
없는 셈이다.. 그래서 톰캣 서버를 하나 띄워 임시 애플리케이션을 배포해두면<br />
프론트엔드 측에서도 API 요청 체크가 가능하고, 백엔드 쪽에서도 개발을 진행할 수 있다.</p>

<p><a href="https://tomcat.apache.org/download-90.cgi">톰캣 공식 사이트</a>에서  <code class="language-plaintext highlighter-rouge">tar.gz (pgp, sha512)</code>를 다운받으면 된다.<br />
(나는 MacOS를 사용하므로 위에 파일을 받은 것이다)</p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">bin</code>폴더에 스크립트 파일을 이용해 톰캣서버를 실행시킬 수 있다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./startup.sh
</code></pre></div></div>

<p><br /></p>

<p>종료시에는 아래 스크립트를 실행시키면 된다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./shutdown.sh
</code></pre></div></div>

<p>톰캣서버가 실행되면 기본 포트는 <code class="language-plaintext highlighter-rouge">localhost:8080</code>으로 접속이 가능하다.</p>

<p>톰캣서버의 설정을 변경하는 경로는 아래와 같다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conf &gt; server.xml
</code></pre></div></div>
<p>해당 xml파일을 열어 포트번호를 변경한다든가… 혹은<br />
내가 빌드한 <code class="language-plaintext highlighter-rouge">.war</code>파일의 경로를 설정한다든가 할 수 있다.</p>

<p>우선 포트번호를 변경하는 방법이다.<br />
아래와 같이 <code class="language-plaintext highlighter-rouge">Connector</code> 태그로 기존에 코드가 작성되어있다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Connector</span> <span class="na">port=</span><span class="s">"8090"</span> <span class="na">protocol=</span><span class="s">"HTTP/1.1"</span> <span class="na">connectionTimeout=</span><span class="s">"20000"</span> <span class="na">redirectPort=</span><span class="s">"8443"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<p>변경하고자하는 포트로 변경. (8080-&gt;8090)<br />
이제 <code class="language-plaintext highlighter-rouge">localhost:8090</code>으로 서버를 띄울 수 있다.</p>

<p>그리고 webapps 폴더에 내가만든<br />
애플리케이션을 놓고 해당 애플리케이션을 실행 시키고 싶을 경우<br />
기존에 작성되어있는 <code class="language-plaintext highlighter-rouge">Host</code>태그를 찾아서 코드를 추가해야한다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="nt">&lt;Host</span> <span class="na">name=</span><span class="s">"localhost"</span>  <span class="na">appBase=</span><span class="s">"webapps"</span>
            <span class="na">unpackWARs=</span><span class="s">"true"</span> <span class="na">autoDeploy=</span><span class="s">"true"</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- webapps 내 War파일 실행 --&gt;</span>
            <span class="nt">&lt;Context</span> <span class="na">path=</span><span class="s">"/"</span> <span class="na">docBase=</span><span class="s">"todolist-0.0.1-SNAPSHOT"</span>  <span class="na">reloadable=</span><span class="s">"false"</span> <span class="nt">&gt;</span> <span class="nt">&lt;/Context&gt;</span>

        <span class="c">&lt;!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html --&gt;</span>
        <span class="c">&lt;!--
        &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;
        --&gt;</span>

        <span class="c">&lt;!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern="common" --&gt;</span>
        <span class="nt">&lt;Valve</span> <span class="na">className=</span><span class="s">"org.apache.catalina.valves.AccessLogValve"</span> <span class="na">directory=</span><span class="s">"logs"</span>
               <span class="na">prefix=</span><span class="s">"localhost_access_log"</span> <span class="na">suffix=</span><span class="s">".txt"</span>
               <span class="na">pattern=</span><span class="s">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> <span class="nt">/&gt;</span>

      <span class="nt">&lt;/Host&gt;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">&lt;!-- webapps 내 War파일 실행 --&gt;</code>이라고 적힌 아래의<br />
<code class="language-plaintext highlighter-rouge">Context</code>태그의 내용을 추가해주면 된다.<br />
여기서 <code class="language-plaintext highlighter-rouge">docBase</code>의 이름은 내가 빌드한 <code class="language-plaintext highlighter-rouge">.war</code>파일의 이름이다.</p>

<p><br /></p>

<p>마지막으로 정리해보자면</p>
<ol>
  <li>내가 만든 어플리케이션을 빌드</li>
  <li>빌드한 파일을 톰켓 서버하나를 만들어 배포 (localhost:8090)</li>
  <li>Ngrok을 이용해 로컬과 터널링하여 연결</li>
  <li>프론트엔드쪽에서 API 요청 테스트가 가능</li>
</ol>

<p><br /></p>

<hr />

<p>오늘은 이렇게 만든 애플리케이션을<br />
프론트엔드에서 사용할 수 있게 터널링을 해주는 방법을 배웠다.<br />
docker를 이용해 사용을 해줄 수도있을 것 같다는 생각이든다.</p>

<p>오늘 공부는 여기서 끝!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️<br />
<strong>오늘의 점심</strong>: 라면, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[오늘은 어제 만들었던 TODO List 프로젝트를 로컬환경에 띄우고 외부에서 접속할 수 있도록 하려한다. AWS EC2같은 클라우딩 서비스에 배포를 하지 않아도 외부에서 접속이가능하니 프론트엔드쪽과 협업할때 매우 좋을 것 같다.]]></summary></entry><entry><title type="html">TIL) 프로젝트 연습, 준비</title><link href="http://localhost:4000/til/2022/12/12/til.html" rel="alternate" type="text/html" title="TIL) 프로젝트 연습, 준비" /><published>2022-12-12T00:00:00+09:00</published><updated>2022-12-12T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/12/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/12/til.html"><![CDATA[<p>드디어 정규과정이 다 끝이 났다.<br />
4개월이란 짧은 시간에 정말 많은 것을 배웠고<br />
모든 기술을 구현할 수 있는 능력은 없지만<br />
작은 프로젝트부터 시작해 경험을 이제 쌓아올려보려한다.</p>

<p>프로젝트때 내가 중점적으로 적용하고 공부해보려는 것은</p>
<ol>
  <li>Spring MVC</li>
  <li>Spring AOP</li>
  <li>Spring JPA</li>
  <li>Spring Security(JWT, OAuth2)</li>
  <li>계층별 테스트코드 작성</li>
  <li>API 문서 자동화</li>
  <li>배포 자동화</li>
  <li>docker를 이용한 배포환경 통일화</li>
</ol>

<p>이렇게 8개 정도를 정말 숙달할 정도로 연습해보려한다.<br />
현재 1번~4번까지는 어느정도 연습이 되어있지만<br />
자세한 계층구조를 파악하는 목적을 두고 있다.</p>

<p>5~8번까지는 실제 애플리케이션 동작들을 간편하게 사용하는 목적으로<br />
이용할 가능성이크고 특히 아직 익숙하지 않은 docker에 대해선<br />
팀원들과 상의해 정말 꼭 통일된 환경을 만들어서 작업을 해보고 싶다.</p>

<p>이렇게 프로그램 작성과 적용하여 내부내용까지 정말 <br />
이번 기회에 확실히 체득하고 내 것으로 만들 계획이다.</p>

<p><br /></p>

<h3 id="간단한-프로젝트-만들어서-해보기">간단한 프로젝트 만들어서 해보기</h3>

<p>본격적으로 팀원이 정해지기전에<br />
혼자 어느정도 만들어보는 시간을 가지는 시간이 주어졌다.</p>

<p>오늘은 Todo List를 구현하는 프로그램을 만들어 보려한다.<br />
클라이언트는 이미 오픈으로 제공되어 있는 <a href="https://todobackend.com/">Todo-Backend</a>사이트를 이용해<br />
서버와 H2 데이터베이스를 이용해 작성해볼 생각이다.</p>

<p>로컬 환경에서 테스트를 하고자한다면</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://todobackend.com/client/index.html?http://localhost:8080
</code></pre></div></div>
<p>해당 URL로 접속 시 TODO LIST에 대한 GET 요청이 이루어질 것이다.<br />
GET,POST,PATCH,DELETE 까지 적용해보자</p>

<p>우선 먼저 내가 사용할 기술들에 대한<br />
의존 라이브러리를 추가해주었다.<br />
내장 톰켓 서버를 사용할 것이고, H2를 사용할 거다.<br />
그리고 Mapper를 이용할 것이고, DB에 접근하는 기술은 JPA를 사용할 것이다.<br />
그리고 편의를 위한 롬복과, 테스트 코드 작성을 위한 의존라이브러리</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">jpa</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">web</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">validation</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">mapstruct</span><span class="o">:</span><span class="nl">mapstruct:</span><span class="mf">1.4</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="na">Final</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">google</span><span class="o">.</span><span class="na">code</span><span class="o">.</span><span class="na">gson</span><span class="o">:</span><span class="n">gson</span><span class="err">'</span>

	<span class="n">compileOnly</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">projectlombok</span><span class="o">:</span><span class="n">lombok</span><span class="err">'</span>
	<span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">h2database</span><span class="o">:</span><span class="n">h2</span><span class="err">'</span>
	<span class="n">annotationProcessor</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">projectlombok</span><span class="o">:</span><span class="n">lombok</span><span class="err">'</span>
	<span class="n">annotationProcessor</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">mapstruct</span><span class="o">:</span><span class="n">mapstruct</span><span class="o">-</span><span class="nl">processor:</span><span class="mf">1.4</span><span class="o">.</span><span class="mi">2</span><span class="o">.</span><span class="na">Final</span><span class="err">'</span>

	<span class="n">testImplementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">test</span><span class="err">'</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이 정도를 추가해볼 수 있을 것 같다.</p>

<p><br /></p>

<p>이제 의존라이브러리 설정을 다해주었으니<br />
웹 애플리케이션 계층 구조를 Controller, Service, Repository로 만들어<br />
적절한 구현과 역할을 나눠주자.</p>

<p>우선 Controller 부터 작성 했다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span><span class="err">\</span>
<span class="nd">@RestController</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TodoListController</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TodoListService</span> <span class="n">todoListService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TodoListMapper</span> <span class="n">todoListMapper</span><span class="o">;</span>

    <span class="nd">@PostMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">createList</span><span class="o">(</span><span class="nd">@Valid</span> <span class="nd">@RequestBody</span> <span class="nc">TodoListDto</span> <span class="n">todoListDto</span><span class="o">){</span>

        <span class="nc">TodoList</span> <span class="n">todoList</span> <span class="o">=</span> <span class="n">todoListService</span><span class="o">.</span><span class="na">createTodoList</span><span class="o">(</span><span class="n">todoListMapper</span><span class="o">.</span><span class="na">todoListDtoToTodoList</span><span class="o">(</span><span class="n">todoListDto</span><span class="o">));</span>
        <span class="nc">TodoListResponseDto</span> <span class="n">todoListResponseDto</span> <span class="o">=</span> <span class="n">todoListMapper</span><span class="o">.</span><span class="na">todoListToTodoListResponseDto</span><span class="o">(</span><span class="n">todoList</span><span class="o">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="n">todoListResponseDto</span><span class="o">,</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">CREATED</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">getLists</span><span class="o">(){</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TodoList</span><span class="o">&gt;</span> <span class="n">todoLists</span> <span class="o">=</span> <span class="n">todoListService</span><span class="o">.</span><span class="na">getLists</span><span class="o">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="n">todoLists</span><span class="o">,</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{listId}"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">getList</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">listId</span><span class="o">){</span>

        <span class="nc">TodoList</span> <span class="n">todoList</span> <span class="o">=</span> <span class="n">todoListService</span><span class="o">.</span><span class="na">getList</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>
        <span class="nc">TodoListResponseDto</span> <span class="n">todoListResponseDto</span> <span class="o">=</span> <span class="n">todoListMapper</span><span class="o">.</span><span class="na">todoListToTodoListResponseDto</span><span class="o">(</span><span class="n">todoList</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="n">todoListResponseDto</span><span class="o">,</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PatchMapping</span><span class="o">(</span><span class="s">"/{listId}"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">updateList</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">listId</span><span class="o">,</span>
                                     <span class="nd">@RequestBody</span> <span class="nc">TodoListDto</span> <span class="n">todoListDto</span><span class="o">){</span>

        <span class="nc">TodoList</span> <span class="n">todoList</span> <span class="o">=</span> <span class="n">todoListService</span><span class="o">.</span><span class="na">changeTodoList</span><span class="o">(</span><span class="n">listId</span><span class="o">,</span> <span class="n">todoListMapper</span><span class="o">.</span><span class="na">todoListDtoToTodoList</span><span class="o">(</span><span class="n">todoListDto</span><span class="o">));</span>
        <span class="nc">TodoListResponseDto</span> <span class="n">todoListResponseDto</span> <span class="o">=</span> <span class="n">todoListMapper</span><span class="o">.</span><span class="na">todoListToTodoListResponseDto</span><span class="o">(</span><span class="n">todoList</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="n">todoListResponseDto</span><span class="o">,</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@DeleteMapping</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">deleteLists</span><span class="o">(){</span>

        <span class="n">todoListService</span><span class="o">.</span><span class="na">deleteTodoLists</span><span class="o">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">NO_CONTENT</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@DeleteMapping</span><span class="o">(</span><span class="s">"/{listId}"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">deleteList</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">listId</span><span class="o">){</span>

        <span class="n">todoListService</span><span class="o">.</span><span class="na">deleteTodoList</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">NO_CONTENT</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>크게 어려운 기술들은 없다.<br />
총 6개의 API로 가장 간단한 동작들만하는 메서드이다.</p>

<p>Entity 클래스 작성이다.<br />
JPA기술을 사용하기 때문에 해당 관련 설정을 해주어야한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TodoList</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">todoOrder</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">completed</span><span class="o">;</span>


    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">getCompleted</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">completed</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p>4개의 필드변수가 존재하고 <br />
테이블을 4개만 사용할 예정이다.</p>

<p>Repository 계층이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TodoListRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">TodoList</span><span class="o">,</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>
<p>JpaRepository를 상속받고, 우리가 Entity클래스로 지정한 <br />
<code class="language-plaintext highlighter-rouge">TodoList</code>와 Id 타입인 <code class="language-plaintext highlighter-rouge">Long</code>을 타입매개변수로 넣어주자</p>

<p>이제 Controller에서 주고받는 데이터를<br />
맵핑해주는 Dto 클래스를 만들어보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TodoListDto</span> <span class="o">{</span>

    <span class="nd">@NotBlank</span><span class="o">(</span><span class="n">message</span> <span class="o">=</span> <span class="s">"제목은 공백이 아니어야 합니다."</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">order</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">completed</span><span class="o">;</span>


    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">getCompleted</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">completed</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TodoListResponseDto</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">todoOrder</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">completed</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>첫번째 Dto는 Json객체로 요청이 왔을때<br />
맵핑을하도록 작성해주었다.<br />
아직 Valid 대한 예외처리는 적용하지 못한 상태이다.</p>

<p>두번째 Dto는 최종적으로 Reponse의 Body로 응답해줄<br />
Json객체를 만들기위해 맵핑해주는 Dto객체이다.</p>

<p>그리고 Mapper 클래스를 만들어보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Mapper</span><span class="o">(</span><span class="n">componentModel</span> <span class="o">=</span> <span class="s">"spring"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TodoListMapper</span> <span class="o">{</span>
    <span class="k">default</span> <span class="nc">TodoList</span> <span class="nf">todoListDtoToTodoList</span><span class="o">(</span><span class="nc">TodoListDto</span> <span class="n">todoListDto</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span> <span class="n">todoListDto</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">TodoList</span> <span class="n">todoList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TodoList</span><span class="o">();</span>

        <span class="n">todoList</span><span class="o">.</span><span class="na">setTitle</span><span class="o">(</span> <span class="n">todoListDto</span><span class="o">.</span><span class="na">getTitle</span><span class="o">()</span> <span class="o">);</span>
        <span class="n">todoList</span><span class="o">.</span><span class="na">setTodoOrder</span><span class="o">(</span><span class="n">todoListDto</span><span class="o">.</span><span class="na">getOrder</span><span class="o">());</span>
        <span class="n">todoList</span><span class="o">.</span><span class="na">setCompleted</span><span class="o">(</span> <span class="n">todoListDto</span><span class="o">.</span><span class="na">getCompleted</span><span class="o">());</span>

        <span class="k">return</span> <span class="n">todoList</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">TodoListResponseDto</span> <span class="nf">todoListToTodoListResponseDto</span><span class="o">(</span><span class="nc">TodoList</span> <span class="n">todoList</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Mapper를 통해서 <code class="language-plaintext highlighter-rouge">TodoListDto</code>객체를 <code class="language-plaintext highlighter-rouge">TodoList</code> 클래스로<br />
<code class="language-plaintext highlighter-rouge">TodoList</code>객체를 <code class="language-plaintext highlighter-rouge">TodoListResponseDto</code>클래스로 변경해준다.</p>

<p>이제 간단한 서비스로직에 대한 예외처리를 위한<br />
클래스를 만들어 보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ExceptionCode</span> <span class="o">{</span>
    <span class="no">LIST_NOT_FOUND</span><span class="o">(</span><span class="mi">404</span><span class="o">,</span><span class="s">"TodoList Not Found"</span><span class="o">);</span>

    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">status</span><span class="o">;</span>

    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">message</span><span class="o">;</span>

    <span class="nc">ExceptionCode</span><span class="o">(</span><span class="kt">int</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">status</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceLogicException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span><span class="o">{</span>
    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="nc">ExceptionCode</span> <span class="n">exceptionCode</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ServiceLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span> <span class="n">exceptionCode</span><span class="o">){</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">exceptionCode</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="k">this</span><span class="o">.</span><span class="na">exceptionCode</span> <span class="o">=</span> <span class="n">exceptionCode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이제 해당 커스텀 코드로 예외를 발생시킬 것이다.<br />
리스트의 존재여부와 같은 예외가 발생하면<br />
해당 예외를 발생시켜 추후에 Advice로 잡아서 처리해줄 수 있다.</p>

<p>이제 마지막으로 Service 로직을 작성해보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@Transactional</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TodoListService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TodoListRepository</span> <span class="n">todoListRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">TodoList</span> <span class="nf">createTodoList</span><span class="o">(</span><span class="nc">TodoList</span> <span class="n">todoList</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">saveTodoList</span><span class="o">(</span><span class="n">todoList</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">TodoList</span> <span class="nf">getList</span><span class="o">(</span><span class="nc">Long</span> <span class="n">listId</span><span class="o">){</span>
        <span class="k">return</span> <span class="nf">findTodoList</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">TodoList</span><span class="o">&gt;</span> <span class="nf">getLists</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">todoListRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">TodoList</span> <span class="nf">changeTodoList</span><span class="o">(</span><span class="nc">Long</span> <span class="n">listId</span><span class="o">,</span> <span class="nc">TodoList</span> <span class="n">todoList</span><span class="o">){</span>
        <span class="nc">TodoList</span> <span class="n">findTodoList</span> <span class="o">=</span> <span class="n">findTodoList</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>

        <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">todoList</span><span class="o">.</span><span class="na">getTitle</span><span class="o">()).</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">title</span> <span class="o">-&gt;</span> <span class="n">findTodoList</span><span class="o">.</span><span class="na">setTitle</span><span class="o">(</span><span class="n">title</span><span class="o">));</span>
        <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">todoList</span><span class="o">.</span><span class="na">getTodoOrder</span><span class="o">()).</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">todoOrder</span> <span class="o">-&gt;</span> <span class="n">findTodoList</span><span class="o">.</span><span class="na">setTodoOrder</span><span class="o">(</span><span class="n">todoOrder</span><span class="o">));</span>
        <span class="nc">Optional</span><span class="o">.</span><span class="na">ofNullable</span><span class="o">(</span><span class="n">todoList</span><span class="o">.</span><span class="na">getCompleted</span><span class="o">()).</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">completed</span> <span class="o">-&gt;</span> <span class="n">findTodoList</span><span class="o">.</span><span class="na">setCompleted</span><span class="o">(</span><span class="n">completed</span><span class="o">));</span>

        <span class="k">return</span> <span class="nf">saveTodoList</span><span class="o">(</span><span class="n">findTodoList</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteTodoLists</span><span class="o">(){</span>
        <span class="n">todoListRepository</span><span class="o">.</span><span class="na">deleteAll</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteTodoList</span><span class="o">(</span><span class="nc">Long</span> <span class="n">listId</span><span class="o">){</span>
        <span class="n">findTodoList</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>
        <span class="n">todoListRepository</span><span class="o">.</span><span class="na">deleteById</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="nc">TodoList</span> <span class="nf">findTodoList</span><span class="o">(</span><span class="nc">Long</span> <span class="n">listId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">TodoList</span><span class="o">&gt;</span> <span class="n">findTodoList</span> <span class="o">=</span> <span class="n">todoListRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">listId</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">findTodoList</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ServiceLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span><span class="o">.</span><span class="na">LIST_NOT_FOUND</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">TodoList</span> <span class="nf">saveTodoList</span><span class="o">(</span><span class="nc">TodoList</span> <span class="n">todoList</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">todoListRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">todoList</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p>아주 기본적인 서비스로직을 구현했다.<br />
트랜잭션 전파관련해 건드릴 만한 서비스도 존재하지 않아<br />
클래스단에 @Transactional을 붙여주었다.</p>

<p>JPA 기술을 이용해 <code class="language-plaintext highlighter-rouge">TodoList</code>객체만 보내주면<br />
DB에 맵핑이 되어진다.</p>

<p><br /></p>

<p>이렇게 간단하게 API요청과 응답에 대한 내용은<br />
전부 처리가 완료되었다.</p>

<p>이제부터 좀더 다듬어야할 부분은</p>
<ol>
  <li>유효성 검증에 처리 추가</li>
  <li>유효성 검증 실패에 따른 Advice 클래스 작성 필요</li>
  <li>계층별 테스트 케이스 만들기</li>
  <li>API 문서 자동화 해보기</li>
</ol>

<p>이렇게 코드를 추가해 볼 수 있을 것 같다.<br />
그리고 현재 로컬서버에서만 작동할 수 있게 되어있는데<br />
Ngrok를 이용해 로컬 환경에 접근할 수 있게 터널링 해주는 프로그램도<br />
이용해 볼 수 있을 것 같다.</p>

<p>우선적으로 터널링을 이용해 테스트를 해본다음<br />
위에 4가지 기능들을 구현할 시간이 주어진다면 내일 이어서 작업해볼 예정이다.</p>

<p><br /></p>

<hr />

<p>오늘은 이렇게 간단하게 웹계층을 만들어보는 시간을 가졌다.<br />
Spring MVC관련 계층 프로그램은 이제<br />
다른 프로그램을 보지않고도 할 수 있는 정도가 되었다.</p>

<p>하지만 예외를 처리하는 Advice 클래스 구현이라든가<br />
테스트 관련 계층은 문법이 생각나지않아 한번씩 보면서 작성을 해야한다…</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 제육볶음, 스팸부침, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[드디어 정규과정이 다 끝이 났다. 4개월이란 짧은 시간에 정말 많은 것을 배웠고 모든 기술을 구현할 수 있는 능력은 없지만 작은 프로젝트부터 시작해 경험을 이제 쌓아올려보려한다.]]></summary></entry><entry><title type="html">TIL) Cloud 운영 전략</title><link href="http://localhost:4000/til/2022/12/09/til.html" rel="alternate" type="text/html" title="TIL) Cloud 운영 전략" /><published>2022-12-09T00:00:00+09:00</published><updated>2022-12-09T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/09/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/09/til.html"><![CDATA[<h3 id="proxy-server">Proxy Server</h3>

<p>프록시 서버는 클라이언트가 서버와 소통할 때<br />
서버에 바로 접근하지 않고 자신을 통해 서버에 접근할 수 있도록<br />
해주는 대리 서버라고 생각하면 간단하다.</p>

<p><strong>1). Forward Proxy</strong></p>

<p>클라이언트 가까이에 위치한 프록시 서버다.<br />
클라이언트를 대신해 서버에 요청을 전달해준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMnENrT4W97MGhsCoY41GXXR2exz07o-Ftd6n5xNT5FsDCQA2-bKk1EkIPg1xG3Ziuonj4jBh9yFy3kLW35p_mYG1d7=w1920-h921" alt="image" class="align-left" style="max-width: 80%" /></p>

<p>장점</p>
<ul>
  <li>캐싱을 통해 빠른 서비스 이용이 가능하다</li>
  <li>보안 (서버에서 프록시서버 IP를 받기때문에 클라이언트 IP를 숨길 수 있다)</li>
</ul>

<p><br /></p>

<p><strong>2). Reverse Proxy</strong></p>

<p>서버 가까이에 위치한 프록시 서버다.<br />
서버를 대신해서 클라이언트에 응답을 제공해준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN3VUWC1TvwBt7n1ovAf-TPeX_VITPkt4aYr7_Nuf273yVBYeaq0oUo5sHfd-Npoe-w3HAY6kaY792Baqa5L01NYcYW=w1920-h921" alt="image" class="align-left" style="max-width: 80%" /></p>

<ul>
  <li>분산처리 (여러대의 서버로 요청을 나누어 전달 후 처리, ex) 로드밸랜서)</li>
  <li>보안 (클라이언트에게 서버 IP가 노출되지 않는다)</li>
</ul>

<p><br /></p>

<h3 id="load-balancer">Load Balancer</h3>
<p>로드 밸런서는 서버에 가해지는 부하(Load)를 분산(Balance) 해주는<br />
장치 또는 기술을 통칭한다.</p>

<p>하나의 서버에 클라이언트의 잦은 요청이 있으면<br />
서버의 과부하가 온다. 과부하로 인해서 서버가 원할하게 서비스를 제공하지<br />
못하는 경우가 발생하기 때문에, 이와 같은 문제를 해결하기 위한<br />
로드 밸린스 방식으로는 크게 2가지가 존재한다.</p>

<p><br /></p>

<p><strong>✅ 로드 밸런서 방식</strong></p>

<p><strong>1). Scale up</strong><br />
물리적으로 서버의 사양을 높이는 하드웨어적 방법이다.<br />
서버 수를 늘리지 않고 프로그램 구현있어 변화가 필요없다는 장점이 있다.</p>

<p>하지만 굉장히 높은 비용이 발생하고, 하드웨어의 업그레이드는<br />
한계가 있다는 단점이 있다.</p>

<p><strong>2). Scale out</strong><br />
서버의 갯수를 늘려 서버의 줄 부하를 분산시키는 방법이다.<br />
많은 요청이 오더라도 여러대의 서버가 나눠서 처리를 하기 떄문에<br />
서버의 사양을 높이지 않고도 비교적 저렴한 방법으로 부하를 처리할 수 있다.</p>

<p><br /></p>

<p><strong>✅ 로드 밸런서 알고리즘</strong></p>

<p><strong>1). 라운드로빈 방식 (Round Robin Method)</strong><br />
서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식</p>

<p><strong>2). 가중 라운드로빈 방식 (Weighted Round Robin Method)</strong><br />
각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선 배분하는 방식이다.</p>

<p><strong>3). IP 해시 방식 (IP Hash Method)</strong><br />
클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식이다.</p>

<p><strong>4). 최소 연결 방식 (Least Connection Method)</strong><br />
요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분하는 방식이다.</p>

<p><strong>5). 최소 리스폰타임 (Least Response Time Method)</strong><br />
서버에 현재 연결 상태와 응답시긴을 모두 고려하여 트래픽을 배분하는 방식이다.</p>

<p><br /></p>

<p><strong>✅ 로드 밸런서 종류</strong></p>

<p>로드 벨런서는 클라이언트의 요청을 어떤 것을 기준으로<br />
분산시키느냐에 따라 종류가 나눠진다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">로드 밸런서 종류</th>
      <th style="text-align: left">로드 밸런싱의 기준</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">L2</td>
      <td style="text-align: left">데이터 전송 계층에서 Mac 주소를 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">L3</td>
      <td style="text-align: left">네트워크 계층에서 IP 주소를 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">L4</td>
      <td style="text-align: left">전송 계층에서 IP주소와 Port를 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">L7</td>
      <td style="text-align: left">응용 계층에서 클라이언트의 요청을 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>✅ Auto Scaling</strong></p>

<p>오토 스케일링은 Scale out 방식으로 서버를 증설할 때<br />
자동으로 서버를 관리해주는 기능이다.<br />
클라이언트의 요청이 많아져 서버의 처리 요구량이 증가하면 새 리소스를<br />
자동으로 추하고 반대로 처리 요구량이 줄어들면 리소스를 감소시켜<br />
적절한 분산 환경을 만들어준다.</p>

<p><br /></p>

<h3 id="web-server">Web Server</h3>

<h4 id="tomcat">Tomcat</h4>

<p>톰캣은 스프링 학습하면서도 많이 보았을 것이다.<br />
Apache 회사에서 개발한 서블릿 컨테이너만 있는 오픈소스 웹 애플리케이션 서비이다.</p>

<p>우리가 흔히 <code class="language-plaintext highlighter-rouge">spring-boot-starter-web</code> 의존라이브러리를 설정해주면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM9BsZsYaMRKMNzpvRyIJ8x1e_QHfIL7G3lRFVPR5032Zy9WiYHkN968M8hq7geCpfSYH9AC0G8N496-KSCb84A34sepQ=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>외부 라이브러리에 추가된 모습을 볼 수 있다.</p>

<p><br /></p>

<h4 id="jetty">Jetty</h4>

<p>제티는 이클립스 재단의 HTTP 서버이자 자바 서블릿 컨테이너이다.<br />
우리는 스프링 웹에 내장되어 있는 톰켓을 사용했지만<br />
Jetty 서버로 변경하여 사용하는 것도 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
	<span class="n">implementation</span> <span class="o">(</span><span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">web</span><span class="err">'</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">exclude</span> <span class="nl">module:</span> <span class="err">'</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">tomcat</span><span class="err">'</span>
	<span class="o">}</span>
	<span class="n">implementation</span> <span class="o">(</span><span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">jetty</span><span class="err">'</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
<p>기존의 톰켓 서버를 제외시키고, Jetty의 의존라이브러리를 추가해주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM4Q_56HQcx6ER0D9G9vc_AzQ_8_XrDREbC2LuRI1onRPzYvqLRzIIAG9jqfKepfooEmAcKuLKWqQLqjckdnKhxsUCs=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>gradle 리로드완료하면 외부라이브러리에서 Tomcat은 없어지고<br />
jetty가 추가된 모습을 확인할 수가 있다.</p>

<p>마찬가지로 애플리케이션을 로컬에서 실행하면 <br />
콘솔에 <code class="language-plaintext highlighter-rouge">Jetty started on port(s) 8080</code>를 확인할 수 있다.</p>

<p><br /></p>

<h4 id="nginx-proxy-server">NginX (Proxy Server)</h4>

<p>NginX는 가볍고 높은 성능을 보이는 오픈소스 웹 서버 소프트웨어이다.<br />
Tomcat과 Jetty가 Java 서블릿 컨테이너 혹은 웹 애플리케이션 서버였다면<br />
NginX는 웹 서버로 클라이언트에게 정적 리소스를 빠르게 응답하기 위한 웹서버로 사용할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOG2uzsclZ4QWPxVAe_uxKcedgoaUBgThcMRAT424RV8K7dLYr9RTnqxzVnbtWUkm6Ovs1fmsRs7A7EAgNcEovLGs2bTA=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같은 구조를 만든다고 가정하고 로컬환경에서 테스트를 해보자</p>

<p>MacOs 기준으로 설명해본다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>nginx
</code></pre></div></div>
<p>homebrew를 이용해 nginx를 설치해준다.<br />
설치가 완료되면 <code class="language-plaintext highlighter-rouge">brew list</code> 명령어로 설치리스트를 확인할 수 있다.</p>

<p>NginX 서버를 실행시키는 방법은</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services start nginx
</code></pre></div></div>
<p>해당 명령어를 입력하면 서버가 실행된다.<br />
MacOS기준으로 기본 포트는 <code class="language-plaintext highlighter-rouge">localhost:8080</code>로 접속이 가능하다. 접속 성공 시에는 콘솔에  <br />
<code class="language-plaintext highlighter-rouge">==&gt; Successfully started nginx (label: homebrew.mxcl.nginx)</code><br />
해당 문구를 확인할 수 있다.</p>

<p>만약 서버를 종료하고 싶다면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services stop nginx
</code></pre></div></div>
<p>해당 명령어를 입력해주면 된다.</p>

<p>당연하게도 포트 변경도 가능하다.<br />
<code class="language-plaintext highlighter-rouge">nginx.conf</code>파일을 찾아서 변경해주면 된다.<br />
homebrew로 설치하였다면 <code class="language-plaintext highlighter-rouge">/opt/homebrew/etc/nginx/nginx.conf</code><br />
해당 경로에 존재할 확률이 높다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNeZvcQvQB3AXd4W2johu0UXke69vIktUKMB9ZCIWk3-U1-ZZEMEqf1zJcXXLqtOzRARHIow3uCQYvxVJevdtJorh-w=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>해당 파일을 vi, nano 편집기로 수정하여도 되고<br />
직접 열어 수정해도 된다.</p>

<p>파일에서 http &gt; server &gt; listen의 포트번호가<br />
8080으로 되어있을 텐데 해당 포트를 바꿔주면 된다.<br />
나는 80으로 변경하여 사용했다.</p>

<p>그리고 location에서 proxy_pass 관련 내용을 추가해주면 된다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
		listen       80; # 포트 변경
...
		location / {
				...
				proxy_pass http://localhost:8080; # 요청을 8080 포트로 넘깁니다.
				proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host $http_host;
		}
}
</code></pre></div></div>

<p>다시 nginx를 실행 시키고, 스프링 부트를 실행시킨다음<br />
<code class="language-plaintext highlighter-rouge">localhost:80</code>에 접속 요청을 하면<br />
SpringBoot로 서버를 띄운 화면으로 넘어가는 것을 확인할 수 있을 것이다.</p>

<p><br /></p>

<h4 id="nginx-load-balancer">NginX (Load Balancer)</h4>

<p>위에서 NginX로 프록시 서버를 만들어서 Spring Web 서버와 연결해보는 것 까지 해보았다.<br />
NginX를 이용해 로컬환경에서 로드 벨런싱을 구성할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPbhOAOVSac7VnsgOd7t4bBzA3D7UlzJQGluLPU_4874TJYacn9Jp7MvB4AuwI0cKCtT3kMfDyslCcYClK7J6f4iQ0b=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>해당 구성도 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일의 설정을 변경해서<br />
로드벨런싱이 되도록 구성할 수 있다.<br />
<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">NginX 로드벨런싱 레퍼런스</a>를 참고해서 작성해보자</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
http {
    ...
    
    # 로드 벨런싱 테스트를 위한 추가 (22.12.09)
    upstream backend {
        server localhost:8080;
        server localhost:8081;
    }
    # 여기 위까지 추가

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
	    
	    # 로드 밸런싱 테스트를 위한 추가 (22.12.09)
	    proxy_pass http://backend;    
	    
        }
        ...
    }
    ...
}
</code></pre></div></div>
<p>로드 벨런싱을 위한 추가라고 붙은 주석이 달린 곳을 보면된다.<br />
스프링 톰켓 서버를 8080, 8081로 애플리케이션으로 실행 시켜둔 다음에<br />
nginx 서버를 80으로 실행 시키고 접속 요청을 하였을 경우</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMKVdGhcGq-yZafA-Yn63bYoQPXPy66rpCBac1Xkzm4czEkxlMaLbtVs-uIpxJ9Jb5zrusAmMAHT38Mlfcu0c7sjJ6z_A=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이렇게 작성한 화면이 띄워지게 된다.<br />
여기서 화면을 구분하기 위해 PID값을 추가해 줬다.<br />
보면 알 수 있듯이 2개의 서버중 33861 PID 값을 가진 화면을 불러왔다.</p>

<p>여러번 새로고침을 반복하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPOoMHE0tlxe7V1CdRoQCdJmIN7tcTL1QwqUY4OwiudZff34WNG0Ss4s1HVGHXJyqp6vwdzWDNhjx6epx8Qh4RgGDBycw=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이번엔 33818 PID 값을 가진 화면을 불러왔다.<br />
이렇게 클라이언트에서 nginx 서버에 요청 시<br />
로드 벨런싱이 적용되어 동작하는걸 눈으로 확인해 볼 수 있다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 클라우드 운영 전략에 대해 간단하게 알아보았다.<br />
백엔드 공부를 시작하면서 늘 걱정이었던게<br />
서버가 터지는 것을 어떻게 방지하지? 라는 의문이 있었고<br />
환경적으로 이렇게 설정할 수 있구나라는걸 많이 배운 것 같다.</p>

<p>이러한 전략들 외에 실제로 웹 요청이 많을때 프로그램 코드적으로는<br />
어떻게 해야 잘 짤 수 있을까도 많이 고민해보면 좋을 것 같다. (WebFlux라든가..)</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 간장계란밥, 김치찌개</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[Proxy Server]]></summary></entry><entry><title type="html">TIL) 배포 자동화 GitHub Actions</title><link href="http://localhost:4000/til/2022/12/08/til.html" rel="alternate" type="text/html" title="TIL) 배포 자동화 GitHub Actions" /><published>2022-12-08T00:00:00+09:00</published><updated>2022-12-08T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/08/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/08/til.html"><![CDATA[<h2 id="github-action">Github Action</h2>

<p>오늘은 GitHub Actions라는 빌드, 테스트 및 배포 파이프라인을<br />
자동화할 수 있는 CI/CD 플랫폼을 배워보려한다.</p>

<p>Pull Request나 push 같은 이벤트를 트리거로 Workflow를 구성할 수 있다.<br />
Workflow는 하나 이상의 작업이 실행되는 자동화 프로세스로, 각 작업은 자체 가상 머신<br />
또는 컨테이너 내부에서 실행된다.</p>

<p><br /></p>

<h3 id="github-actions를-통한-자동화-배포-flow">Github Actions를 통한 자동화 배포 Flow</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNS7vEzt0Vzp4__CH13v9LcmDTz7WAHn3CuXNw2JbEdcTd0Rlim8mfhT_8BX6KokJ4pPfSp7XLuV-zHGrM6KAUkfRwPag=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<ol>
  <li>레포지토리에 변화가 생기면 Github Actions 작동</li>
  <li>프로젝트 빌드 결과물(.jar) S3로 전송 및 저장</li>
  <li>CodeDeploy로 배포 명령</li>
  <li>프로젝트 빌드 결과물(.jar) CodeDeploy로 전달</li>
  <li>EC2 배포 및 샐행</li>
</ol>

<p>GitHub Actions는 설정파일(<code class="language-plaintext highlighter-rouge">.yml</code>)에 따라 Github Repository에<br />
특정 변동사항을 트리거로 작동된다. 트리커는 Pull Request나 push 같은 이벤트를<br />
사용할 수 있다고 위에서 얘기 했었었다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="s2">"</span><span class="s">main"</span> <span class="pi">]</span>
</code></pre></div></div>
<p>간단한 예시로 <code class="language-plaintext highlighter-rouge">main</code>브랜치에 push가 되어질때를 트리거로 사용하는 <code class="language-plaintext highlighter-rouge">.yml</code>설정이다.</p>

<p>Github Actions에서 빌드를 마치고 빌드 결과물을(.jar)  AWS S3 버킷에 객체를 저장한다.<br />
그리고 Code Deploy로 배포 명령이 내려진다.<br />
(즉, S3는 빌드한 결과물을 저장해주는 용도로만 사용할 것이다.)</p>

<p>그렇게 Code Deploy가 배포 명령을 받으면<br />
S3에 저장되어 있던 빌드 결과물이 EC2 인스턴스로 이동한다.<br />
그리고 <code class="language-plaintext highlighter-rouge">appspec.yml</code>파일에 설정한대로 shell script를 동작한다.</p>

<p>그렇게되면 EC2에서 <code class="language-plaintext highlighter-rouge">.yml</code>,<code class="language-plaintext highlighter-rouge">.sh</code>파일들에 의해 빌드파일(<code class="language-plaintext highlighter-rouge">.jar</code>)을 실행하고<br />
배포 결과를 로그로 남길 수 있다.<br />
즉, EC2에서는 Code Deploy Agent의 설치와 JDK 버전 설치가 필요하다.</p>

<p><br /></p>

<h3 id="github-actions-생성">Github Actions 생성</h3>
<p>이제 자동 배포과정은 위에서 알아 보았으니<br />
Github Actions을 이용해 설정을 진행해보자.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMYNPG-u6wiQkjifVTjEQoKHtaBipydSZPQKgyZx0rYIcuXUSkJSallw1_50L0eTN2PolpzM0LN3Iq-53XpaeOGc0RISQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>테스트용으로 만든 Repository의 상단의 Actions를 들어가서<br />
Java with Gradle을 찾아 구성을 클릭해준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM5ES3mIxRbG_7Tv7xj6t5VmlwijcfF3hNJE-Y-6LL5Ho0UW-ryp83Wv09WSYX_zmL1A_yXR83yC5j1CYsvj7RGrvxRzw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>눌러 주고나면 상단에 <code class="language-plaintext highlighter-rouge">.yml</code>파일을 저장할 경로가 나오고<br />
이름을 설정해 줄 수 있다. 기본이름인 <code class="language-plaintext highlighter-rouge">gradle.yml</code>로 설정 후</p>

<p>하단에는 <code class="language-plaintext highlighter-rouge">gradle.yml</code> 파일에 대한 설정을 해주어야한다.<br />
위에서 잠깐 얘기했던 변동사항 트리거 설정, JDK 설치<br />
build한 후 압축하는 기능, AWS credentials 구성, 압축한 파일 S3 전송<br />
CodeDeploy에게 배포 명령 등 다양한 Workflow를 설정해 줄 수 있다.</p>

<p>해당 설정을 마쳤다면, Start commit 버튼을 눌러준 후 Commit new file을 눌러 주면 된다. <br />
<code class="language-plaintext highlighter-rouge">gradle.yml</code> 파일은 Repository <code class="language-plaintext highlighter-rouge">.github/workflows</code> 경로에 저장된다.</p>

<p>그리고 Actions에서 우리가 설정한 <code class="language-plaintext highlighter-rouge">gradle.yml</code> 설정대로<br />
Workflow가 진행되는 것을 확인 할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN_vA2swoIsKid0hpogGa6K3M2HJBTtXm-GDj3Jgd5XETM9wAWdxUNkQyJXVJNWW3jWBSsFBStT6Zi3nWTmNAZJ_xD8mQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>모든 과정이 완료되면 위와 같이 녹색으로 표시가 된다.<br />
이제 S3에 빌드파일 객체가 전달되었을 것이고<br />
Code Deploy의 작동을 모아놓는 <code class="language-plaintext highlighter-rouge">appspec.yml</code>설정이 제대로 되어있고<br />
script <code class="language-plaintext highlighter-rouge">.sh</code>들의 코드가 정상적으로 들어가 있다면<br />
EC2에 정상적인 배포가 자동으로 이루어졌을 것이다.</p>

<p>Github Actions를 설정하기전에</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOCCMyhm1hmET_5cP4ljHyaJO7PsnSF7BHDYz2UDXIXk_bnHjHRXcJiInrmSFkwX5vihtTEAlXthho-aq2hznZ2WicsZw=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우리가 이용하는 Code Deploy의 애플리케이션 생성과<br />
<code class="language-plaintext highlighter-rouge">appspec.yml</code>, <code class="language-plaintext highlighter-rouge">.sh</code>파일에 대한 설정은 끝나 있어야한다.</p>

<p><br /></p>

<h3 id="github-action-configure-aws-credentials">Github Action Configure AWS credentials</h3>

<p>현재 IAM 계정으로 AWS를 이용중이다.<br />
(<a href="https://docs.aws.amazon.com/ko_kr/powershell/latest/userguide/pstools-appendix-sign-up.html">참고 - AWS 엑세스키 관련 문서</a>)</p>

<p>Github Actions에서 Workflow를 실행하는 과정에서<br />
Access Key가 필요하다. 공개되면 보안 이슈가 발생할 수 있어<br />
Github Secret 기능을 이용해 Access Key 값을 저장한 후 사용할 수 있다.<br />
<a href="https://github.com/aws-actions/configure-aws-credentials">configure-aws-credentials 레퍼런스</a>를 참고해보면 좋을 것 같다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">steps</span><span class="pi">:</span>      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure AWS credentials</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">aws-actions/configure-aws-credentials@v1</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">aws-access-key-id</span><span class="pi">:</span> <span class="s">$</span> <span class="c1"># 등록한 Github Secret</span>
          <span class="na">aws-secret-access-key</span><span class="pi">:</span> <span class="s">$</span> <span class="c1"># 등록한 Github Secret</span>
          <span class="na">aws-region</span><span class="pi">:</span> <span class="s">ap-northeast-2</span>
     
      <span class="s">// ..생략</span>
</code></pre></div></div>
<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNUWS9aAZNZWUWqRYoX-BwmSLb-6gQk_20nb6IINmQUT2KAzI4lG5iZRNsAOzd0bseG1KReKyflHyumA-PfLlni5ijXrA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이렇게 키값을 설정해주면<br />
<code class="language-plaintext highlighter-rouge">gradle.yml</code>에서 환경변수 사용하듯이 사용이 가능하다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 Github actions를 이용해<br />
push 한번으로 EC2까지 자동으로 배포되어지는 기능을 사용해 보았다.<br />
안에 엄청나게 복잡한 내용들이 존재하는건 분명하다.</p>

<p>이 기능을 이용해본 입장으로서는 Workflow 구성설정과<br />
AWS CodeDeploy의 <code class="language-plaintext highlighter-rouge">.yml</code>,<code class="language-plaintext highlighter-rouge">.sh</code> 파일에 대한 내용만<br />
우리가 동작을 원하는대로 설정만 잘해두면 무리없이 동작되는 것 같다.</p>

<p>이렇게 이틀 동안 배포자동화에 대한 두가지 방법을 알아 보았다.<br />
느낀점은 AWS에 대한 공부가 절실하다는 것.<br />
전체적인 흐름을 이해했으니 이제 상세한 공부들이 필요할 시기다.</p>

<p>오늘 공부는 여기서 끝!!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 짜파게티, 김치찌개</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[Github Action]]></summary></entry><entry><title type="html">TIL) 배포 자동화 AWS Pipeline</title><link href="http://localhost:4000/til/2022/12/07/til.html" rel="alternate" type="text/html" title="TIL) 배포 자동화 AWS Pipeline" /><published>2022-12-07T00:00:00+09:00</published><updated>2022-12-07T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/07/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/07/til.html"><![CDATA[<h2 id="배포-자동화">배포 자동화</h2>
<p>말그대로 배포 자동화란 기존에 배포를 위한 복잡한 작업을<br />
클릭 혹은 명령어 입력을 통해 전체 배포 과정을 자동으로 진행하는 과정이다.</p>

<h3 id="배포-자동화-파이프-라인">배포 자동화 파이프 라인</h3>
<p>파이프 라인이라하면, 이전에 Stream API 공부할 때<br />
들어보았었다. 무언가 연결해준다는 의미를 가지고 있었다.<br />
배포 자동화에서 파이프 라인은 소스 코드의 관리부터 실제 서비스로의<br />
배포 과정을 연결하는 구조를 뜻한다. 파이프라인은 전체 배포 과정을<br />
여러 Stage(단계)로 분리한다. 가장 많이 쓰이는 3가지를 알아보자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOBugDzkr65yzP1swq8j1g1mBAZr045aqB-cw37iLymttIosjnfOMB7uXqdvuDB57Pn7JMCKjSYkUackOYK56Jxv-_yeg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<ul>
  <li>Source 단계
원격 저장소에 관리되고 있는 소스 코드에 변경 사항이 일어날 경우<br />
이를 감지하고 다음 단계로 전달하는 작업을 수행하는 단계이다.</li>
  <li>Build 단계
Source 단계에서 전달받은 코드를 컴파일, 빌드, 테스트하여 가공한다.</li>
  <li>Deploy 단계
Build 단계에서 전달받은 결과물을 실제 서비스에 반영하는 작업을 수행한다.</li>
</ul>

<p>기본적으로 위와 같이 단계가 있고, 상황과 필요에 따라<br />
더 세분화되거나 간소화될 수 있다.</p>

<p>AWS 개발자 도구 섹션에는 배포 자동화 파이프 라인을<br />
구출할 수 있는 서비스를 제공해준다.</p>

<p>CodeCommit - Source 단계때 구성할때 사용  <br />
CodeBuild - Build 단계를 구성할때 사용<br />
CodeDeploy - Deploy 단계를 구성할때 사용<br />
CodePipeline - 각 단계를 연결하는 파이프라인을 구축할때 사용</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM8pJIpAdD3GNp2mXZL5SYWXzDvSr1uUBGS_yexwRH8gfwX8ADARYcBpQiHMhElbxPMW_wio_bkug-UdFYF-4uucf4f7Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>CodeCommit을 제외한 파이프라인 구성이다.<br />
GitHub 레포지포티와 연결하여, 후에 변경사항을 반영했을 경우<br />
배포 과정이 자동으로 진행되는 방식이다.</p>

<p><br /></p>

<h3 id="개발환경-구축">개발환경 구축</h3>

<p>이와 같이 구성을 하기 위해서<br />
EC2 인스턴스에 java,aws-cli,ruby를 설치하여 개발환경을 구축해야한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
</code></pre></div></div>
<p>apt를 업데이트를 먼저 진행한다.</p>

<p><br /></p>

<p><strong>1). Java 설치</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-11-jre-headless
</code></pre></div></div>

<p><br /></p>

<p><strong>2). AWS CLI 설치</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"</span> <span class="nt">-o</span> <span class="s2">"awscliv2.zip"</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>unzip
unzip awscliv2.zip
<span class="nb">sudo</span> ./aws/install
</code></pre></div></div>
<p><a href="https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/getting-started-install.html">AWS CLI 공식 문서</a>를 참고하면 동일하게 나온다.<br />
unzip이 설치되어있다면 생략해도 가능하다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws <span class="nt">--version</span>
</code></pre></div></div>
<p>설치가 완려되면 버젼확인이 가능하다.</p>

<p><br /></p>

<p><strong>3). CodeDeploy Agent 설치</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>ruby-full             
<span class="nb">sudo </span>apt <span class="nb">install </span>wget
<span class="nb">cd</span> /home/ubuntu
<span class="nb">sudo </span>wget https://aws-codedeploy-ap-northeast-2.s3.ap-northeast-2.amazonaws.com/latest/install
<span class="nb">sudo chmod</span> +x ./install
<span class="nb">sudo</span> ./install auto <span class="o">&gt;</span> /tmp/logfile
</code></pre></div></div>
<p><a href="https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/codedeploy-agent-operations-install-ubuntu.html">AWS CodeDeploy 공식 문서</a>를 참조하면 확인이 가능하다.
wget이 없을 경우 wget 설치.</p>

<p>설치가 완료되면 서비스가 실행중인다 확인할 수 있다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service codedeploy-agent status
</code></pre></div></div>
<p>를 입력하였을 경우 <code class="language-plaintext highlighter-rouge">active(running)</code>문구를 확인할 수 있다. 
만약 확인이 되지 않을 경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service codedeploy-agent start
<span class="nb">sudo </span>service codedeploy-agent stop
</code></pre></div></div>
<p>start와 stop을 반복하여 확인할 수 있다..</p>

<p><br /></p>

<h3 id="파이프라인-구축">파이프라인 구축</h3>

<p>우선 AWS에서 파이프라인을 만들기전에<br />
애플리케이션에서 설정을해줘야하는 정보가 있다.<br />
설정 후 GitHub 레포지토리에 push해 놓으면 후에 파이프라인 구성완료 시<br />
자동으로 EC2로 빌드가 되어진다.</p>

<p><code class="language-plaintext highlighter-rouge">appspec.yml</code>,<code class="language-plaintext highlighter-rouge">buildspec.yml</code>파일을 프로젝트 하위폴더로 만들어 설정해 놓아야한다.<br />
<a href="https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html">AWS CodeDeploy hooks</a>, <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html">AWS CodeBuild reference</a>를 참조해 설정이 가능하다.<br />
그에 따른 여러 Script(.sh) 파일도 만들어 줘야한다.</p>

<p><br /></p>

<p>설정을 완료하였다면 AWS측을 설정해보자
우선 IAM 계정을 사용하고 있을 경우<br />
EC2 인스턴스의 IAM 역할 권한을 추가해줘야한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNHCZmULZC_buWOV0uETzML7F5yL9VNR0hj_Q4BV4gGNtv0GOCClWrzgXa-dtUzxqNLqn_WwwcpSwaMV_RmfKBf5nQxqw=w1347-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM1bpbtv0DDnd8H-7P6jP2brR474UmPVdMEFXnEfif64w1RL6X4FAttBZUzd8SRMg0-G4IbhFIgL0E9SilwKHxEh3JctA=w1347-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>AmazonS3FullAccess<br />
AmazonEC2RoleforAWSCodeDeploy<br />
AWSCodeDeployRole<br />
AmazonSSMFullAccess<br />
정책 생성을 진행 해주면 된다.</p>

<p>그리고 신뢰 관계 정책 설정에서</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM83eaHqKN9E2lXj13Vs4tHqQtA7pwGi-9gfttGhvNhZhUlChzPlKtzn90TDSUfHuueIgv0lRqhAbOB35wAVXDl5If0=w1347-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Service의 <code class="language-plaintext highlighter-rouge">"codedeploy.ap-northeast-2.amazonaws.com"</code>를 할당해주면 된다.</p>

<p><br /></p>

<p>그 다음엔 CodeDeploy에서 애플리케이션을 생성해주자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOCCMyhm1hmET_5cP4ljHyaJO7PsnSF7BHDYz2UDXIXk_bnHjHRXcJiInrmSFkwX5vihtTEAlXthho-aq2hznZ2WicsZw=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<p>그리고 CodePipeline에서 파이프라인을 생성해주면 된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPtKi60Y7GgJNZ-krPaDlb7pxQeTHn1rhOxGyNiRfip436OUWCtxR4xNpu-yETn1kF6Yod57iJmMKi50rXhxLMyQIHXsw=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>파이프라인을 만들때 Source 단계에서는 <br />
GiuHub에 연결해서 사용하면 된다.</p>

<p>이제 파이프라인 구성을 완료하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOgBdDghrM3cnjcID_cq7VNsyWqpOinvicT0MfJeSOpE0dVVs1zM986Cu6Jz9kQ7MW0j1X2amC1ego-aMHv2bM-NcG9WA=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 파이프라인이 실행이 완료된 것을 볼 수 있다.<br />
이제 우리가 Github에 push를 하는 순간</p>

<p>해당 내용이 EC2 인스턴스 서버에 빌드되는게<br />
자동화가 되었다는 사실 !!!</p>

<p>엄청 대단한 기술이다… 물론 알아야할 것도 엄청 많아서 난해했지만<br />
현재는 따라하는 단계만 마친 것 같다.</p>

<p><br /></p>

<h3 id="서버-환경-변수-설정">서버 환경 변수 설정</h3>

<p>기존에는 <code class="language-plaintext highlighter-rouge">.yml</code>, <code class="language-plaintext highlighter-rouge">.properties</code> 파일에 환경변수를<br />
설정하여 파싱해서 가져다 사용했었다.<br />
이제는 EC2에 서버가 배포되어있으니 AWS의 Parameter Store<br />
서비스를 이용하면 환경변수가 쉽게 설정이 가능하다.</p>

<p>우선 EC2에 배포하려는 프로그램에 설정해주자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="n">implementation</span><span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">cloud</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">cloud</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">aws</span><span class="o">-</span><span class="n">parameter</span><span class="o">-</span><span class="n">store</span><span class="o">-</span><span class="n">config</span><span class="err">'</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencyManagement</span> <span class="o">{</span> 
	<span class="n">imports</span> <span class="o">{</span>
		<span class="n">mavenBom</span> <span class="s">"org.springframework.cloud:spring-cloud-starter-parent:Hoxton.SR12"</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>build.gradle의 의존관계를 설정해주어야한다.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">aws</span><span class="pi">:</span>
  <span class="na">paramstore</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">prefix</span><span class="pi">:</span> <span class="s">/spring-boot-aws</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">be-88-MyCatlikesChuru</span> <span class="c1"># 리소스 이름을 작성합니다.</span>
    <span class="na">profileSeparator</span><span class="pi">:</span> <span class="s">_</span>
</code></pre></div></div>

<p>파라미터 스토어에서는 <code class="language-plaintext highlighter-rouge">/prefix/name/key</code>의 순서로 네이밍 규칙에 <br />
맞게 작성해야한다. name은 EC2 인스턴스이름과 동일하게 설정해주자.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">.yml</code>, <code class="language-plaintext highlighter-rouge">.properties</code>에 설정해 주었던<br />
환경변수는 EC2 파라미터 스토어에서 대체되니<br />
삭제하거나 주석처리를 하면 된다.</p>

<p>이제 AWS의 파라미터 스토어에서 파라미터를 생성해주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO32zl6JsLi9OZI8wmEopf7e19jrzKC-54eaufU8QdnSmQp_MyS-toExX9-gZKm2RPXwZFu4DMEF7NPDYuTNMPUmcJnvA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이름에는 네이밍 규칙을 넣어주면 되고 <br />
값에는 우리가 실제로 환경변수를 사용할 값을 넣어주면 된다.</p>

<p>예를들어 mysql을 사용하려는데 username을 설정한다고 가정하면<br />
<code class="language-plaintext highlighter-rouge">spring.datasource.username=admin</code>과 같은 형태로 <code class="language-plaintext highlighter-rouge">.properties</code>에  <br />
사용한다고 가정을 하였을 경우</p>

<p>이름 : <code class="language-plaintext highlighter-rouge">/spring-boot-aws/be-88-MyCatlikesChuru/spring.datasource.username</code><br />
값 : <code class="language-plaintext highlighter-rouge">admin</code><br />
과 같은 형태로 파라미터를 만들어 준다면<br />
우리가 EC2에 정상적으로 배포해둔 서버에 해당 환경변수가 적용될 것이다.</p>

<p><br /></p>

<hr />

<p>오늘은 이렇게 배포를 자동화하는 기술을 배워보았다.<br />
AWS에서 지원하는 파이프라인 구성을 통해<br />
EC2 인스턴스 빌드가 자동으로 되는 과정을 지켜보았고<br />
이번에 공부하면서 느낀건데… AWS에 대한 깊은 공부가<br />
정말 필요하다고 절실히 느꼈다.</p>

<p>Java와 Spring이 어느정도 익숙해진다면<br />
AWS 공부를 열심히 해볼 생각이다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 콩나물 김치찌개, 계란야채부침, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[배포 자동화 말그대로 배포 자동화란 기존에 배포를 위한 복잡한 작업을 클릭 혹은 명령어 입력을 통해 전체 배포 과정을 자동으로 진행하는 과정이다.]]></summary></entry><entry><title type="html">TIL) 배포 컨테이너 Docker</title><link href="http://localhost:4000/til/2022/12/06/til.html" rel="alternate" type="text/html" title="TIL) 배포 컨테이너 Docker" /><published>2022-12-06T00:00:00+09:00</published><updated>2022-12-06T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/06/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/06/til.html"><![CDATA[<h2 id="docker">Docker</h2>

<p>실제 선박의 컨테이너라함은 여러가지 물자들은 하나의 컨테이너에 싦어<br />
부피,인력,물자 이동 등 엄청난 장점을 가져왔다.</p>

<p>소프트웨어 측면에서도 배포하는 과정을 편하게 사용하고 여러 장점을 가지기 위해<br />
애플리케이션을 컨테이너화할 수 있는 도커가 등장했다.<br />
즉, 컨테이너 방식의 애플리케이션이라는 뜻은 실행환경에 <br />
구애받지 않고 실행시킬 수 있다는 뜻이다.</p>

<p>가장 많이 듣는 용어를 적어본다.</p>

<ul>
  <li>
    <p><strong>컨테이너</strong><br />
애플리케이션이 의존성, 네트워크 환경, 파일 시스템에 구애받지 않고<br />
도커라는 기술 위에 실행될 수 있도록 만든 애플리케이션 상자이다.<br />
즉, <strong>도커에 의해 관리/제공되는 애플리케이션 단위이다.</strong></p>
  </li>
  <li>
    <p><strong>이미지</strong><br />
모든 컨테이너는 이미지로 부터 생성된다.<br />
이미지를 이용해 여러개의 컨테이너를 생성할 수 있고, 애플리케이션 <br />
수평확장이 가능하다. 즉, <strong>도커 컨테이너를 생성하는데 사용되는 템플릿이다.</strong></p>
  </li>
  <li>
    <p><strong>레지스트리</strong><br />
이미지는 레지스트리에 저장된다. 대포적으로<br />
Docker Hub, Amazon ECR등이 있다.<br />
즉, <strong>도커 이미지를 저장하고 배포/공유하는데 사용한다.</strong></p>
  </li>
</ul>

<p><br /></p>

<h3 id="docker-컨테이너-방식의-장점">Docker 컨테이너 방식의 장점</h3>

<p><strong>1). 의존성 충돌 문제를 해결</strong><br />
컨테이너 기술을 바탕으로 한 컴퓨터 안에 여러대의 컨테이너가 있다.<br />
애플리케이션 실행 환경이 격리되어있다는 뜻이므로<br />
각자 고유의 의존성을 포함하고 있다.</p>

<p>그렇다면, 어떤 자원을 독립적으로 가지고 있는지 알아보자</p>
<ol>
  <li>프로세스<br />
-. 특정 컨테이너에서 작동하는 프로세스는 기본적으로 그 컨테이너 안에서만 액세스 가능<br />
-. 컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향 X</li>
  <li>네트워크<br />
-. 기본으로 컨테이너 하나에 하나의 IP 주소가 할당</li>
  <li>파일 시스템<br />
-. 컨테이너 안에서 사용되는 파일 시스템은 구획화 되어있다.<br />
그래서 해당 컨테이너에서의 명령이나 파일 등의 액세스를 제한 할 수 있다.</li>
</ol>

<p><br /></p>

<p><strong>2). 개발과 배포 환경을 일치 시켜준다.</strong><br />
Docker를 사용하면 OS에 상관없이 즉시 애플리케이션 실행 환경을 만들 수 있다.<br />
그리고 개발 컨테이너 위에서 진행할 경우, 모든 개발팀이 동일한 환경 하에<br />
개발을 진행할 수 있다.</p>

<p><strong>3). 수평 확장을 쉽게 해준다, 각 서버에 새로운 내용을 배포하기 쉽게 만들어준다.</strong><br />
컨테이너 기술의 가장 큰 장점은 실행 환경의 일치이다.<br />
엄청난 트래픽을 요구하는 애플리케이션들은 단하나의 서버가 아니라<br />
트래픽을 분산하기 위해 프록시 서버를 운영한다고 한다.</p>

<p>프록시 서버는 여러 대의 동일한 서버 중 한군데를 이용할 수 있도록 돕는데<br />
동일한 서비스가 여러 컴퓨터에서 작동하기위해서 편리하게 사용하는 기술이 컨테이너 기술이다.</p>

<p><br /></p>

<h3 id="docker-설치">Docker 설치</h3>

<p>현재 나는 MacOS를 사용하고 있기때문에<br />
<a href="https://docs.docker.com/desktop/install/mac-install/">Docker Mac install</a>를 접속해 도커를 설치할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOirwJaCgDYW20G-JPu9KXSWfoPXL55k_PPeZhnPzs4qxZUhExHL7cjPH110xQtywGE6J71t1n7aRJnz0k2XmPKfqNofg=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>도커 설치를 완료하면 위와 같은 애플리케이션 GUI 확인이 가능하다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
</code></pre></div></div>
<p>실제로 CLI로 버젼을 입력할 경우 정상적으로 설치되었으면<br />
현재 설치된 버전이 나올 것이다.</p>

<p><br /></p>

<h3 id="docker-사용전-명령어-보기">Docker 사용전 명령어 보기</h3>

<p>Docker GUI를 이용하지 않고<br />
<a href="https://docs.docker.com/engine/reference/commandline/container_run/">CLI</a>를 통한 연습을 진행해보려한다.</p>

<p>그전에 선행되어야하는 것이 명령어를 먼저 알아야한다.</p>

<h4 id="1-이미지-관련-명령어">1). 이미지 관련 명령어</h4>

<p>✅ 설치된 이미지 조회하는 명령어이다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image <span class="nb">ls</span>
</code></pre></div></div>

<p><br /></p>

<p>✅ 이미지를 설치하는 방법이다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image pull 이미지이름:tag
</code></pre></div></div>

<p><br /></p>

<p>✅ 설치되어 있는 이미지를 삭제하는 방법이다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image <span class="nb">rm </span>이미지이름
</code></pre></div></div>
<p>만약 이미지를 컨테이너에 사용할 경우 삭제가 불가능하다.<br />
컨테이너를 종료시키고 삭제 후 에 이미지를 삭제해야한다.</p>

<p><br /></p>

<h4 id="2-컨테이너-관련-명령어">2). 컨테이너 관련 명령어</h4>

<p>✅ 설치되어 있는 이미지를 삭제하는 방법이다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container run <span class="nt">--name</span> 컨테이너이름 <span class="nt">-p</span> 8080:80 이미지이름
</code></pre></div></div>
<p><strong>컨테이너 이름</strong>은 우리가 정하면 된다.</p>

<p><strong>이미지 이름</strong>은 설치한 이미지의 이름을 적어주면되는데<br />
만약 해당 이미지으 tag가 있다면 <code class="language-plaintext highlighter-rouge">이미지이름:tag</code> 를 적어줘야한다.<br />
여기서 tag라 함은 <code class="language-plaintext highlighter-rouge">latest</code>, <code class="language-plaintext highlighter-rouge">2.0</code>이라든가의 버젼을 의미한다.</p>

<p>또한 포트번호는 8080:80이라고 적어두었는데<br />
첫번쨰 포트는 내부포트이고 두번쨰 포트는 외부포트이다.<br />
외부에서 통신을하기 위한 통신 포트를 요청하면<br />
컨테이너의 내부포트로 forwarding 하겠다는 의미이다.<br />
즉, 8080포트로 요청할 경우 80으로 포트포워딩 하겠다는 뜻이다.<br />
<a href="https://ooeunz.tistory.com/104">Port Forwarding 참고 - ooeunz님 블로그</a></p>

<p><br /></p>

<p>✅ 컨테이너 리스트 출력</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container ps <span class="nt">-a</span>
</code></pre></div></div>

<p><br /></p>

<p>✅ 실행중인 컨테이너 리스트 출력</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">ls</span>
</code></pre></div></div>
<p>컨테이너 리스트 출려과는 다르다. 현재 start되어있는 컨테이너만 출력되어진다.</p>

<p><br /></p>

<p>✅ 컨테이너 실행</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container start 컨테이너이름
</code></pre></div></div>
<p>컨테이너를 백그라운드 상태로 실행시킬 수 있는 명령어이다.</p>

<p><br /></p>

<p>✅ 컨테이너 중지</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container stop 컨테이너이름
</code></pre></div></div>
<p>살행 중인 컨테이너를 종료하는 명령어이다.</p>

<p><br /></p>

<p>✅ 컨테이너 삭제</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">rm </span>컨테이너이름
</code></pre></div></div>
<p>컨테이너를 중지시킨다음, 해당 컨테이너가 필요없을 경우<br />
해당 명령얼 컨테이너를 삭제할 수 있다.</p>

<p><br /></p>

<p>✅ 컨테이너 내부 접근</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> 컨테이너이름 bash
</code></pre></div></div>
<p>선택한 컨테이너를 bash CLI로 접근할 수 있다.</p>

<p><br /></p>

<p>✅ 현재 폴더의 파일을 컨테이너의 경로에 복사하기</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">cp</span> ./ 컨테이너이름:/경로
</code></pre></div></div>

<p><br /></p>

<p>✅ 구동중인 컨테이너를 지정해 이미지로 만들기</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container commit 컨테이너이름 이미지이름:tag
</code></pre></div></div>

<p><br /></p>

<p>✅ 이미지 빌드하는 방법</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">--tag</span> 이미지이름:tag <span class="nb">.</span> 
</code></pre></div></div>
<p>Dockerfile을 만들고, Dockerfile 대로 이미지를 build하는 방법이다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM httpd:2.4 
COPY ./ /usr/local/apache2/htdocs/
</code></pre></div></div>
<p>와 같은 형식으로 Dockerfile을 만든다.<br />
위에 내용을 해석하자면 베이스 이미지르 httpd로 사용<br />
현재경로에(./) 있는 파일들을 특정경로(/usr/local/apache2/htdocs/)로 이동한다.</p>

<p>이렇게 빌드된 이미지를 이제 컨테이너로 사용할 수 있다.</p>

<p><br /></p>

<h3 id="docker-사용해보기">Docker 사용해보기</h3>

<p>순서는 레지스트리에서 이미지를 받고 컨테이너를 만들면된다.<br />
그리고 해당 컨테이너 주소로 접속해 우리가 하려고하는 <br />
애플리케이션의 테스트가 가능하다.</p>

<h4 id="hello-docker">Hello docker</h4>
<p>우선 만들어 놓은 프로젝트가 없으니<br />
간단한 이미지 부터 사용해보려한다.</p>

<p><a href="https://hub.docker.com/">dockerhub</a>에서 여러가지 이미지를 받을 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOVWTMjVY1qXqFAq126SrK8teCYWrYjuD9AUm4P7X5-jZFdC34n7mts1L9tvQHKnubRGziozwnzaI33PP8bx462unP0xQ=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그 중 귀여운 고래화면을 띄워주는 <code class="language-plaintext highlighter-rouge">docker/whalesay</code>를 검색해보자<br />
검색해보면 오른쪽에 커맨드로 도커를 가져올 수 있는 명령어가 있고<br />
사용 방법에 대한 내용이 쭉 나와 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull docker/whalesay
</code></pre></div></div>
<p>를 입력해주면 해당 이미지를 다운 받는다</p>

<p>그리고 컨테이너를 시작시켜주는 명령어를 사용하면 된다.<br />
해당 이미지에선 사용하는 방법을 설명해준다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run docker/whalesay cowsay boo
</code></pre></div></div>
<p>를 입력하게 되면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> _____
&lt; boo <span class="o">&gt;</span>
 <span class="nt">-----</span>
    <span class="se">\</span>
     <span class="se">\</span>
      <span class="se">\</span>
                    <span class="c">##        .</span>
              <span class="c">## ## ##       ==</span>
           <span class="c">## ## ## ##      ===</span>
       /<span class="s2">""""""""""""""""</span>___/ <span class="o">===</span>
  ~~~ <span class="o">{</span>~~ ~~~~ ~~~ ~~~~ ~~ ~ /  <span class="o">===</span>- ~~~
       <span class="se">\_</span>_____ o          __/
        <span class="se">\ </span>   <span class="se">\ </span>       __/
          <span class="se">\_</span>___<span class="se">\_</span>_____/
</code></pre></div></div>
<p>이러한 귀여운 고래 모습을 볼 수 있다.</p>

<p>이제 간단한 이미지를 다운받아 사용까지 해보았다.<br />
삭제를 하려면 컨테이너에서 먼저 삭제한다음<br />
이미지를 삭제해주면 된다.</p>

<p><br /></p>

<h4 id="httpd-사용해보기">httpd 사용해보기</h4>

<p>이제 본격적으로 사용해보자 homebrew <code class="language-plaintext highlighter-rouge">httpd</code>를 사용하듯<br />
Apache HTTP Server인 <code class="language-plaintext highlighter-rouge">httpd</code> 이미지를 이용해<br />
웹서버를 띄워 볼 수 도 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container run <span class="nt">--name</span> <span class="nb">test</span> <span class="nt">-p</span> 818:80 httpd
</code></pre></div></div>
<p>test라는 이름의 컨테이너로 818포트를 80포트로 포워딩하게 해두었다.<br />
httpd의 기본포트는 80번으로 설정되어있다.</p>

<p>해당 컨테이너를 실행한 후에 <code class="language-plaintext highlighter-rouge">http://localhost:818</code>로 접속하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNFNMWOpsHkODxYQxJgNRxLj1AeHg2F0fO44DfPsxGt3X1MLhhs0yKVwVkF5SiESv9ODhQJ4xY0Mpgki2MHFCrIEQgc=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>기존에 Apache HTTP Server를 띄우는 것처럼<br />
기본 html인 It works!가 확인이 가능하다.</p>

<p><br /></p>

<h4 id="httpd-서버에-프로그램-올리기">httpd 서버에 프로그램 올리기</h4>

<p>이제 여기서 우리가 해당 컨테이너에 프로그램을 넣을 수 있다.<br />
예를 들어 <code class="language-plaintext highlighter-rouge">팩맨 게임</code>을 해당 웹서버에 올린다고 가정하자.<br />
(해당 게임 프로그램은 <a href="https://github.com/daleharvey/pacman">pacman github</a>에서 클론 받을 수 있다.)</p>

<p>방법은 2가지 정도가 있다.<br />
첫번째 방법은 현재 컨테이너에다가 파일을 복사하는 방법과<br />
두번째 방법은 Dockerfile을 이용해 이미지를 다시만든다음에 컨테이너로 만들면된다.</p>

<p>첫번째 방법 부터해보자<br />
현재 만들어둔 test 컨테이너 안에 httpd 경로에 파일을 복사하면된다.<br />
실제로 컨테이너를 접속해보면 <code class="language-plaintext highlighter-rouge">/usr/local/apache2/htdocs/</code>경로에<br />
<code class="language-plaintext highlighter-rouge">index.html</code>파일이 있는 것을 볼 수 있다. 해당 파일은 It works! 파일이다.<br />
해당 경로에 내가 올리려는 <code class="language-plaintext highlighter-rouge">팩맨 게임</code>의 <code class="language-plaintext highlighter-rouge">index.html</code>과 여러 파일들을 넣어주면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">cp</span> ./ <span class="nb">test</span>:/usr/local/apache2/htdocs/
</code></pre></div></div>
<p>이제 내가가지고 있는 프로그램 파일 경로로 접속해<br />
해당 명령어를 입력해주면 해당 경로에 있는 파일들이<br />
전부 test 컨테이너의 해당 경로로 복사되어진다.</p>

<p>그리고 다시 컨테이너를 시작해준다면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container start <span class="nb">test</span>
</code></pre></div></div>
<p>백그라운드로 실행 될 것이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNlwmnQmaBw58r6RaXn6r0cqk2S5p1PNxjI-p9i_FN0dP0id_Gk2udyi8M6KHtwMnNn9bcC67lLPdIL1OD4gr_HuSlLtA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><code class="language-plaintext highlighter-rouge">팩맨 게임</code>이 실제로 동작하는 것을 볼 수 있다.</p>

<p><br /></p>

<p>두번째 방법으로는
<code class="language-plaintext highlighter-rouge">팩맨 게임</code>폴더에 <code class="language-plaintext highlighter-rouge">Dockerfile</code>이라는 <br />
이름의 파일을 만든다. 그리고 해당 파일 안에는</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM httpd:2.4
COPY ./ /usr/local/apache2/htdocs/
</code></pre></div></div>
<p>와 같은 내용을 넣어준다. (설명은 명령어에서 설명했으므로 생략)</p>

<p>그리고 build 명령어를 이용해서 이미지를 빌드할 수 있다.<br />
명령어를 실행할때는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 경로에서 입력해야한다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">--tag</span> pacman:2.0 <span class="nb">.</span>
</code></pre></div></div>
<p>build 명령어를 실행하면, 이미지 파일이 생성되고<br />
해당 이미지 파일로 이제 컨테이너를 실행시키면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> pacmangametest <span class="nt">-p</span> 818:80 pacman:2.0
</code></pre></div></div>

<p><br /></p>

<p>이렇게 CLI로 명령어로 docker를 사용하는 방법을<br />
간단하게 알아보았다. 실제로 우리가 만든 이미지와 컨테이너들을<br />
처음에 설치했던 GUI에서 확인이 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPo7gNUnHKL8zeCRsYvKbyYYsOo7MetSL7gXnBiWBaVDpwCNjPW8nF03SW8upgiGOE4S8bBqLdOrxDnnkH9PJTQvp9lWA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<hr />

<p>오늘은 이렇게 짧지만 docker를 공부했다.<br />
계속 연습하다보니까 어느정도 이해가 되었다.<br />
이렇게 이미지로 만들어 팀원들과 배포환경을 동일하게<br />
사용할 수 있을 것 같다.</p>

<p>이제 곧 프로젝트인데 프로젝트할 때 적용해보도록 해봐야겠다!!</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 삼첩분식</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[Docker]]></summary></entry><entry><title type="html">TIL) Cloud 운영 환경 구성 2</title><link href="http://localhost:4000/til/2022/12/05/til.html" rel="alternate" type="text/html" title="TIL) Cloud 운영 환경 구성 2" /><published>2022-12-05T00:00:00+09:00</published><updated>2022-12-05T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/05/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/05/til.html"><![CDATA[<p>저번주에는 기본적인<br />
Cloud 운영 환경에 대한 구성들을 배워 보았다.<br />
이번 공부에서는 3티어 아키텍처 형태로 배포하는 방법을<br />
배울 것이고, 저번주에 EC2에 서버를 배포해보는 것까지 해봤었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMCqrjaGSYLYkne25hlMNNSGrxxCwtWjwIW1qahU8iTVkaJk3lgQwrF-ArVtHMFQcmUuojJ-JIIdF3Sujk5F4ZZuD8BHQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그 중에서도 우리는 EC2 인스턴스에<br />
우리가 만든 Spring 프로젝트를 build하여<br />
서버에 배포해보는 것까지 진행 했었다.</p>

<p>오늘은 클라이언트(S3) 측과 데이터베이스(RDS) 측을 알아보자</p>

<p><br /></p>

<h3 id="클라이언트-배포">클라이언트 배포</h3>

<p>우선 클라이언트의 프로젝트를 build하는 방법이<br />
여러가지가 있는 것 같다. (java와 마찬가지로)</p>

<p>그 중 터미널의 node를 이용해 build하는 작업을 진행해보자<br />
(참고로 MacOS를 사용중)</p>

<p><br /></p>

<h4 id="1-프로젝트-build">1. 프로젝트 build</h4>

<p>먼저 <a href="https://github.com/nvm-sh/nvm#install--update-script">nvm 설치</a>를 진행해주자.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="nt">-qO-</span> https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash
</code></pre></div></div>
<p>공식 사이트에 있는 최신 버젼을 설치해주면 될 것 같다.<br />
만약, wget을 찾을 수 없다는 알람이 뜬다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>wget
</code></pre></div></div>
<p>wget을 패키지 관리자인 homebrew로 설치하면 된다.</p>

<p>짤막한 지식과 검색을 통한 지식으로 정리를 해보자면<br />
NVM은 Node Version Manager로 Node.js의 버전을 관리해주는 도구이다.  <br />
Node.js는 브라우저 내에서 말고도 다른 환경에서도 JavaScript를 실행 시킬 수 있게<br />
도와주는 실행창, 실행 환경이라고한다. (크롬의 js해석 엔진인 V8 엔진을 이용)</p>

<p>그럼 이제 nvm 설치가 완료되었다면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm <span class="nt">--version</span>
</code></pre></div></div>
<p>명령어로 설치가 되었는지 확인해주자.</p>

<p>이제 nvm이 설치되었으니 <a href="https://nodejs.org/en/">node.js 설치</a>를 할 수 있다.  <br />
해당 사이트에서 버전 확인이 가능하다.</p>

<p>원하는 버전을 설치해줘도 되지만.. 16버전을 이용했을 때<br />
오류가 없었기에</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm <span class="nb">install </span>16
</code></pre></div></div>
<p>이라고 입력해주면 16버전이 설치된다.</p>

<p>최신 버전을 설치하고 싶을 경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm <span class="nb">install</span> <span class="nt">--lts</span>
</code></pre></div></div>
<p>를 입력해주면 최신버전이 설치가 된다.</p>

<p>만약 설치를 여러개 하였을 때, 버젼을 변경해서 사용하고 싶을 경우<br />
먼저 버전을 확인하고 싶으면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm list
</code></pre></div></div>
<p>명령어로 현재 설치된 버전이 확인된다.</p>

<p>그리고 버전을 변경하고 싶을 경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm use 16
</code></pre></div></div>
<p>과 같은 식으로 현재 설치된 버전 중 선택해서 nvm use를 사용하면 변경된다.</p>

<p><br /></p>

<p>이제 실제로 클라이언트를 AWS를 이용해 배포해보자<br />
우선 터미널로 우리가 만든 클라이언트 폴더에 접속한다.</p>

<p>이동완료후 클라이언트 의존성 모듈을 설치해야한다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span>
</code></pre></div></div>
<p>npm은 Node Package Manager로 Node.js로 만들어진<br />
프로그램을 쉽게 설치 혹은 여러기능들을 해주는 것이라 이해하면 쉬울 것 같다.</p>

<p>설치가 완료되었으면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nt">-v</span>
</code></pre></div></div>
<p>명령어로 설치된 버전을 확인할 수 있다.</p>

<p><br /></p>

<p>이제 이 패키지 매니저로 우리는 build 명령을 실행할 것 인데<br />
이전에 우리는 처음에 보았던 이그림을 볼 필요가 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMCqrjaGSYLYkne25hlMNNSGrxxCwtWjwIW1qahU8iTVkaJk3lgQwrF-ArVtHMFQcmUuojJ-JIIdF3Sujk5F4ZZuD8BHQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>현재 클라이언트와 서버가 연결되기 위해서는<br />
build하기 전에 EC2의 주소를 이용해 환경변수로 설정해<br />
연결을 해준 후 build를 진행해야 우리의 EC2 인스턴스와 연결되는 것 같다.</p>

<p>아직 클라이언트 측의 구성이 정확히 어떻게 되어있는지 이해가 가진 않았다.<br />
하지만 React에서 환경 변수를 사용할 경우 <code class="language-plaintext highlighter-rouge">.env</code>파일을 이용해<br />
보안과 유지보수에 용이하게 사용하는 것 같다. (<a href="https://carmack-kim.tistory.com/111">ENV? - 출처: carmack-kim님 블로그</a>)</p>

<p>우선 코드스테이츠 측에서 배포용으로 만들어준<br />
클라이언트 프로그램에 <code class="language-plaintext highlighter-rouge">.env</code>파일에 EC2 경로를 추가해줘야한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNOxhLDZ27Sr73PjkWiOEuy7fxEbUeO8PExbopcMOhYwIE9voaaFWfTIfwUI1LRemjgPfidns6Qnaawzke-k1y8su_mvg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>내 EC2 인스턴스의 <code class="language-plaintext highlighter-rouge">퍼블릭 IPv4 DNS</code>를 입력해주면 된다.<br />
환경 변수 설정이 끝났으면 이제 <code class="language-plaintext highlighter-rouge">npm</code>을 이용해 build를 진행해주면된다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm run build
</code></pre></div></div>
<p>를 입력해주면 build가 되어질 것이고</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMm2-cXyHyX_Dka-3eOFxiBi9Shvt6NpdXGyr4eeNvSiqYakRmHEw2IsC8VT2TjTHetmajHF85bfA8RoFaMV30SGUGA_Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><code class="language-plaintext highlighter-rouge">Compiled successfully</code>가 콘솔에 확인된다면<br />
정상적으로 완료되었을 것이고 build 폴더가 생겼을 것이다.</p>

<p>이제 클라이언트 프로그램이 build가 되었으니<br />
AWS의 S3 버킷에 올리기만하면 된다.</p>

<p><br /></p>

<h4 id="2-build-파일-업로드">2. build 파일 업로드</h4>

<p>여기서 버킷은 만들어져있다고 가정하고</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMt5DZC0u-iy00YbD24vOXQHSgoZuuE3TaqTJ9DKfV-rmiIHkzsemBccNULT5kX_op5CnQacIHp5zQqVrlpkoHVq0Hpvg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>만들어진 버킷을 보면 여러가지 확인과 설정을 할 수 있다.<br />
객체에는 우리가 build한 파일을 업로드해주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gP--JcVN_ro93rs0B8hRPIIlA8cCBE6S6EwLJ0t8J6FoCOkT2t2sGTXUypnYqIlnkgbzpmm2hhe5bT29_pdZrIg0EFejQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<h4 id="3-정적-웹사이트-호스팅-및-정책-설정확인">3. 정적 웹사이트 호스팅 및 정책 설정확인</h4>

<p>속성에서 정적 웹 사이트 호스팅 편집이 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMuwTO1DRQvt3Cq_twhIxiSqw1TII2qdRKLPP1A5l32tOAWB9D4xT2R0aajpK14WWMR1RF9fp24Z_JH1hvhgchn4Luc=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>활성화를 눌러준 후 여러 설정을 할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMRTfdAd-MrGvJWcOs8k6c8JsWUMENpfp8NHUYwB-wB_CcLPM9vI8MpR8NZFGUh9-MO4Pj_Jo_rIL98SAsTcQe0dO4pvw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 변경 저장을하면 엔드포인트를 확인할 수 있다.<br />
해당 엔드포인트로 접속 시 우리가 빌드한 html을 확인할 수 있다.<br />
하지만 만약 퍼블릭 엑세스 활성화를 하지 않았다면</p>

<p>403 Forbidden 화면을 보게 될 것이다.<br />
아래에서 설정해보자</p>

<p><br /></p>

<h4 id="4-퍼블릭-엑세스-활성화">4. 퍼블릭 엑세스 활성화</h4>

<p>권한 텝에서 먼저</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOySHGyNBeD5ROwQcYrc7Q-LryyL0GpHOOWLW9cpO8IoJG2o0s68sAqdvbZYp07vh5vzgXQ4tz4Wx5FnXTVYJ-arLdYHg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>모든 퍼블릭 엑세스 차단 체크박스를 해제하고<br />
변경 사항을 저장해준다.</p>

<p>그리고 버킷 정책에서<br />
편집 -&gt; 정책 생성기를 눌러</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gORyh2hy9R7NQi5ZFdxelWkB9PXqXFFkf5od8ptjyq_M2q6gMll9UJC8QAh0CWB0jNWXzOzEnN43dPeJJbeI9uPJFow=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>정책에 대한 내용을 적어준다.<br />
해당 부분은 추후에 어떤 정책인지에 대한 내용은<br />
어드벤스한 공부가 필요해보인다..</p>

<p>우선 위와 같이 입력 완료 후<br />
하단에 Add Statement를 눌러주면 Json 형태로 객체가 하나 나온다.<br />
해당 코드 값을 복사해 정책 코드란에다가 붙여 넣어주면 된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO4sb2RQfnC9UAo9e3mqbNuAUAYCqlGSgh9Xi-0UL5QX5vFoKRL5G--penSCYSkN1KGUQN9LzKuR-cfxL8-qPOIjrhT=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 변경 사항 저장을 눌러주면<br />
해당 버킷에 대한 정책이 적용되어 퍼블릭 엑세스가 가능해진다.<br />
아마 어디서든 접근이 가능하게 만들어진 것 같다.</p>

<p>우선 이렇게 클라이언트에 배포를 하고 정책을 설정에 권한 부여를<br />
할 수 있다는 흐름만 이해해야할 것 같다.</p>

<p>이제 정상적으로 엔드포인트에 접속하면 우리가 만든 화면을 볼 수 있다.<br />
여기서 알아둬야할 점은 클라이언트 S3에 설정이 끝났을 뿐<br />
EC2에서는 S3의 엔드포인트를 config.domain에 설정해줘야한다.<br />
설정해보기전에 RDS먼저 셋팅을 진행해보자</p>

<p><br /></p>

<h3 id="데이터베이스-연결">데이터베이스 연결</h3>

<p>이제 RDS 인스턴스를 생성하고 연결해보자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPt7L85pyOiBzvoUv4AoWFQRcZrAeTXi1e88euqY0WZwdeBy-fExoGosLSe_fFHmiIRcbyGesHL6tk9uH-P1LcPtRPHMQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>상단에서 RDS를 검색하여 데이터베이스 생성을 눌러준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN269A-5fP5DuTNlzYOxjstGaW4ZQ7LhDuRqYLKO0zE0bSCrP8VS9z6hcT9CNfpacjfrb1_r44aoGEjD-HkeYCIOm5dxQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>사용하려는 데이터베이스의 엔진을 선택 !<br />
나는 MySQL을 사용</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gORLVLuS8ordfLtooWUbgVapIf3PXVhjfSzClCSkdgFuaSgubU5LQwJs1HAIUh0GmqIBEOcCvuXN2pxthcBLJQpCtxFeA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>템플릿은 프리티어로 설정했다. 프리티어로 설정하면<br />
MySQL의 db.t2.micro 인스턴스는 750시간이 무료사용 가능한 것 같다.<br />
<a href="https://aws.amazon.com/ko/rds/free/">참고 - AWS 프리티어</a></p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPMDaskil2A9TqVUKLCShge25ti9mtf2nQUp67wJyOgx7ow6BFZNJQ-S1JUZAEjk_aqGqqo_ReFq4R1pTVp12HqdrnhGQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>여기서 이제 우리가 기억해야하는 부분이 나왔다.</p>

<p>✅ 마스터 사용자 이름과 마스터 암호는<br />
나중에 DB에 접근할때 꼭 필요한 값이니 기억해두거나<br />
어딘가에 저장해두자 !</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOqZjz97jIYND5PWh2kLo8O1rrpMicafKcPaDK7e4aOHR27d0apBQl3NJJ2G-ZTCiuTxoZ8wHnQ1MjwgQKaNaENBCUZBg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위에서 얘기했던 무료로 사용하기 위해 해당 옵션으로 설정</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOQ9Fc1p6L13bXI707a9Csgcs0oyQWQQvA7c4ZJs5x248-Mie6dXx8AZ04E_4_7oQjDmYuqy2Z0aixPrjjEg6wa--G5gg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>퍼블릭 엑세스는 허용으로 해준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMUDem6XIZCQA8hwXlATX6_JFFwo6w0ZNGrodOWnnmxjprmpjBmv1DKnJxcr3PGrahMDy_sVeqWftBU84OAozCd_WnXkQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 데이터 베이스를 사용하기 위한<br />
포트번호를 설정해둔다. 기본값은 3306이고<br />
13306으로 변경해서 사용하려고 변경했다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOFFsQrJPtaKbAFAE6XirmNp2zBlyHRpgE4iOm9Cn1TZsxF6NHQU6N1PLVBSL-7Ay3Hyd6SiR5MrJNV7wEIeACkiiUz6w=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>추가 구성을 눌러<br />
데이터 베이스의 이름을 설정해줄 수 있다.<br />
이름을 지정한대로 후에 조회할때<br />
해당 데이터 베이스 이름으로 조회가 된다. (test라고 지정했다고 가정하자)</p>

<p><br /></p>

<p>이제 모든 설정은 끝났으니<br />
맨 하단에 데이터베이스 생성을 눌러 만들어주자<br />
데이터베이스가 생성이 완료되면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN8tsT3QpYd684mkxbVNM6eWBUfuilsIcfBYaBjqCZfG4awLWyKRCR2NWeH9y4tslTrOXyOUDOfz2Mc7vWUhn6pvYEz=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>엔드 포인트와 설정했던 포트가 확인된다.<br />
이제 우리는 이 데이터베이스로 EC2에서 접근을하면 된다.</p>

<p>접근하기 이전에 정말로 정상적으로 동작되는지 확인해보고 싶다면<br />
터미널로 확인이 가능하다.</p>

<p>이전에 homebrew를 통해 MySQL을 설치했었다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>mysql
</code></pre></div></div>

<p>MYSQL이 정상적으로 설치가 완료되었다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql <span class="nt">-u</span> <span class="o">[</span>마스터 이름] <span class="nt">--host</span> <span class="o">[</span>엔드 포인트 주소] <span class="nt">-P</span> <span class="o">[</span>포트 번호] <span class="nt">-p</span>
</code></pre></div></div>
<p>이렇게 입력해주면 터미널로 mysql 접속이 된다.</p>

<p>예를 들어 데이터베이스 만들때 생성했던 정보가 아래와 같다고 가정해보자</p>

<p>마스터 이름 : admin<br />
마스터 비밀번호 : 1234<br />
데이터 베이스 엔드포인트 : be-88-mycatlikeschuru.c0nwl8c1futc.ap-northeast-2.rds.amazonaws.com</p>

<p>위와 같다고 가정할 때 아래와 같이 터미널에 명령을 실행시켜주면 된다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> mysql <span class="nt">-u</span> admin <span class="nt">--host</span> be-88-mycatlikeschuru.c0nwl8c1futc.ap-northeast-2.rds.amazonaws.com <span class="nt">-P</span> 13306 <span class="nt">-p</span>
</code></pre></div></div>
<p>위와 같이 입력하면 비밀번호를 입력라고 나올텐데<br />
우리가 설정했던 마스터 비밀번호 1234를 입력해주면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMOglrCiBEQQTzd9iNGlQLu4azD8EDI_e2QjmV4gPddeD7GCX8znn1b6L0BZSRTPu4ssWWyEg4vu12DNRtZF3rLBTBW=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 mysql에 접근할 수 있는 것을 확인 할 수 있다.<br />
실제로 <code class="language-plaintext highlighter-rouge">show databases;</code>를 입력해서<br />
우리가 데이터베이스를 만들때 추가구성에서 넣었던 이름인<br />
<code class="language-plaintext highlighter-rouge">test</code> 데이터베이스가 있는 것을 확인할 수 있다.</p>

<p>이제 정상적으로 데이터베이스가 작동된다는 것도 확인하였고<br />
이제 EC2에서 S3와 RDS를 연결해줘야한다.</p>

<p><br /></p>

<h3 id="클라이언트---서버---db">클라이언트 - 서버 - DB</h3>

<p>위에서 클라이언트와 데이터베이스까지 생성하고 설정까지 끝냈다.</p>

<p>EC2는 생각보다 간단하다.<br />
여태까지 우리가 많이 설정해왔던 방식이고 익숙하기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">.yml</code>파일이거나 혹은 <code class="language-plaintext highlighter-rouge">.properties</code>파일에 설정해주면된다.<br />
<code class="language-plaintext highlighter-rouge">.properties</code>파일로 만들었으니 해당 기준으로 적어본다.</p>

<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.jpa.database</span><span class="p">=</span><span class="s">mysql</span>
<span class="py">spring.jpa.database-platform</span><span class="p">=</span><span class="s">org.hibernate.dialect.MySQL5InnoDBDialect</span>
<span class="py">spring.datasource.url</span><span class="p">=</span><span class="s">jdbc:mysql://[AWS RDS 엔드포인트]/test?useSSL=false&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span>
<span class="py">spring.datasource.username</span><span class="p">=</span><span class="s">[RDS 마스터 이름]</span>
<span class="py">spring.datasource.password</span><span class="p">=</span><span class="s">[RDS 마스터 비밀번호]</span>
<span class="py">spring.datasource.driver-class-name</span><span class="p">=</span><span class="s">com.mysql.cj.jdbc.Driver</span>
<span class="py">config.domain</span><span class="p">=</span><span class="s">[AWS S3 엔드포인트]</span>
</code></pre></div></div>
<p>위에 처럼 이제 우리가 모두 알 수 있는 정보다</p>

<p>RDS를 만들었기에 엔드포인트를 알 수 있고<br />
마스터 이름과 비밀번호도 우리가 생성했다.</p>

<p>그리고 S3와 연결하기 위해 즉, 클라이언트와 연결하기위해<br />
AWS S3 엔드포인트를 설정해주면 클라이언트에서<br />
API 요청이 오면 이제 정상적으로 EC2 서버에서 작성한 프로그램대로<br />
동작하는 모습을 확인할 수 있을 것이다.</p>

<p><br /></p>

<hr />

<p>이렇게 아주 기초적인 3티어 아키텍처로<br />
인스턴스를 만들어서 배포를 진행 해보았다.</p>

<p>배포하는 과정에 엄청 공부할게 많구나라고 느꼈다.<br />
지금은 거의 따라하는 수준이지만… 나중에는 실제로 운영을하려면<br />
입맛에 맞게 변경하고 관리를 해야하기 때문에 AWS에 대한<br />
공부가 필요해 보였다.</p>

<p>어제 오늘 이렇게 배포를 해보면서 대략적인 감을 익혔고<br />
같이 페어했던분이랑 너무 재밌게해서<br />
더 오래 기억에 남을 것 같다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김치찌개, 스팸계란부침, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[저번주에는 기본적인 Cloud 운영 환경에 대한 구성들을 배워 보았다. 이번 공부에서는 3티어 아키텍처 형태로 배포하는 방법을 배울 것이고, 저번주에 EC2에 서버를 배포해보는 것까지 해봤었다.]]></summary></entry></feed>