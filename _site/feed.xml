<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-09T15:44:03+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">LeeJellan</title><subtitle>안녕하세요!🙂 IT,여행,기타 등 기록을 남기기위한 블로그 입니다 !</subtitle><author><name>LEE JAEHYEOK</name></author><entry><title type="html">TIL) Cloud 운영 전략</title><link href="http://localhost:4000/til/2022/12/09/til.html" rel="alternate" type="text/html" title="TIL) Cloud 운영 전략" /><published>2022-12-09T00:00:00+09:00</published><updated>2022-12-09T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/09/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/09/til.html"><![CDATA[<h3 id="proxy-server">Proxy Server</h3>

<p>프록시 서버는 클라이언트가 서버와 소통할 때<br />
서버에 바로 접근하지 않고 자신을 통해 서버에 접근할 수 있도록<br />
해주는 대리 서버라고 생각하면 간단하다.</p>

<p><strong>1). Forward Proxy</strong></p>

<p>클라이언트 가까이에 위치한 프록시 서버다.<br />
클라이언트를 대신해 서버에 요청을 전달해준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMnENrT4W97MGhsCoY41GXXR2exz07o-Ftd6n5xNT5FsDCQA2-bKk1EkIPg1xG3Ziuonj4jBh9yFy3kLW35p_mYG1d7=w1920-h921" alt="image" class="align-left" style="max-width: 80%" /></p>

<p>장점</p>
<ul>
  <li>캐싱을 통해 빠른 서비스 이용이 가능하다</li>
  <li>보안 (서버에서 프록시서버 IP를 받기때문에 클라이언트 IP를 숨길 수 있다)</li>
</ul>

<p><br /></p>

<p><strong>2). Reverse Proxy</strong></p>

<p>서버 가까이에 위치한 프록시 서버다.<br />
서버를 대신해서 클라이언트에 응답을 제공해준다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN3VUWC1TvwBt7n1ovAf-TPeX_VITPkt4aYr7_Nuf273yVBYeaq0oUo5sHfd-Npoe-w3HAY6kaY792Baqa5L01NYcYW=w1920-h921" alt="image" class="align-left" style="max-width: 80%" /></p>

<ul>
  <li>분산처리 (여러대의 서버로 요청을 나누어 전달 후 처리, ex) 로드밸랜서)</li>
  <li>보안 (클라이언트에게 서버 IP가 노출되지 않는다)</li>
</ul>

<p><br /></p>

<h3 id="load-balancer">Load Balancer</h3>
<p>로드 밸런서는 서버에 가해지는 부하(Load)를 분산(Balance) 해주는<br />
장치 또는 기술을 통칭한다.</p>

<p>하나의 서버에 클라이언트의 잦은 요청이 있으면<br />
서버의 과부하가 온다. 과부하로 인해서 서버가 원할하게 서비스를 제공하지<br />
못하는 경우가 발생하기 때문에, 이와 같은 문제를 해결하기 위한<br />
로드 밸린스 방식으로는 크게 2가지가 존재한다.</p>

<p><br /></p>

<p><strong>✅ 로드 밸런서 방식</strong></p>

<p><strong>1). Scale up</strong><br />
물리적으로 서버의 사양을 높이는 하드웨어적 방법이다.<br />
서버 수를 늘리지 않고 프로그램 구현있어 변화가 필요없다는 장점이 있다.</p>

<p>하지만 굉장히 높은 비용이 발생하고, 하드웨어의 업그레이드는<br />
한계가 있다는 단점이 있다.</p>

<p><strong>2). Scale out</strong><br />
서버의 갯수를 늘려 서버의 줄 부하를 분산시키는 방법이다.<br />
많은 요청이 오더라도 여러대의 서버가 나눠서 처리를 하기 떄문에<br />
서버의 사양을 높이지 않고도 비교적 저렴한 방법으로 부하를 처리할 수 있다.</p>

<p><br /></p>

<p><strong>✅ 로드 밸런서 알고리즘</strong></p>

<p><strong>1). 라운드로빈 방식 (Round Robin Method)</strong><br />
서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식</p>

<p><strong>2). 가중 라운드로빈 방식 (Weighted Round Robin Method)</strong><br />
각각의 서버마다 가중치를 매기고 가중치가 높은 서버에 클라이언트 요청을 우선 배분하는 방식이다.</p>

<p><strong>3). IP 해시 방식 (IP Hash Method)</strong><br />
클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식이다.</p>

<p><strong>4). 최소 연결 방식 (Least Connection Method)</strong><br />
요청이 들어온 시점에 가장 적은 연결상태를 보이는 서버에 우선적으로 트래픽을 배분하는 방식이다.</p>

<p><strong>5). 최소 리스폰타임 (Least Response Time Method)</strong><br />
서버에 현재 연결 상태와 응답시긴을 모두 고려하여 트래픽을 배분하는 방식이다.</p>

<p><br /></p>

<p><strong>✅ 로드 밸런서 종류</strong></p>

<p>로드 벨런서는 클라이언트의 요청을 어떤 것을 기준으로<br />
분산시키느냐에 따라 종류가 나눠진다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">로드 밸런서 종류</th>
      <th style="text-align: left">로드 밸런싱의 기준</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">L2</td>
      <td style="text-align: left">데이터 전송 계층에서 Mac 주소를 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">L3</td>
      <td style="text-align: left">네트워크 계층에서 IP 주소를 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">L4</td>
      <td style="text-align: left">전송 계층에서 IP주소와 Port를 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">L7</td>
      <td style="text-align: left">응용 계층에서 클라이언트의 요청을 바탕으로 로드 밸런싱을 한다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>✅ Auto Scaling</strong></p>

<p>오토 스케일링은 Scale out 방식으로 서버를 증설할 때<br />
자동으로 서버를 관리해주는 기능이다.<br />
클라이언트의 요청이 많아져 서버의 처리 요구량이 증가하면 새 리소스를<br />
자동으로 추하고 반대로 처리 요구량이 줄어들면 리소스를 감소시켜<br />
적절한 분산 환경을 만들어준다.</p>

<p><br /></p>

<h3 id="web-server">Web Server</h3>

<h4 id="tomcat">Tomcat</h4>

<p>톰캣은 스프링 학습하면서도 많이 보았을 것이다.<br />
Apache 회사에서 개발한 서블릿 컨테이너만 있는 오픈소스 웹 애플리케이션 서비이다.</p>

<p>우리가 흔히 <code class="language-plaintext highlighter-rouge">spring-boot-starter-web</code> 의존라이브러리를 설정해주면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM9BsZsYaMRKMNzpvRyIJ8x1e_QHfIL7G3lRFVPR5032Zy9WiYHkN968M8hq7geCpfSYH9AC0G8N496-KSCb84A34sepQ=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>외부 라이브러리에 추가된 모습을 볼 수 있다.</p>

<p><br /></p>

<h4 id="jetty">Jetty</h4>

<p>제티는 이클립스 재단의 HTTP 서버이자 자바 서블릿 컨테이너이다.<br />
우리는 스프링 웹에 내장되어 있는 톰켓을 사용했지만<br />
Jetty 서버로 변경하여 사용하는 것도 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
	<span class="n">implementation</span> <span class="o">(</span><span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">web</span><span class="err">'</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">exclude</span> <span class="nl">module:</span> <span class="err">'</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">tomcat</span><span class="err">'</span>
	<span class="o">}</span>
	<span class="n">implementation</span> <span class="o">(</span><span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">jetty</span><span class="err">'</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>
<p>기존의 톰켓 서버를 제외시키고, Jetty의 의존라이브러리를 추가해주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM4Q_56HQcx6ER0D9G9vc_AzQ_8_XrDREbC2LuRI1onRPzYvqLRzIIAG9jqfKepfooEmAcKuLKWqQLqjckdnKhxsUCs=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>gradle 리로드완료하면 외부라이브러리에서 Tomcat은 없어지고<br />
jetty가 추가된 모습을 확인할 수가 있다.</p>

<p>마찬가지로 애플리케이션을 로컬에서 실행하면 <br />
콘솔에 <code class="language-plaintext highlighter-rouge">Jetty started on port(s) 8080</code>를 확인할 수 있다.</p>

<p><br /></p>

<h4 id="nginx-proxy-server">NginX (Proxy Server)</h4>

<p>NginX는 가볍고 높은 성능을 보이는 오픈소스 웹 서버 소프트웨어이다.<br />
Tomcat과 Jetty가 Java 서블릿 컨테이너 혹은 웹 애플리케이션 서버였다면<br />
NginX는 웹 서버로 클라이언트에게 정적 리소스를 빠르게 응답하기 위한 웹서버로 사용할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOG2uzsclZ4QWPxVAe_uxKcedgoaUBgThcMRAT424RV8K7dLYr9RTnqxzVnbtWUkm6Ovs1fmsRs7A7EAgNcEovLGs2bTA=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같은 구조를 만든다고 가정하고 로컬환경에서 테스트를 해보자</p>

<p>MacOs 기준으로 설명해본다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>nginx
</code></pre></div></div>
<p>homebrew를 이용해 nginx를 설치해준다.<br />
설치가 완료되면 <code class="language-plaintext highlighter-rouge">brew list</code> 명령어로 설치리스트를 확인할 수 있다.</p>

<p>NginX 서버를 실행시키는 방법은</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services start nginx
</code></pre></div></div>
<p>해당 명령어를 입력하면 서버가 실행된다.<br />
MacOS기준으로 기본 포트는 <code class="language-plaintext highlighter-rouge">localhost:8080</code>로 접속이 가능하다. 접속 성공 시에는 콘솔에  <br />
<code class="language-plaintext highlighter-rouge">==&gt; Successfully started nginx (label: homebrew.mxcl.nginx)</code><br />
해당 문구를 확인할 수 있다.</p>

<p>만약 서버를 종료하고 싶다면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew services stop nginx
</code></pre></div></div>
<p>해당 명령어를 입력해주면 된다.</p>

<p>당연하게도 포트 변경도 가능하다.<br />
<code class="language-plaintext highlighter-rouge">nginx.conf</code>파일을 찾아서 변경해주면 된다.<br />
homebrew로 설치하였다면 <code class="language-plaintext highlighter-rouge">/opt/homebrew/etc/nginx/nginx.conf</code><br />
해당 경로에 존재할 확률이 높다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNeZvcQvQB3AXd4W2johu0UXke69vIktUKMB9ZCIWk3-U1-ZZEMEqf1zJcXXLqtOzRARHIow3uCQYvxVJevdtJorh-w=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>해당 파일을 vi, nano 편집기로 수정하여도 되고<br />
직접 열어 수정해도 된다.</p>

<p>파일에서 http &gt; server &gt; listen의 포트번호가<br />
8080으로 되어있을 텐데 해당 포트를 바꿔주면 된다.<br />
나는 80으로 변경하여 사용했다.</p>

<p>그리고 location에서 proxy_pass 관련 내용을 추가해주면 된다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
		listen       80; # 포트 변경
...
		location / {
				...
				proxy_pass http://localhost:8080; # 요청을 8080 포트로 넘깁니다.
				proxy_set_header X-Real-IP $remote_addr;
				proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
				proxy_set_header Host $http_host;
		}
}
</code></pre></div></div>

<p>다시 nginx를 실행 시키고, 스프링 부트를 실행시킨다음<br />
<code class="language-plaintext highlighter-rouge">localhost:80</code>에 접속 요청을 하면<br />
SpringBoot로 서버를 띄운 화면으로 넘어가는 것을 확인할 수 있을 것이다.</p>

<p><br /></p>

<h4 id="nginx-load-balancer">NginX (Load Balancer)</h4>

<p>위에서 NginX로 프록시 서버를 만들어서 Spring Web 서버와 연결해보는 것 까지 해보았다.<br />
NginX를 이용해 로컬환경에서 로드 벨런싱을 구성할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPbhOAOVSac7VnsgOd7t4bBzA3D7UlzJQGluLPU_4874TJYacn9Jp7MvB4AuwI0cKCtT3kMfDyslCcYClK7J6f4iQ0b=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>해당 구성도 <code class="language-plaintext highlighter-rouge">nginx.conf</code> 파일의 설정을 변경해서<br />
로드벨런싱이 되도록 구성할 수 있다.<br />
<a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">NginX 로드벨런싱 레퍼런스</a>를 참고해서 작성해보자</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
http {
    ...
    
    # 로드 벨런싱 테스트를 위한 추가 (22.12.09)
    upstream backend {
        server localhost:8080;
        server localhost:8081;
    }
    # 여기 위까지 추가

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
	    
	    # 로드 밸런싱 테스트를 위한 추가 (22.12.09)
	    proxy_pass http://backend;    
	    
        }
        ...
    }
    ...
}
</code></pre></div></div>
<p>로드 벨런싱을 위한 추가라고 붙은 주석이 달린 곳을 보면된다.<br />
스프링 톰켓 서버를 8080, 8081로 애플리케이션으로 실행 시켜둔 다음에<br />
nginx 서버를 80으로 실행 시키고 접속 요청을 하였을 경우</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMKVdGhcGq-yZafA-Yn63bYoQPXPy66rpCBac1Xkzm4czEkxlMaLbtVs-uIpxJ9Jb5zrusAmMAHT38Mlfcu0c7sjJ6z_A=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이렇게 작성한 화면이 띄워지게 된다.<br />
여기서 화면을 구분하기 위해 PID값을 추가해 줬다.<br />
보면 알 수 있듯이 2개의 서버중 33861 PID 값을 가진 화면을 불러왔다.</p>

<p>여러번 새로고침을 반복하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPOoMHE0tlxe7V1CdRoQCdJmIN7tcTL1QwqUY4OwiudZff34WNG0Ss4s1HVGHXJyqp6vwdzWDNhjx6epx8Qh4RgGDBycw=w3024-h1620" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이번엔 33818 PID 값을 가진 화면을 불러왔다.<br />
이렇게 클라이언트에서 nginx 서버에 요청 시<br />
로드 벨런싱이 적용되어 동작하는걸 눈으로 확인해 볼 수 있다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 클라우드 운영 전략에 대해 간단하게 알아보았다.<br />
백엔드 공부를 시작하면서 늘 걱정이었던게<br />
서버가 터지는 것을 어떻게 방지하지? 라는 의문이 있었고<br />
환경적으로 이렇게 설정할 수 있구나라는걸 많이 배운 것 같다.</p>

<p>이러한 전략들 외에 실제로 웹 요청이 많을때 프로그램 코드적으로는<br />
어떻게 해야 잘 짤 수 있을까도 많이 고민해보면 좋을 것 같다. (WebFlux라든가..)</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 간장계란밥, 김치찌개</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[Proxy Server]]></summary></entry><entry><title type="html">TIL) 배포 자동화 GitHub Actions</title><link href="http://localhost:4000/til/2022/12/08/til.html" rel="alternate" type="text/html" title="TIL) 배포 자동화 GitHub Actions" /><published>2022-12-08T00:00:00+09:00</published><updated>2022-12-08T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/08/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/08/til.html"><![CDATA[<h2 id="github-action">Github Action</h2>

<p>오늘은 GitHub Actions라는 빌드, 테스트 및 배포 파이프라인을<br />
자동화할 수 있는 CI/CD 플랫폼을 배워보려한다.</p>

<p>Pull Request나 push 같은 이벤트를 트리거로 Workflow를 구성할 수 있다.<br />
Workflow는 하나 이상의 작업이 실행되는 자동화 프로세스로, 각 작업은 자체 가상 머신<br />
또는 컨테이너 내부에서 실행된다.</p>

<p><br /></p>

<h3 id="github-actions를-통한-자동화-배포-flow">Github Actions를 통한 자동화 배포 Flow</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNS7vEzt0Vzp4__CH13v9LcmDTz7WAHn3CuXNw2JbEdcTd0Rlim8mfhT_8BX6KokJ4pPfSp7XLuV-zHGrM6KAUkfRwPag=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<ol>
  <li>레포지토리에 변화가 생기면 Github Actions 작동</li>
  <li>프로젝트 빌드 결과물(.jar) S3로 전송 및 저장</li>
  <li>CodeDeploy로 배포 명령</li>
  <li>프로젝트 빌드 결과물(.jar) CodeDeploy로 전달</li>
  <li>EC2 배포 및 샐행</li>
</ol>

<p>GitHub Actions는 설정파일(<code class="language-plaintext highlighter-rouge">.yml</code>)에 따라 Github Repository에<br />
특정 변동사항을 트리거로 작동된다. 트리커는 Pull Request나 push 같은 이벤트를<br />
사용할 수 있다고 위에서 얘기 했었었다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">on</span><span class="pi">:</span>
  <span class="na">push</span><span class="pi">:</span>
    <span class="na">branches</span><span class="pi">:</span> <span class="pi">[</span> <span class="s2">"</span><span class="s">main"</span> <span class="pi">]</span>
</code></pre></div></div>
<p>간단한 예시로 <code class="language-plaintext highlighter-rouge">main</code>브랜치에 push가 되어질때를 트리거로 사용하는 <code class="language-plaintext highlighter-rouge">.yml</code>설정이다.</p>

<p>Github Actions에서 빌드를 마치고 빌드 결과물을(.jar)  AWS S3 버킷에 객체를 저장한다.<br />
그리고 Code Deploy로 배포 명령이 내려진다.<br />
(즉, S3는 빌드한 결과물을 저장해주는 용도로만 사용할 것이다.)</p>

<p>그렇게 Code Deploy가 배포 명령을 받으면<br />
S3에 저장되어 있던 빌드 결과물이 EC2 인스턴스로 이동한다.<br />
그리고 <code class="language-plaintext highlighter-rouge">appspec.yml</code>파일에 설정한대로 shell script를 동작한다.</p>

<p>그렇게되면 EC2에서 <code class="language-plaintext highlighter-rouge">.yml</code>,<code class="language-plaintext highlighter-rouge">.sh</code>파일들에 의해 빌드파일(<code class="language-plaintext highlighter-rouge">.jar</code>)을 실행하고<br />
배포 결과를 로그로 남길 수 있다.<br />
즉, EC2에서는 Code Deploy Agent의 설치와 JDK 버전 설치가 필요하다.</p>

<p><br /></p>

<h3 id="github-actions-생성">Github Actions 생성</h3>
<p>이제 자동 배포과정은 위에서 알아 보았으니<br />
Github Actions을 이용해 설정을 진행해보자.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMYNPG-u6wiQkjifVTjEQoKHtaBipydSZPQKgyZx0rYIcuXUSkJSallw1_50L0eTN2PolpzM0LN3Iq-53XpaeOGc0RISQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>테스트용으로 만든 Repository의 상단의 Actions를 들어가서<br />
Java with Gradle을 찾아 구성을 클릭해준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM5ES3mIxRbG_7Tv7xj6t5VmlwijcfF3hNJE-Y-6LL5Ho0UW-ryp83Wv09WSYX_zmL1A_yXR83yC5j1CYsvj7RGrvxRzw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>눌러 주고나면 상단에 <code class="language-plaintext highlighter-rouge">.yml</code>파일을 저장할 경로가 나오고<br />
이름을 설정해 줄 수 있다. 기본이름인 <code class="language-plaintext highlighter-rouge">gradle.yml</code>로 설정 후</p>

<p>하단에는 <code class="language-plaintext highlighter-rouge">gradle.yml</code> 파일에 대한 설정을 해주어야한다.<br />
위에서 잠깐 얘기했던 변동사항 트리거 설정, JDK 설치<br />
build한 후 압축하는 기능, AWS credentials 구성, 압축한 파일 S3 전송<br />
CodeDeploy에게 배포 명령 등 다양한 Workflow를 설정해 줄 수 있다.</p>

<p>해당 설정을 마쳤다면, Start commit 버튼을 눌러준 후 Commit new file을 눌러 주면 된다. <br />
<code class="language-plaintext highlighter-rouge">gradle.yml</code> 파일은 Repository <code class="language-plaintext highlighter-rouge">.github/workflows</code> 경로에 저장된다.</p>

<p>그리고 Actions에서 우리가 설정한 <code class="language-plaintext highlighter-rouge">gradle.yml</code> 설정대로<br />
Workflow가 진행되는 것을 확인 할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN_vA2swoIsKid0hpogGa6K3M2HJBTtXm-GDj3Jgd5XETM9wAWdxUNkQyJXVJNWW3jWBSsFBStT6Zi3nWTmNAZJ_xD8mQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>모든 과정이 완료되면 위와 같이 녹색으로 표시가 된다.<br />
이제 S3에 빌드파일 객체가 전달되었을 것이고<br />
Code Deploy의 작동을 모아놓는 <code class="language-plaintext highlighter-rouge">appspec.yml</code>설정이 제대로 되어있고<br />
script <code class="language-plaintext highlighter-rouge">.sh</code>들의 코드가 정상적으로 들어가 있다면<br />
EC2에 정상적인 배포가 자동으로 이루어졌을 것이다.</p>

<p>Github Actions를 설정하기전에</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOCCMyhm1hmET_5cP4ljHyaJO7PsnSF7BHDYz2UDXIXk_bnHjHRXcJiInrmSFkwX5vihtTEAlXthho-aq2hznZ2WicsZw=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>우리가 이용하는 Code Deploy의 애플리케이션 생성과<br />
<code class="language-plaintext highlighter-rouge">appspec.yml</code>, <code class="language-plaintext highlighter-rouge">.sh</code>파일에 대한 설정은 끝나 있어야한다.</p>

<p><br /></p>

<h3 id="github-action-configure-aws-credentials">Github Action Configure AWS credentials</h3>

<p>현재 IAM 계정으로 AWS를 이용중이다.<br />
(<a href="https://docs.aws.amazon.com/ko_kr/powershell/latest/userguide/pstools-appendix-sign-up.html">참고 - AWS 엑세스키 관련 문서</a>)</p>

<p>Github Actions에서 Workflow를 실행하는 과정에서<br />
Access Key가 필요하다. 공개되면 보안 이슈가 발생할 수 있어<br />
Github Secret 기능을 이용해 Access Key 값을 저장한 후 사용할 수 있다.<br />
<a href="https://github.com/aws-actions/configure-aws-credentials">configure-aws-credentials 레퍼런스</a>를 참고해보면 좋을 것 같다.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">jobs</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span>
    <span class="na">steps</span><span class="pi">:</span>      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure AWS credentials</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">aws-actions/configure-aws-credentials@v1</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">aws-access-key-id</span><span class="pi">:</span> <span class="s">$</span> <span class="c1"># 등록한 Github Secret</span>
          <span class="na">aws-secret-access-key</span><span class="pi">:</span> <span class="s">$</span> <span class="c1"># 등록한 Github Secret</span>
          <span class="na">aws-region</span><span class="pi">:</span> <span class="s">ap-northeast-2</span>
     
      <span class="s">// ..생략</span>
</code></pre></div></div>
<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNUWS9aAZNZWUWqRYoX-BwmSLb-6gQk_20nb6IINmQUT2KAzI4lG5iZRNsAOzd0bseG1KReKyflHyumA-PfLlni5ijXrA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이렇게 키값을 설정해주면<br />
<code class="language-plaintext highlighter-rouge">gradle.yml</code>에서 환경변수 사용하듯이 사용이 가능하다.</p>

<p><br /></p>

<hr />

<p>이렇게 오늘은 Github actions를 이용해<br />
push 한번으로 EC2까지 자동으로 배포되어지는 기능을 사용해 보았다.<br />
안에 엄청나게 복잡한 내용들이 존재하는건 분명하다.</p>

<p>이 기능을 이용해본 입장으로서는 Workflow 구성설정과<br />
AWS CodeDeploy의 <code class="language-plaintext highlighter-rouge">.yml</code>,<code class="language-plaintext highlighter-rouge">.sh</code> 파일에 대한 내용만<br />
우리가 동작을 원하는대로 설정만 잘해두면 무리없이 동작되는 것 같다.</p>

<p>이렇게 이틀 동안 배포자동화에 대한 두가지 방법을 알아 보았다.<br />
느낀점은 AWS에 대한 공부가 절실하다는 것.<br />
전체적인 흐름을 이해했으니 이제 상세한 공부들이 필요할 시기다.</p>

<p>오늘 공부는 여기서 끝!!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 짜파게티, 김치찌개</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[Github Action]]></summary></entry><entry><title type="html">TIL) 배포 자동화 AWS Pipeline</title><link href="http://localhost:4000/til/2022/12/07/til.html" rel="alternate" type="text/html" title="TIL) 배포 자동화 AWS Pipeline" /><published>2022-12-07T00:00:00+09:00</published><updated>2022-12-07T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/07/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/07/til.html"><![CDATA[<h2 id="배포-자동화">배포 자동화</h2>
<p>말그대로 배포 자동화란 기존에 배포를 위한 복잡한 작업을<br />
클릭 혹은 명령어 입력을 통해 전체 배포 과정을 자동으로 진행하는 과정이다.</p>

<h3 id="배포-자동화-파이프-라인">배포 자동화 파이프 라인</h3>
<p>파이프 라인이라하면, 이전에 Stream API 공부할 때<br />
들어보았었다. 무언가 연결해준다는 의미를 가지고 있었다.<br />
배포 자동화에서 파이프 라인은 소스 코드의 관리부터 실제 서비스로의<br />
배포 과정을 연결하는 구조를 뜻한다. 파이프라인은 전체 배포 과정을<br />
여러 Stage(단계)로 분리한다. 가장 많이 쓰이는 3가지를 알아보자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOBugDzkr65yzP1swq8j1g1mBAZr045aqB-cw37iLymttIosjnfOMB7uXqdvuDB57Pn7JMCKjSYkUackOYK56Jxv-_yeg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<ul>
  <li>Source 단계
원격 저장소에 관리되고 있는 소스 코드에 변경 사항이 일어날 경우<br />
이를 감지하고 다음 단계로 전달하는 작업을 수행하는 단계이다.</li>
  <li>Build 단계
Source 단계에서 전달받은 코드를 컴파일, 빌드, 테스트하여 가공한다.</li>
  <li>Deploy 단계
Build 단계에서 전달받은 결과물을 실제 서비스에 반영하는 작업을 수행한다.</li>
</ul>

<p>기본적으로 위와 같이 단계가 있고, 상황과 필요에 따라<br />
더 세분화되거나 간소화될 수 있다.</p>

<p>AWS 개발자 도구 섹션에는 배포 자동화 파이프 라인을<br />
구출할 수 있는 서비스를 제공해준다.</p>

<p>CodeCommit - Source 단계때 구성할때 사용  <br />
CodeBuild - Build 단계를 구성할때 사용<br />
CodeDeploy - Deploy 단계를 구성할때 사용<br />
CodePipeline - 각 단계를 연결하는 파이프라인을 구축할때 사용</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM8pJIpAdD3GNp2mXZL5SYWXzDvSr1uUBGS_yexwRH8gfwX8ADARYcBpQiHMhElbxPMW_wio_bkug-UdFYF-4uucf4f7Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>CodeCommit을 제외한 파이프라인 구성이다.<br />
GitHub 레포지포티와 연결하여, 후에 변경사항을 반영했을 경우<br />
배포 과정이 자동으로 진행되는 방식이다.</p>

<p><br /></p>

<h3 id="개발환경-구축">개발환경 구축</h3>

<p>이와 같이 구성을 하기 위해서<br />
EC2 인스턴스에 java,aws-cli,ruby를 설치하여 개발환경을 구축해야한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
</code></pre></div></div>
<p>apt를 업데이트를 먼저 진행한다.</p>

<p><br /></p>

<p><strong>1). Java 설치</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-11-jre-headless
</code></pre></div></div>

<p><br /></p>

<p><strong>2). AWS CLI 설치</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="s2">"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"</span> <span class="nt">-o</span> <span class="s2">"awscliv2.zip"</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>unzip
unzip awscliv2.zip
<span class="nb">sudo</span> ./aws/install
</code></pre></div></div>
<p><a href="https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/getting-started-install.html">AWS CLI 공식 문서</a>를 참고하면 동일하게 나온다.<br />
unzip이 설치되어있다면 생략해도 가능하다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aws <span class="nt">--version</span>
</code></pre></div></div>
<p>설치가 완려되면 버젼확인이 가능하다.</p>

<p><br /></p>

<p><strong>3). CodeDeploy Agent 설치</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>ruby-full             
<span class="nb">sudo </span>apt <span class="nb">install </span>wget
<span class="nb">cd</span> /home/ubuntu
<span class="nb">sudo </span>wget https://aws-codedeploy-ap-northeast-2.s3.ap-northeast-2.amazonaws.com/latest/install
<span class="nb">sudo chmod</span> +x ./install
<span class="nb">sudo</span> ./install auto <span class="o">&gt;</span> /tmp/logfile
</code></pre></div></div>
<p><a href="https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/codedeploy-agent-operations-install-ubuntu.html">AWS CodeDeploy 공식 문서</a>를 참조하면 확인이 가능하다.
wget이 없을 경우 wget 설치.</p>

<p>설치가 완료되면 서비스가 실행중인다 확인할 수 있다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service codedeploy-agent status
</code></pre></div></div>
<p>를 입력하였을 경우 <code class="language-plaintext highlighter-rouge">active(running)</code>문구를 확인할 수 있다. 
만약 확인이 되지 않을 경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service codedeploy-agent start
<span class="nb">sudo </span>service codedeploy-agent stop
</code></pre></div></div>
<p>start와 stop을 반복하여 확인할 수 있다..</p>

<p><br /></p>

<h3 id="파이프라인-구축">파이프라인 구축</h3>

<p>우선 AWS에서 파이프라인을 만들기전에<br />
애플리케이션에서 설정을해줘야하는 정보가 있다.<br />
설정 후 GitHub 레포지토리에 push해 놓으면 후에 파이프라인 구성완료 시<br />
자동으로 EC2로 빌드가 되어진다.</p>

<p><code class="language-plaintext highlighter-rouge">appspec.yml</code>,<code class="language-plaintext highlighter-rouge">buildspec.yml</code>파일을 프로젝트 하위폴더로 만들어 설정해 놓아야한다.<br />
<a href="https://docs.aws.amazon.com/ko_kr/codedeploy/latest/userguide/reference-appspec-file-structure-hooks.html">AWS CodeDeploy hooks</a>, <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html">AWS CodeBuild reference</a>를 참조해 설정이 가능하다.<br />
그에 따른 여러 Script(.sh) 파일도 만들어 줘야한다.</p>

<p><br /></p>

<p>설정을 완료하였다면 AWS측을 설정해보자
우선 IAM 계정을 사용하고 있을 경우<br />
EC2 인스턴스의 IAM 역할 권한을 추가해줘야한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNHCZmULZC_buWOV0uETzML7F5yL9VNR0hj_Q4BV4gGNtv0GOCClWrzgXa-dtUzxqNLqn_WwwcpSwaMV_RmfKBf5nQxqw=w1347-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM1bpbtv0DDnd8H-7P6jP2brR474UmPVdMEFXnEfif64w1RL6X4FAttBZUzd8SRMg0-G4IbhFIgL0E9SilwKHxEh3JctA=w1347-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>AmazonS3FullAccess<br />
AmazonEC2RoleforAWSCodeDeploy<br />
AWSCodeDeployRole<br />
AmazonSSMFullAccess<br />
정책 생성을 진행 해주면 된다.</p>

<p>그리고 신뢰 관계 정책 설정에서</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gM83eaHqKN9E2lXj13Vs4tHqQtA7pwGi-9gfttGhvNhZhUlChzPlKtzn90TDSUfHuueIgv0lRqhAbOB35wAVXDl5If0=w1347-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Service의 <code class="language-plaintext highlighter-rouge">"codedeploy.ap-northeast-2.amazonaws.com"</code>를 할당해주면 된다.</p>

<p><br /></p>

<p>그 다음엔 CodeDeploy에서 애플리케이션을 생성해주자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOCCMyhm1hmET_5cP4ljHyaJO7PsnSF7BHDYz2UDXIXk_bnHjHRXcJiInrmSFkwX5vihtTEAlXthho-aq2hznZ2WicsZw=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<p>그리고 CodePipeline에서 파이프라인을 생성해주면 된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPtKi60Y7GgJNZ-krPaDlb7pxQeTHn1rhOxGyNiRfip436OUWCtxR4xNpu-yETn1kF6Yod57iJmMKi50rXhxLMyQIHXsw=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>파이프라인을 만들때 Source 단계에서는 <br />
GiuHub에 연결해서 사용하면 된다.</p>

<p>이제 파이프라인 구성을 완료하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOgBdDghrM3cnjcID_cq7VNsyWqpOinvicT0MfJeSOpE0dVVs1zM986Cu6Jz9kQ7MW0j1X2amC1ego-aMHv2bM-NcG9WA=w1304-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 파이프라인이 실행이 완료된 것을 볼 수 있다.<br />
이제 우리가 Github에 push를 하는 순간</p>

<p>해당 내용이 EC2 인스턴스 서버에 빌드되는게<br />
자동화가 되었다는 사실 !!!</p>

<p>엄청 대단한 기술이다… 물론 알아야할 것도 엄청 많아서 난해했지만<br />
현재는 따라하는 단계만 마친 것 같다.</p>

<p><br /></p>

<h3 id="서버-환경-변수-설정">서버 환경 변수 설정</h3>

<p>기존에는 <code class="language-plaintext highlighter-rouge">.yml</code>, <code class="language-plaintext highlighter-rouge">.properties</code> 파일에 환경변수를<br />
설정하여 파싱해서 가져다 사용했었다.<br />
이제는 EC2에 서버가 배포되어있으니 AWS의 Parameter Store<br />
서비스를 이용하면 환경변수가 쉽게 설정이 가능하다.</p>

<p>우선 EC2에 배포하려는 프로그램에 설정해주자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span><span class="o">{</span>
    <span class="o">...</span>
    <span class="n">implementation</span><span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">cloud</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">cloud</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">aws</span><span class="o">-</span><span class="n">parameter</span><span class="o">-</span><span class="n">store</span><span class="o">-</span><span class="n">config</span><span class="err">'</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencyManagement</span> <span class="o">{</span> 
	<span class="n">imports</span> <span class="o">{</span>
		<span class="n">mavenBom</span> <span class="s">"org.springframework.cloud:spring-cloud-starter-parent:Hoxton.SR12"</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>build.gradle의 의존관계를 설정해주어야한다.</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">aws</span><span class="pi">:</span>
  <span class="na">paramstore</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">prefix</span><span class="pi">:</span> <span class="s">/spring-boot-aws</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">be-88-MyCatlikesChuru</span> <span class="c1"># 리소스 이름을 작성합니다.</span>
    <span class="na">profileSeparator</span><span class="pi">:</span> <span class="s">_</span>
</code></pre></div></div>

<p>파라미터 스토어에서는 <code class="language-plaintext highlighter-rouge">/prefix/name/key</code>의 순서로 네이밍 규칙에 <br />
맞게 작성해야한다. name은 EC2 인스턴스이름과 동일하게 설정해주자.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">.yml</code>, <code class="language-plaintext highlighter-rouge">.properties</code>에 설정해 주었던<br />
환경변수는 EC2 파라미터 스토어에서 대체되니<br />
삭제하거나 주석처리를 하면 된다.</p>

<p>이제 AWS의 파라미터 스토어에서 파라미터를 생성해주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO32zl6JsLi9OZI8wmEopf7e19jrzKC-54eaufU8QdnSmQp_MyS-toExX9-gZKm2RPXwZFu4DMEF7NPDYuTNMPUmcJnvA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>이름에는 네이밍 규칙을 넣어주면 되고 <br />
값에는 우리가 실제로 환경변수를 사용할 값을 넣어주면 된다.</p>

<p>예를들어 mysql을 사용하려는데 username을 설정한다고 가정하면<br />
<code class="language-plaintext highlighter-rouge">spring.datasource.username=admin</code>과 같은 형태로 <code class="language-plaintext highlighter-rouge">.properties</code>에  <br />
사용한다고 가정을 하였을 경우</p>

<p>이름 : <code class="language-plaintext highlighter-rouge">/spring-boot-aws/be-88-MyCatlikesChuru/spring.datasource.username</code><br />
값 : <code class="language-plaintext highlighter-rouge">admin</code><br />
과 같은 형태로 파라미터를 만들어 준다면<br />
우리가 EC2에 정상적으로 배포해둔 서버에 해당 환경변수가 적용될 것이다.</p>

<p><br /></p>

<hr />

<p>오늘은 이렇게 배포를 자동화하는 기술을 배워보았다.<br />
AWS에서 지원하는 파이프라인 구성을 통해<br />
EC2 인스턴스 빌드가 자동으로 되는 과정을 지켜보았고<br />
이번에 공부하면서 느낀건데… AWS에 대한 깊은 공부가<br />
정말 필요하다고 절실히 느꼈다.</p>

<p>Java와 Spring이 어느정도 익숙해진다면<br />
AWS 공부를 열심히 해볼 생각이다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 콩나물 김치찌개, 계란야채부침, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[배포 자동화 말그대로 배포 자동화란 기존에 배포를 위한 복잡한 작업을 클릭 혹은 명령어 입력을 통해 전체 배포 과정을 자동으로 진행하는 과정이다.]]></summary></entry><entry><title type="html">TIL) 배포 컨테이너 Docker</title><link href="http://localhost:4000/til/2022/12/06/til.html" rel="alternate" type="text/html" title="TIL) 배포 컨테이너 Docker" /><published>2022-12-06T00:00:00+09:00</published><updated>2022-12-06T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/06/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/06/til.html"><![CDATA[<h2 id="docker">Docker</h2>

<p>실제 선박의 컨테이너라함은 여러가지 물자들은 하나의 컨테이너에 싦어<br />
부피,인력,물자 이동 등 엄청난 장점을 가져왔다.</p>

<p>소프트웨어 측면에서도 배포하는 과정을 편하게 사용하고 여러 장점을 가지기 위해<br />
애플리케이션을 컨테이너화할 수 있는 도커가 등장했다.<br />
즉, 컨테이너 방식의 애플리케이션이라는 뜻은 실행환경에 <br />
구애받지 않고 실행시킬 수 있다는 뜻이다.</p>

<p>가장 많이 듣는 용어를 적어본다.</p>

<ul>
  <li>
    <p><strong>컨테이너</strong><br />
애플리케이션이 의존성, 네트워크 환경, 파일 시스템에 구애받지 않고<br />
도커라는 기술 위에 실행될 수 있도록 만든 애플리케이션 상자이다.<br />
즉, <strong>도커에 의해 관리/제공되는 애플리케이션 단위이다.</strong></p>
  </li>
  <li>
    <p><strong>이미지</strong><br />
모든 컨테이너는 이미지로 부터 생성된다.<br />
이미지를 이용해 여러개의 컨테이너를 생성할 수 있고, 애플리케이션 <br />
수평확장이 가능하다. 즉, <strong>도커 컨테이너를 생성하는데 사용되는 템플릿이다.</strong></p>
  </li>
  <li>
    <p><strong>레지스트리</strong><br />
이미지는 레지스트리에 저장된다. 대포적으로<br />
Docker Hub, Amazon ECR등이 있다.<br />
즉, <strong>도커 이미지를 저장하고 배포/공유하는데 사용한다.</strong></p>
  </li>
</ul>

<p><br /></p>

<h3 id="docker-컨테이너-방식의-장점">Docker 컨테이너 방식의 장점</h3>

<p><strong>1). 의존성 충돌 문제를 해결</strong><br />
컨테이너 기술을 바탕으로 한 컴퓨터 안에 여러대의 컨테이너가 있다.<br />
애플리케이션 실행 환경이 격리되어있다는 뜻이므로<br />
각자 고유의 의존성을 포함하고 있다.</p>

<p>그렇다면, 어떤 자원을 독립적으로 가지고 있는지 알아보자</p>
<ol>
  <li>프로세스<br />
-. 특정 컨테이너에서 작동하는 프로세스는 기본적으로 그 컨테이너 안에서만 액세스 가능<br />
-. 컨테이너 안에서 실행되는 프로세스는 다른 컨테이너의 프로세스에게 영향 X</li>
  <li>네트워크<br />
-. 기본으로 컨테이너 하나에 하나의 IP 주소가 할당</li>
  <li>파일 시스템<br />
-. 컨테이너 안에서 사용되는 파일 시스템은 구획화 되어있다.<br />
그래서 해당 컨테이너에서의 명령이나 파일 등의 액세스를 제한 할 수 있다.</li>
</ol>

<p><br /></p>

<p><strong>2). 개발과 배포 환경을 일치 시켜준다.</strong><br />
Docker를 사용하면 OS에 상관없이 즉시 애플리케이션 실행 환경을 만들 수 있다.<br />
그리고 개발 컨테이너 위에서 진행할 경우, 모든 개발팀이 동일한 환경 하에<br />
개발을 진행할 수 있다.</p>

<p><strong>3). 수평 확장을 쉽게 해준다, 각 서버에 새로운 내용을 배포하기 쉽게 만들어준다.</strong><br />
컨테이너 기술의 가장 큰 장점은 실행 환경의 일치이다.<br />
엄청난 트래픽을 요구하는 애플리케이션들은 단하나의 서버가 아니라<br />
트래픽을 분산하기 위해 프록시 서버를 운영한다고 한다.</p>

<p>프록시 서버는 여러 대의 동일한 서버 중 한군데를 이용할 수 있도록 돕는데<br />
동일한 서비스가 여러 컴퓨터에서 작동하기위해서 편리하게 사용하는 기술이 컨테이너 기술이다.</p>

<p><br /></p>

<h3 id="docker-설치">Docker 설치</h3>

<p>현재 나는 MacOS를 사용하고 있기때문에<br />
<a href="https://docs.docker.com/desktop/install/mac-install/">Docker Mac install</a>를 접속해 도커를 설치할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOirwJaCgDYW20G-JPu9KXSWfoPXL55k_PPeZhnPzs4qxZUhExHL7cjPH110xQtywGE6J71t1n7aRJnz0k2XmPKfqNofg=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>도커 설치를 완료하면 위와 같은 애플리케이션 GUI 확인이 가능하다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nt">--version</span>
</code></pre></div></div>
<p>실제로 CLI로 버젼을 입력할 경우 정상적으로 설치되었으면<br />
현재 설치된 버전이 나올 것이다.</p>

<p><br /></p>

<h3 id="docker-사용전-명령어-보기">Docker 사용전 명령어 보기</h3>

<p>Docker GUI를 이용하지 않고<br />
<a href="https://docs.docker.com/engine/reference/commandline/container_run/">CLI</a>를 통한 연습을 진행해보려한다.</p>

<p>그전에 선행되어야하는 것이 명령어를 먼저 알아야한다.</p>

<h4 id="1-이미지-관련-명령어">1). 이미지 관련 명령어</h4>

<p>✅ 설치된 이미지 조회하는 명령어이다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image <span class="nb">ls</span>
</code></pre></div></div>

<p><br /></p>

<p>✅ 이미지를 설치하는 방법이다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image pull 이미지이름:tag
</code></pre></div></div>

<p><br /></p>

<p>✅ 설치되어 있는 이미지를 삭제하는 방법이다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker image <span class="nb">rm </span>이미지이름
</code></pre></div></div>
<p>만약 이미지를 컨테이너에 사용할 경우 삭제가 불가능하다.<br />
컨테이너를 종료시키고 삭제 후 에 이미지를 삭제해야한다.</p>

<p><br /></p>

<h4 id="2-컨테이너-관련-명령어">2). 컨테이너 관련 명령어</h4>

<p>✅ 설치되어 있는 이미지를 삭제하는 방법이다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container run <span class="nt">--name</span> 컨테이너이름 <span class="nt">-p</span> 8080:80 이미지이름
</code></pre></div></div>
<p><strong>컨테이너 이름</strong>은 우리가 정하면 된다.</p>

<p><strong>이미지 이름</strong>은 설치한 이미지의 이름을 적어주면되는데<br />
만약 해당 이미지으 tag가 있다면 <code class="language-plaintext highlighter-rouge">이미지이름:tag</code> 를 적어줘야한다.<br />
여기서 tag라 함은 <code class="language-plaintext highlighter-rouge">latest</code>, <code class="language-plaintext highlighter-rouge">2.0</code>이라든가의 버젼을 의미한다.</p>

<p>또한 포트번호는 8080:80이라고 적어두었는데<br />
첫번쨰 포트는 내부포트이고 두번쨰 포트는 외부포트이다.<br />
외부에서 통신을하기 위한 통신 포트를 요청하면<br />
컨테이너의 내부포트로 forwarding 하겠다는 의미이다.<br />
즉, 8080포트로 요청할 경우 80으로 포트포워딩 하겠다는 뜻이다.<br />
<a href="https://ooeunz.tistory.com/104">Port Forwarding 참고 - ooeunz님 블로그</a></p>

<p><br /></p>

<p>✅ 컨테이너 리스트 출력</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container ps <span class="nt">-a</span>
</code></pre></div></div>

<p><br /></p>

<p>✅ 실행중인 컨테이너 리스트 출력</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">ls</span>
</code></pre></div></div>
<p>컨테이너 리스트 출려과는 다르다. 현재 start되어있는 컨테이너만 출력되어진다.</p>

<p><br /></p>

<p>✅ 컨테이너 실행</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container start 컨테이너이름
</code></pre></div></div>
<p>컨테이너를 백그라운드 상태로 실행시킬 수 있는 명령어이다.</p>

<p><br /></p>

<p>✅ 컨테이너 중지</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container stop 컨테이너이름
</code></pre></div></div>
<p>살행 중인 컨테이너를 종료하는 명령어이다.</p>

<p><br /></p>

<p>✅ 컨테이너 삭제</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">rm </span>컨테이너이름
</code></pre></div></div>
<p>컨테이너를 중지시킨다음, 해당 컨테이너가 필요없을 경우<br />
해당 명령얼 컨테이너를 삭제할 수 있다.</p>

<p><br /></p>

<p>✅ 컨테이너 내부 접근</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> 컨테이너이름 bash
</code></pre></div></div>
<p>선택한 컨테이너를 bash CLI로 접근할 수 있다.</p>

<p><br /></p>

<p>✅ 현재 폴더의 파일을 컨테이너의 경로에 복사하기</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">cp</span> ./ 컨테이너이름:/경로
</code></pre></div></div>

<p><br /></p>

<p>✅ 구동중인 컨테이너를 지정해 이미지로 만들기</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container commit 컨테이너이름 이미지이름:tag
</code></pre></div></div>

<p><br /></p>

<p>✅ 이미지 빌드하는 방법</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">--tag</span> 이미지이름:tag <span class="nb">.</span> 
</code></pre></div></div>
<p>Dockerfile을 만들고, Dockerfile 대로 이미지를 build하는 방법이다.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM httpd:2.4 
COPY ./ /usr/local/apache2/htdocs/
</code></pre></div></div>
<p>와 같은 형식으로 Dockerfile을 만든다.<br />
위에 내용을 해석하자면 베이스 이미지르 httpd로 사용<br />
현재경로에(./) 있는 파일들을 특정경로(/usr/local/apache2/htdocs/)로 이동한다.</p>

<p>이렇게 빌드된 이미지를 이제 컨테이너로 사용할 수 있다.</p>

<p><br /></p>

<h3 id="docker-사용해보기">Docker 사용해보기</h3>

<p>순서는 레지스트리에서 이미지를 받고 컨테이너를 만들면된다.<br />
그리고 해당 컨테이너 주소로 접속해 우리가 하려고하는 <br />
애플리케이션의 테스트가 가능하다.</p>

<h4 id="hello-docker">Hello docker</h4>
<p>우선 만들어 놓은 프로젝트가 없으니<br />
간단한 이미지 부터 사용해보려한다.</p>

<p><a href="https://hub.docker.com/">dockerhub</a>에서 여러가지 이미지를 받을 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOVWTMjVY1qXqFAq126SrK8teCYWrYjuD9AUm4P7X5-jZFdC34n7mts1L9tvQHKnubRGziozwnzaI33PP8bx462unP0xQ=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그 중 귀여운 고래화면을 띄워주는 <code class="language-plaintext highlighter-rouge">docker/whalesay</code>를 검색해보자<br />
검색해보면 오른쪽에 커맨드로 도커를 가져올 수 있는 명령어가 있고<br />
사용 방법에 대한 내용이 쭉 나와 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull docker/whalesay
</code></pre></div></div>
<p>를 입력해주면 해당 이미지를 다운 받는다</p>

<p>그리고 컨테이너를 시작시켜주는 명령어를 사용하면 된다.<br />
해당 이미지에선 사용하는 방법을 설명해준다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run docker/whalesay cowsay boo
</code></pre></div></div>
<p>를 입력하게 되면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> _____
&lt; boo <span class="o">&gt;</span>
 <span class="nt">-----</span>
    <span class="se">\</span>
     <span class="se">\</span>
      <span class="se">\</span>
                    <span class="c">##        .</span>
              <span class="c">## ## ##       ==</span>
           <span class="c">## ## ## ##      ===</span>
       /<span class="s2">""""""""""""""""</span>___/ <span class="o">===</span>
  ~~~ <span class="o">{</span>~~ ~~~~ ~~~ ~~~~ ~~ ~ /  <span class="o">===</span>- ~~~
       <span class="se">\_</span>_____ o          __/
        <span class="se">\ </span>   <span class="se">\ </span>       __/
          <span class="se">\_</span>___<span class="se">\_</span>_____/
</code></pre></div></div>
<p>이러한 귀여운 고래 모습을 볼 수 있다.</p>

<p>이제 간단한 이미지를 다운받아 사용까지 해보았다.<br />
삭제를 하려면 컨테이너에서 먼저 삭제한다음<br />
이미지를 삭제해주면 된다.</p>

<p><br /></p>

<h4 id="httpd-사용해보기">httpd 사용해보기</h4>

<p>이제 본격적으로 사용해보자 homebrew <code class="language-plaintext highlighter-rouge">httpd</code>를 사용하듯<br />
Apache HTTP Server인 <code class="language-plaintext highlighter-rouge">httpd</code> 이미지를 이용해<br />
웹서버를 띄워 볼 수 도 있다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container run <span class="nt">--name</span> <span class="nb">test</span> <span class="nt">-p</span> 818:80 httpd
</code></pre></div></div>
<p>test라는 이름의 컨테이너로 818포트를 80포트로 포워딩하게 해두었다.<br />
httpd의 기본포트는 80번으로 설정되어있다.</p>

<p>해당 컨테이너를 실행한 후에 <code class="language-plaintext highlighter-rouge">http://localhost:818</code>로 접속하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNFNMWOpsHkODxYQxJgNRxLj1AeHg2F0fO44DfPsxGt3X1MLhhs0yKVwVkF5SiESv9ODhQJ4xY0Mpgki2MHFCrIEQgc=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>기존에 Apache HTTP Server를 띄우는 것처럼<br />
기본 html인 It works!가 확인이 가능하다.</p>

<p><br /></p>

<h4 id="httpd-서버에-프로그램-올리기">httpd 서버에 프로그램 올리기</h4>

<p>이제 여기서 우리가 해당 컨테이너에 프로그램을 넣을 수 있다.<br />
예를 들어 <code class="language-plaintext highlighter-rouge">팩맨 게임</code>을 해당 웹서버에 올린다고 가정하자.<br />
(해당 게임 프로그램은 <a href="https://github.com/daleharvey/pacman">pacman github</a>에서 클론 받을 수 있다.)</p>

<p>방법은 2가지 정도가 있다.<br />
첫번째 방법은 현재 컨테이너에다가 파일을 복사하는 방법과<br />
두번째 방법은 Dockerfile을 이용해 이미지를 다시만든다음에 컨테이너로 만들면된다.</p>

<p>첫번째 방법 부터해보자<br />
현재 만들어둔 test 컨테이너 안에 httpd 경로에 파일을 복사하면된다.<br />
실제로 컨테이너를 접속해보면 <code class="language-plaintext highlighter-rouge">/usr/local/apache2/htdocs/</code>경로에<br />
<code class="language-plaintext highlighter-rouge">index.html</code>파일이 있는 것을 볼 수 있다. 해당 파일은 It works! 파일이다.<br />
해당 경로에 내가 올리려는 <code class="language-plaintext highlighter-rouge">팩맨 게임</code>의 <code class="language-plaintext highlighter-rouge">index.html</code>과 여러 파일들을 넣어주면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container <span class="nb">cp</span> ./ <span class="nb">test</span>:/usr/local/apache2/htdocs/
</code></pre></div></div>
<p>이제 내가가지고 있는 프로그램 파일 경로로 접속해<br />
해당 명령어를 입력해주면 해당 경로에 있는 파일들이<br />
전부 test 컨테이너의 해당 경로로 복사되어진다.</p>

<p>그리고 다시 컨테이너를 시작해준다면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker container start <span class="nb">test</span>
</code></pre></div></div>
<p>백그라운드로 실행 될 것이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNlwmnQmaBw58r6RaXn6r0cqk2S5p1PNxjI-p9i_FN0dP0id_Gk2udyi8M6KHtwMnNn9bcC67lLPdIL1OD4gr_HuSlLtA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><code class="language-plaintext highlighter-rouge">팩맨 게임</code>이 실제로 동작하는 것을 볼 수 있다.</p>

<p><br /></p>

<p>두번째 방법으로는
<code class="language-plaintext highlighter-rouge">팩맨 게임</code>폴더에 <code class="language-plaintext highlighter-rouge">Dockerfile</code>이라는 <br />
이름의 파일을 만든다. 그리고 해당 파일 안에는</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM httpd:2.4
COPY ./ /usr/local/apache2/htdocs/
</code></pre></div></div>
<p>와 같은 내용을 넣어준다. (설명은 명령어에서 설명했으므로 생략)</p>

<p>그리고 build 명령어를 이용해서 이미지를 빌드할 수 있다.<br />
명령어를 실행할때는 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 경로에서 입력해야한다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">--tag</span> pacman:2.0 <span class="nb">.</span>
</code></pre></div></div>
<p>build 명령어를 실행하면, 이미지 파일이 생성되고<br />
해당 이미지 파일로 이제 컨테이너를 실행시키면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> pacmangametest <span class="nt">-p</span> 818:80 pacman:2.0
</code></pre></div></div>

<p><br /></p>

<p>이렇게 CLI로 명령어로 docker를 사용하는 방법을<br />
간단하게 알아보았다. 실제로 우리가 만든 이미지와 컨테이너들을<br />
처음에 설치했던 GUI에서 확인이 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPo7gNUnHKL8zeCRsYvKbyYYsOo7MetSL7gXnBiWBaVDpwCNjPW8nF03SW8upgiGOE4S8bBqLdOrxDnnkH9PJTQvp9lWA=w3024-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<hr />

<p>오늘은 이렇게 짧지만 docker를 공부했다.<br />
계속 연습하다보니까 어느정도 이해가 되었다.<br />
이렇게 이미지로 만들어 팀원들과 배포환경을 동일하게<br />
사용할 수 있을 것 같다.</p>

<p>이제 곧 프로젝트인데 프로젝트할 때 적용해보도록 해봐야겠다!!</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 삼첩분식</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[Docker]]></summary></entry><entry><title type="html">TIL) Cloud 운영 환경 구성 2</title><link href="http://localhost:4000/til/2022/12/05/til.html" rel="alternate" type="text/html" title="TIL) Cloud 운영 환경 구성 2" /><published>2022-12-05T00:00:00+09:00</published><updated>2022-12-05T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/05/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/05/til.html"><![CDATA[<p>저번주에는 기본적인<br />
Cloud 운영 환경에 대한 구성들을 배워 보았다.<br />
이번 공부에서는 3티어 아키텍처 형태로 배포하는 방법을<br />
배울 것이고, 저번주에 EC2에 서버를 배포해보는 것까지 해봤었다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMCqrjaGSYLYkne25hlMNNSGrxxCwtWjwIW1qahU8iTVkaJk3lgQwrF-ArVtHMFQcmUuojJ-JIIdF3Sujk5F4ZZuD8BHQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그 중에서도 우리는 EC2 인스턴스에<br />
우리가 만든 Spring 프로젝트를 build하여<br />
서버에 배포해보는 것까지 진행 했었다.</p>

<p>오늘은 클라이언트(S3) 측과 데이터베이스(RDS) 측을 알아보자</p>

<p><br /></p>

<h3 id="클라이언트-배포">클라이언트 배포</h3>

<p>우선 클라이언트의 프로젝트를 build하는 방법이<br />
여러가지가 있는 것 같다. (java와 마찬가지로)</p>

<p>그 중 터미널의 node를 이용해 build하는 작업을 진행해보자<br />
(참고로 MacOS를 사용중)</p>

<p><br /></p>

<h4 id="1-프로젝트-build">1. 프로젝트 build</h4>

<p>먼저 <a href="https://github.com/nvm-sh/nvm#install--update-script">nvm 설치</a>를 진행해주자.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="nt">-qO-</span> https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash
</code></pre></div></div>
<p>공식 사이트에 있는 최신 버젼을 설치해주면 될 것 같다.<br />
만약, wget을 찾을 수 없다는 알람이 뜬다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>wget
</code></pre></div></div>
<p>wget을 패키지 관리자인 homebrew로 설치하면 된다.</p>

<p>짤막한 지식과 검색을 통한 지식으로 정리를 해보자면<br />
NVM은 Node Version Manager로 Node.js의 버전을 관리해주는 도구이다.  <br />
Node.js는 브라우저 내에서 말고도 다른 환경에서도 JavaScript를 실행 시킬 수 있게<br />
도와주는 실행창, 실행 환경이라고한다. (크롬의 js해석 엔진인 V8 엔진을 이용)</p>

<p>그럼 이제 nvm 설치가 완료되었다면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm <span class="nt">--version</span>
</code></pre></div></div>
<p>명령어로 설치가 되었는지 확인해주자.</p>

<p>이제 nvm이 설치되었으니 <a href="https://nodejs.org/en/">node.js 설치</a>를 할 수 있다.  <br />
해당 사이트에서 버전 확인이 가능하다.</p>

<p>원하는 버전을 설치해줘도 되지만.. 16버전을 이용했을 때<br />
오류가 없었기에</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm <span class="nb">install </span>16
</code></pre></div></div>
<p>이라고 입력해주면 16버전이 설치된다.</p>

<p>최신 버전을 설치하고 싶을 경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm <span class="nb">install</span> <span class="nt">--lts</span>
</code></pre></div></div>
<p>를 입력해주면 최신버전이 설치가 된다.</p>

<p>만약 설치를 여러개 하였을 때, 버젼을 변경해서 사용하고 싶을 경우<br />
먼저 버전을 확인하고 싶으면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm list
</code></pre></div></div>
<p>명령어로 현재 설치된 버전이 확인된다.</p>

<p>그리고 버전을 변경하고 싶을 경우</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm use 16
</code></pre></div></div>
<p>과 같은 식으로 현재 설치된 버전 중 선택해서 nvm use를 사용하면 변경된다.</p>

<p><br /></p>

<p>이제 실제로 클라이언트를 AWS를 이용해 배포해보자<br />
우선 터미널로 우리가 만든 클라이언트 폴더에 접속한다.</p>

<p>이동완료후 클라이언트 의존성 모듈을 설치해야한다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span>
</code></pre></div></div>
<p>npm은 Node Package Manager로 Node.js로 만들어진<br />
프로그램을 쉽게 설치 혹은 여러기능들을 해주는 것이라 이해하면 쉬울 것 같다.</p>

<p>설치가 완료되었으면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nt">-v</span>
</code></pre></div></div>
<p>명령어로 설치된 버전을 확인할 수 있다.</p>

<p><br /></p>

<p>이제 이 패키지 매니저로 우리는 build 명령을 실행할 것 인데<br />
이전에 우리는 처음에 보았던 이그림을 볼 필요가 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMCqrjaGSYLYkne25hlMNNSGrxxCwtWjwIW1qahU8iTVkaJk3lgQwrF-ArVtHMFQcmUuojJ-JIIdF3Sujk5F4ZZuD8BHQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>현재 클라이언트와 서버가 연결되기 위해서는<br />
build하기 전에 EC2의 주소를 이용해 환경변수로 설정해<br />
연결을 해준 후 build를 진행해야 우리의 EC2 인스턴스와 연결되는 것 같다.</p>

<p>아직 클라이언트 측의 구성이 정확히 어떻게 되어있는지 이해가 가진 않았다.<br />
하지만 React에서 환경 변수를 사용할 경우 <code class="language-plaintext highlighter-rouge">.env</code>파일을 이용해<br />
보안과 유지보수에 용이하게 사용하는 것 같다. (<a href="https://carmack-kim.tistory.com/111">ENV? - 출처: carmack-kim님 블로그</a>)</p>

<p>우선 코드스테이츠 측에서 배포용으로 만들어준<br />
클라이언트 프로그램에 <code class="language-plaintext highlighter-rouge">.env</code>파일에 EC2 경로를 추가해줘야한다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNOxhLDZ27Sr73PjkWiOEuy7fxEbUeO8PExbopcMOhYwIE9voaaFWfTIfwUI1LRemjgPfidns6Qnaawzke-k1y8su_mvg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>내 EC2 인스턴스의 <code class="language-plaintext highlighter-rouge">퍼블릭 IPv4 DNS</code>를 입력해주면 된다.<br />
환경 변수 설정이 끝났으면 이제 <code class="language-plaintext highlighter-rouge">npm</code>을 이용해 build를 진행해주면된다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm run build
</code></pre></div></div>
<p>를 입력해주면 build가 되어질 것이고</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMm2-cXyHyX_Dka-3eOFxiBi9Shvt6NpdXGyr4eeNvSiqYakRmHEw2IsC8VT2TjTHetmajHF85bfA8RoFaMV30SGUGA_Q=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><code class="language-plaintext highlighter-rouge">Compiled successfully</code>가 콘솔에 확인된다면<br />
정상적으로 완료되었을 것이고 build 폴더가 생겼을 것이다.</p>

<p>이제 클라이언트 프로그램이 build가 되었으니<br />
AWS의 S3 버킷에 올리기만하면 된다.</p>

<p><br /></p>

<h4 id="2-build-파일-업로드">2. build 파일 업로드</h4>

<p>여기서 버킷은 만들어져있다고 가정하고</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMt5DZC0u-iy00YbD24vOXQHSgoZuuE3TaqTJ9DKfV-rmiIHkzsemBccNULT5kX_op5CnQacIHp5zQqVrlpkoHVq0Hpvg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>만들어진 버킷을 보면 여러가지 확인과 설정을 할 수 있다.<br />
객체에는 우리가 build한 파일을 업로드해주면된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gP--JcVN_ro93rs0B8hRPIIlA8cCBE6S6EwLJ0t8J6FoCOkT2t2sGTXUypnYqIlnkgbzpmm2hhe5bT29_pdZrIg0EFejQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p><br /></p>

<h4 id="3-정적-웹사이트-호스팅-및-정책-설정확인">3. 정적 웹사이트 호스팅 및 정책 설정확인</h4>

<p>속성에서 정적 웹 사이트 호스팅 편집이 가능하다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMuwTO1DRQvt3Cq_twhIxiSqw1TII2qdRKLPP1A5l32tOAWB9D4xT2R0aajpK14WWMR1RF9fp24Z_JH1hvhgchn4Luc=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>활성화를 눌러준 후 여러 설정을 할 수 있다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMRTfdAd-MrGvJWcOs8k6c8JsWUMENpfp8NHUYwB-wB_CcLPM9vI8MpR8NZFGUh9-MO4Pj_Jo_rIL98SAsTcQe0dO4pvw=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 변경 저장을하면 엔드포인트를 확인할 수 있다.<br />
해당 엔드포인트로 접속 시 우리가 빌드한 html을 확인할 수 있다.<br />
하지만 만약 퍼블릭 엑세스 활성화를 하지 않았다면</p>

<p>403 Forbidden 화면을 보게 될 것이다.<br />
아래에서 설정해보자</p>

<p><br /></p>

<h4 id="4-퍼블릭-엑세스-활성화">4. 퍼블릭 엑세스 활성화</h4>

<p>권한 텝에서 먼저</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOySHGyNBeD5ROwQcYrc7Q-LryyL0GpHOOWLW9cpO8IoJG2o0s68sAqdvbZYp07vh5vzgXQ4tz4Wx5FnXTVYJ-arLdYHg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>모든 퍼블릭 엑세스 차단 체크박스를 해제하고<br />
변경 사항을 저장해준다.</p>

<p>그리고 버킷 정책에서<br />
편집 -&gt; 정책 생성기를 눌러</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gORyh2hy9R7NQi5ZFdxelWkB9PXqXFFkf5od8ptjyq_M2q6gMll9UJC8QAh0CWB0jNWXzOzEnN43dPeJJbeI9uPJFow=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>정책에 대한 내용을 적어준다.<br />
해당 부분은 추후에 어떤 정책인지에 대한 내용은<br />
어드벤스한 공부가 필요해보인다..</p>

<p>우선 위와 같이 입력 완료 후<br />
하단에 Add Statement를 눌러주면 Json 형태로 객체가 하나 나온다.<br />
해당 코드 값을 복사해 정책 코드란에다가 붙여 넣어주면 된다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gO4sb2RQfnC9UAo9e3mqbNuAUAYCqlGSgh9Xi-0UL5QX5vFoKRL5G--penSCYSkN1KGUQN9LzKuR-cfxL8-qPOIjrhT=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 변경 사항 저장을 눌러주면<br />
해당 버킷에 대한 정책이 적용되어 퍼블릭 엑세스가 가능해진다.<br />
아마 어디서든 접근이 가능하게 만들어진 것 같다.</p>

<p>우선 이렇게 클라이언트에 배포를 하고 정책을 설정에 권한 부여를<br />
할 수 있다는 흐름만 이해해야할 것 같다.</p>

<p>이제 정상적으로 엔드포인트에 접속하면 우리가 만든 화면을 볼 수 있다.<br />
여기서 알아둬야할 점은 클라이언트 S3에 설정이 끝났을 뿐<br />
EC2에서는 S3의 엔드포인트를 config.domain에 설정해줘야한다.<br />
설정해보기전에 RDS먼저 셋팅을 진행해보자</p>

<p><br /></p>

<h3 id="데이터베이스-연결">데이터베이스 연결</h3>

<p>이제 RDS 인스턴스를 생성하고 연결해보자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPt7L85pyOiBzvoUv4AoWFQRcZrAeTXi1e88euqY0WZwdeBy-fExoGosLSe_fFHmiIRcbyGesHL6tk9uH-P1LcPtRPHMQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>상단에서 RDS를 검색하여 데이터베이스 생성을 눌러준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN269A-5fP5DuTNlzYOxjstGaW4ZQ7LhDuRqYLKO0zE0bSCrP8VS9z6hcT9CNfpacjfrb1_r44aoGEjD-HkeYCIOm5dxQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>사용하려는 데이터베이스의 엔진을 선택 !<br />
나는 MySQL을 사용</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gORLVLuS8ordfLtooWUbgVapIf3PXVhjfSzClCSkdgFuaSgubU5LQwJs1HAIUh0GmqIBEOcCvuXN2pxthcBLJQpCtxFeA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>템플릿은 프리티어로 설정했다. 프리티어로 설정하면<br />
MySQL의 db.t2.micro 인스턴스는 750시간이 무료사용 가능한 것 같다.<br />
<a href="https://aws.amazon.com/ko/rds/free/">참고 - AWS 프리티어</a></p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPMDaskil2A9TqVUKLCShge25ti9mtf2nQUp67wJyOgx7ow6BFZNJQ-S1JUZAEjk_aqGqqo_ReFq4R1pTVp12HqdrnhGQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>여기서 이제 우리가 기억해야하는 부분이 나왔다.</p>

<p>✅ 마스터 사용자 이름과 마스터 암호는<br />
나중에 DB에 접근할때 꼭 필요한 값이니 기억해두거나<br />
어딘가에 저장해두자 !</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOqZjz97jIYND5PWh2kLo8O1rrpMicafKcPaDK7e4aOHR27d0apBQl3NJJ2G-ZTCiuTxoZ8wHnQ1MjwgQKaNaENBCUZBg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위에서 얘기했던 무료로 사용하기 위해 해당 옵션으로 설정</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOQ9Fc1p6L13bXI707a9Csgcs0oyQWQQvA7c4ZJs5x248-Mie6dXx8AZ04E_4_7oQjDmYuqy2Z0aixPrjjEg6wa--G5gg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>퍼블릭 엑세스는 허용으로 해준다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMUDem6XIZCQA8hwXlATX6_JFFwo6w0ZNGrodOWnnmxjprmpjBmv1DKnJxcr3PGrahMDy_sVeqWftBU84OAozCd_WnXkQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>그리고 데이터 베이스를 사용하기 위한<br />
포트번호를 설정해둔다. 기본값은 3306이고<br />
13306으로 변경해서 사용하려고 변경했다.</p>

<p><br /></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOFFsQrJPtaKbAFAE6XirmNp2zBlyHRpgE4iOm9Cn1TZsxF6NHQU6N1PLVBSL-7Ay3Hyd6SiR5MrJNV7wEIeACkiiUz6w=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>추가 구성을 눌러<br />
데이터 베이스의 이름을 설정해줄 수 있다.<br />
이름을 지정한대로 후에 조회할때<br />
해당 데이터 베이스 이름으로 조회가 된다. (test라고 지정했다고 가정하자)</p>

<p><br /></p>

<p>이제 모든 설정은 끝났으니<br />
맨 하단에 데이터베이스 생성을 눌러 만들어주자<br />
데이터베이스가 생성이 완료되면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN8tsT3QpYd684mkxbVNM6eWBUfuilsIcfBYaBjqCZfG4awLWyKRCR2NWeH9y4tslTrOXyOUDOfz2Mc7vWUhn6pvYEz=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>엔드 포인트와 설정했던 포트가 확인된다.<br />
이제 우리는 이 데이터베이스로 EC2에서 접근을하면 된다.</p>

<p>접근하기 이전에 정말로 정상적으로 동작되는지 확인해보고 싶다면<br />
터미널로 확인이 가능하다.</p>

<p>이전에 homebrew를 통해 MySQL을 설치했었다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>mysql
</code></pre></div></div>

<p>MYSQL이 정상적으로 설치가 완료되었다면</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql <span class="nt">-u</span> <span class="o">[</span>마스터 이름] <span class="nt">--host</span> <span class="o">[</span>엔드 포인트 주소] <span class="nt">-P</span> <span class="o">[</span>포트 번호] <span class="nt">-p</span>
</code></pre></div></div>
<p>이렇게 입력해주면 터미널로 mysql 접속이 된다.</p>

<p>예를 들어 데이터베이스 만들때 생성했던 정보가 아래와 같다고 가정해보자</p>

<p>마스터 이름 : admin<br />
마스터 비밀번호 : 1234<br />
데이터 베이스 엔드포인트 : be-88-mycatlikeschuru.c0nwl8c1futc.ap-northeast-2.rds.amazonaws.com</p>

<p>위와 같다고 가정할 때 아래와 같이 터미널에 명령을 실행시켜주면 된다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> mysql <span class="nt">-u</span> admin <span class="nt">--host</span> be-88-mycatlikeschuru.c0nwl8c1futc.ap-northeast-2.rds.amazonaws.com <span class="nt">-P</span> 13306 <span class="nt">-p</span>
</code></pre></div></div>
<p>위와 같이 입력하면 비밀번호를 입력라고 나올텐데<br />
우리가 설정했던 마스터 비밀번호 1234를 입력해주면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMOglrCiBEQQTzd9iNGlQLu4azD8EDI_e2QjmV4gPddeD7GCX8znn1b6L0BZSRTPu4ssWWyEg4vu12DNRtZF3rLBTBW=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같이 mysql에 접근할 수 있는 것을 확인 할 수 있다.<br />
실제로 <code class="language-plaintext highlighter-rouge">show databases;</code>를 입력해서<br />
우리가 데이터베이스를 만들때 추가구성에서 넣었던 이름인<br />
<code class="language-plaintext highlighter-rouge">test</code> 데이터베이스가 있는 것을 확인할 수 있다.</p>

<p>이제 정상적으로 데이터베이스가 작동된다는 것도 확인하였고<br />
이제 EC2에서 S3와 RDS를 연결해줘야한다.</p>

<p><br /></p>

<h3 id="클라이언트---서버---db">클라이언트 - 서버 - DB</h3>

<p>위에서 클라이언트와 데이터베이스까지 생성하고 설정까지 끝냈다.</p>

<p>EC2는 생각보다 간단하다.<br />
여태까지 우리가 많이 설정해왔던 방식이고 익숙하기 때문이다.</p>

<p><code class="language-plaintext highlighter-rouge">.yml</code>파일이거나 혹은 <code class="language-plaintext highlighter-rouge">.properties</code>파일에 설정해주면된다.<br />
<code class="language-plaintext highlighter-rouge">.properties</code>파일로 만들었으니 해당 기준으로 적어본다.</p>

<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.jpa.database</span><span class="p">=</span><span class="s">mysql</span>
<span class="py">spring.jpa.database-platform</span><span class="p">=</span><span class="s">org.hibernate.dialect.MySQL5InnoDBDialect</span>
<span class="py">spring.datasource.url</span><span class="p">=</span><span class="s">jdbc:mysql://[AWS RDS 엔드포인트]/test?useSSL=false&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span>
<span class="py">spring.datasource.username</span><span class="p">=</span><span class="s">[RDS 마스터 이름]</span>
<span class="py">spring.datasource.password</span><span class="p">=</span><span class="s">[RDS 마스터 비밀번호]</span>
<span class="py">spring.datasource.driver-class-name</span><span class="p">=</span><span class="s">com.mysql.cj.jdbc.Driver</span>
<span class="py">config.domain</span><span class="p">=</span><span class="s">[AWS S3 엔드포인트]</span>
</code></pre></div></div>
<p>위에 처럼 이제 우리가 모두 알 수 있는 정보다</p>

<p>RDS를 만들었기에 엔드포인트를 알 수 있고<br />
마스터 이름과 비밀번호도 우리가 생성했다.</p>

<p>그리고 S3와 연결하기 위해 즉, 클라이언트와 연결하기위해<br />
AWS S3 엔드포인트를 설정해주면 클라이언트에서<br />
API 요청이 오면 이제 정상적으로 EC2 서버에서 작성한 프로그램대로<br />
동작하는 모습을 확인할 수 있을 것이다.</p>

<p><br /></p>

<hr />

<p>이렇게 아주 기초적인 3티어 아키텍처로<br />
인스턴스를 만들어서 배포를 진행 해보았다.</p>

<p>배포하는 과정에 엄청 공부할게 많구나라고 느꼈다.<br />
지금은 거의 따라하는 수준이지만… 나중에는 실제로 운영을하려면<br />
입맛에 맞게 변경하고 관리를 해야하기 때문에 AWS에 대한<br />
공부가 필요해 보였다.</p>

<p>어제 오늘 이렇게 배포를 해보면서 대략적인 감을 익혔고<br />
같이 페어했던분이랑 너무 재밌게해서<br />
더 오래 기억에 남을 것 같다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김치찌개, 스팸계란부침, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[저번주에는 기본적인 Cloud 운영 환경에 대한 구성들을 배워 보았다. 이번 공부에서는 3티어 아키텍처 형태로 배포하는 방법을 배울 것이고, 저번주에 EC2에 서버를 배포해보는 것까지 해봤었다.]]></summary></entry><entry><title type="html">macOs) brew update Error Another active Homebrew update process is already in progress. 문제 해결</title><link href="http://localhost:4000/macos/2022/12/04/OS-macOs-5.html" rel="alternate" type="text/html" title="macOs) brew update Error Another active Homebrew update process is already in progress. 문제 해결" /><published>2022-12-04T00:00:00+09:00</published><updated>2022-12-04T00:00:00+09:00</updated><id>http://localhost:4000/macos/2022/12/04/OS-macOs-5</id><content type="html" xml:base="http://localhost:4000/macos/2022/12/04/OS-macOs-5.html"><![CDATA[<p>Mac용 패키지 관리자 Homebrew를 사용하다가</p>

<p>brew update 중 아래와 같은 에러가 발생했다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPgnf_Jlr6jF5QrJ3a1bIdej3lBiR4_o-5y7SfrHRjvujgPSqqZkSrl29Kf4TWNO2frqh1AoHoQrYmTsdS_4V134Mnzig=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error: Another active Homebrew update process is already <span class="k">in </span>progress.
Please <span class="nb">wait </span><span class="k">for </span>it to finish or terminate it to <span class="k">continue</span><span class="nb">.</span>
</code></pre></div></div>

<p>내용으로보아선 프로세스가 실행중이니 기다리거나 종료해야하는 것 같다.<br />
아마 brew update중 Ctrl+Z를 눌러 종료하거나 bash를 강제로 끌 경우 <br />
발생하는 것 같다. 만약 다시 brew update를 진행하고 싶다면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNt4jGQKvpg6v4idw1qCOQfMrClt6WEeSjGurKDYsmUv0A6kUzSff5ib5LtR5rpktmwbejPAmrg0g50hQjoqKSAVJsM0w=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>/opt/homebrew/var/homebrew 경로에 있는<br />
locks파일을 삭제해주면 된다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm</span> <span class="nt">-rf</span> /opt/homebrew/var/homebrew/locks
</code></pre></div></div>

<p>터미널 명령어로 삭제를 해도 무방하다.<br />
<strong><em>(여러 블로그를 살펴보니 homebrew 경로가 다른 것 같다.<br />
즉, locks 파일 위치가 환경마다 다른 것 같다..)</em></strong></p>

<p>그렇게 locks 폴더를 삭제 후</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew update
</code></pre></div></div>
<p>다시 진행 해주면 정상적으로 업데이트가 되는 것을 확인 할 수 있다.</p>

<p><br />
<br /></p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="macOs" /><category term="macOs" /><summary type="html"><![CDATA[Mac용 패키지 관리자 Homebrew를 사용하다가]]></summary></entry><entry><title type="html">TIL) Cloud 운영 환경 구성 1</title><link href="http://localhost:4000/til/2022/12/02/til.html" rel="alternate" type="text/html" title="TIL) Cloud 운영 환경 구성 1" /><published>2022-12-02T00:00:00+09:00</published><updated>2022-12-02T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/02/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/02/til.html"><![CDATA[<p>날씨가 갑자기 겨울로 넘어왔다…<br />
손발이 떨릴정도로 이제 추운 날씨가 왔다.</p>

<p>갑자기 추워진만큼 건강관리를 잘해야겠다.<br />
이제 다음주 부터 슬슬 프로젝트가 시작될 것 같으니<br />
열심히 공부해서 참여하도록해야겠다 !</p>

<hr />

<h2 id="운영-환경-구성">운영 환경 구성</h2>

<p>여태까지 애플리케이션을 위한 프로그램을 배웠다면<br />
이제 유저들이 사용할 수 있도록, 웹서비스에 배포를 해야한다.<br />
그러기 위해서는 클라우드 서비스에 대한 내용을 알아야하며<br />
가장 많이 사용하는 <strong>AWS</strong>(Amazon Web Service)를 이용할 예정이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOqOLzNVFQEsg_qVlTE8LMUqfss5wT_TUYqngNJB6_sgDfVqJyntlKRdVf4o86XtCoGcpGM3EHGia4hRgiH-bbS5wnd=w1920-h919" alt="image" class="align-left" style="max-width: 70%" /></p>

<p><br /></p>

<h3 id="cloud-computing">Cloud Computing</h3>

<p>기존에는 같은 공간에 더 많은 컴퓨터를 추가하거나, 컴퓨터 성능을 업그레이드했다.<br />
하지만 이러한 방식에는 한계가 존재했다.</p>
<ol>
  <li>주기적인 관리가 필요</li>
  <li>공간의 한계</li>
</ol>

<p>와 같은 한계가 존재하다보니 거대 기업들은 데이터 센터라는<br />
건물을 세워 유휴 자원을 대여해주는 서비스들이 생기기 시작했다.<br />
이러한 서비스들은 서버의 자원과 공간, 네트워크 환경을 제공해준다.<br />
이러한 환경을 <strong>On-premise</strong>라고 한다.</p>

<p><strong><em>On-Premise : 자체적으로 보유한 전산실 서버에 직접 설치해 운영하는 방식</em></strong></p>

<p><br /></p>

<p>현대의 클라우드 컴퓨팅은 데이터 센터와 비슷한 역할을하지만<br />
물리적인 컴퓨터가 아닌, 가상컴퓨터를 대여해준다는 점이 다르다.</p>

<p>그럼 클라우드 서비스의 장점이 무었이 있냐면</p>
<ol>
  <li>컴퓨팅 능력을 유연하게 조절가능</li>
  <li>사용한 만큼 요금만 지불</li>
  <li>컴퓨터의 스냅샷을 이용해 다른 컴퓨터로 즉시 이주가 가능</li>
</ol>

<p>클라우드 서비스 형태는<br />
SaaS (Software as a Service) : 네트워크+하드웨어+운영체제+DB/플랫폼+애플리케이션<br />
PasS(Platform as a Service) : 네트워크+하드웨어+운영체제+DB/플랫폼<br />
IaaS(Infrastructure as a Service) : 네트워크+하드웨어</p>

<p>이러한 서비스 형태를 제공해주고 서비스 범위가 각각 다르다.<br />
AWS 같은 경우는 IaaS와 가까운 형태이다.</p>

<p><br /></p>

<h3 id="deploy">Deploy</h3>

<p>전개하다, 배포하다라는 의미를 가지고 있다.<br />
배포는 우리가 개발한 서비스를 사용자들이 이용 가능하게 하는 일련의 과정이다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 1단계 : Development  
로컬환경에서 개발 및 테스트 하는 단계이다.  

            ↓

✅ 2단계 : Intergration  
각자의 환경에서 개발된 부분을 취합하는 단계이다.  

            ↓

✅ 3단계 : Staging  
다양한 환경에서 테스트를 진행하는 단계이다.

            ↓

✅ 4단계 : Production  
실제로 서비스가 제공되는 단계이다.  
</code></pre></div></div>

<p>작성한 코드가 다른 환경에서 정상 작동할 수 있게 하려면<br />
설정을 환경변수에 저장해야 한다.<br />
환경 변수는 코드 변경 없이 배포 때마다 쉽게 변경할 수 있다.</p>

<p>이 외에도 docker와 같은 개발 환경 자체를 통일시키는<br />
솔루션을 사용할 수 도 있다.</p>

<p><br /></p>

<h3 id="aws-ec2">AWS EC2</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOtO5zNG-mSGQ0VpIrnDtKv8WjStCZz80s64TdpaTziPs4U4w2NrWWr-2PCFgKEx1F9AZ6MgqbDeUn9oKYze6SjTKfr=w1920-h919" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Amazon Elastic Compute Cloud라고도 부른다.<br />
AWS에서 원격으로 제어할 수 있는 가상의 컴퓨터 한 대를 빌리는 것을 말한다.<br />
이렇게 빌린 컴퓨터를 인스턴스(Instance)라고한다.</p>

<p>Elastic(탄력적인)이라는 영어 단어에서 알 수 있듯이<br />
우리가 사용한 만큼 비용을 지불하기 때문에<br />
비용,성능,용량을 자유롭게 조절할 수가 있다.</p>

<p>EC2의 사용의 장점?</p>
<ol>
  <li>구성하는데 필요한 시간이 짧다</li>
  <li>다양한 운영체제에 대한 선택이 가능하다</li>
</ol>

<p>AMI는 Amazon Machine Image의 약자로<br />
소프트웨어 구성이 기재된 템플릿이다.<br />
(윈도우, 우분투 리눅스, 우분투+node.js 등등)<br />
인스턴스 생성시 선택해야하는 소프트웨어라고 생각하면 될 것 같다.<br />
사용 용도에 맞게 운영체제, 런타임 등의 구성된 셋팅을 선택할 수 있다.</p>

<p><a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html">AWS EC2 설명서</a>를 확인해보면 도움이 될 것 같다.</p>

<p><br /></p>

<h3 id="rds">RDS</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN7nLYSONV59gpEN-AxxvVVseentMz1scQ3svv2baW-tIKb0ddiTx5w_BNK7X9_4WqxQmttPUh9sUH9av2MmooXk_zsYg=w1920-h919" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Relational Database Service의 약자로<br />
AWS에서 제공하는 관계형 데이터 베이스 서비스이다.</p>

<p>EC2에서 빌린 가상의 컴퓨터에서 MySQL을 설치해서 사용할 수도 있다.<br />
하지만 RDS를 따로 사용하는 이유는</p>

<p>EC2 인스턴스를 사용하면 DB 관련해서<br />
자동으로 관리를 담당하는 부분이 매우 적기 때문에, 사용자가 일일이<br />
시간을 투자해서 데이터베이스 엔진의 설치, 버전관리, 데이터 백업을 해야한다.<br />
또한 가용성과 내구성이 확보되지 않기 때문에, DB의 데이터가 유실되가나<br />
정상적으로 사용하지 못할 확률이 커지고, 후에 필요에 따른 확장이 어렵기 때문이다.</p>

<p>즉, RDS를 이용하면 DB 유지보수와 관련된 일을 RDS에서 자동 관리한다.<br />
사용자가 해야할 일은 초기 설정을 제외하고 DB에 저장된 데이터를 관리하는<br />
일 밖에 없어지기 때문에 큰 편의성을 느낄 수 있다.</p>

<p>또한 여러가지 DB 엔진(Oracle, MySQL, MairaDB 등) 선택지를 제공해준다.</p>

<p><br /></p>

<h3 id="s3">S3</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPyX47-O0zlGcOuOrGwR40VZM8bDpk1COUH1tS16G9Z2SxWkYDkjNyVlfi-EuCJ46PbsuRvLkYR_IOIjxQdxQkNKQl1lg=w1920-h919" alt="image" class="align-left" style="max-width: 40%" /></p>

<p>Simple Storage Service를 줄여서 S3라고 부른다.<br />
AWS에서 제공하는 클라우드 스토리지 서비스이며,<br />
클라우드 스토리지 서비스는 인터넷 공간에 데이터를 저장하는 저장소를 얘끼한다.<br />
ex) 구글 드라이브, 아이클라우드 등</p>

<p>S3 사용 시 장점?</p>
<ol>
  <li>데이터를 무한히 저장 가능하다.</li>
  <li>스토리지의 내구성이 높다 (파일 유실가능성이 적다)</li>
  <li>가용성이 보장된다.(저장된 파일들을 정상적으로 사용할 수있는 시간이 길다)</li>
  <li>다양한 스토리지 클래스 제공 <br />
-. Standard 클래스 : 데이터에 자주 엑세스할 때 사용
-. Glacier 클래스 : 데이터를 장기보관할 때 사용</li>
  <li>정적 웹 사이트 호스팅이   가능</li>
</ol>

<p><em><strong>정적 파일 : 서버의 개입없이 생성된 파일</strong></em> <br />
<strong><em>웹 호스팅 : 공간을 임대해 주는 서비스</em></strong></p>

<p>S3에서는 버킷이 사용자들이 웹사이트를 배포할 수 있는 공간을 제공해준다.</p>

<p>버킷은 S3에 저장되는 파일을 담는 최상위 디렉토리이다.<br />
저장되는 파일을 객체라 부르며, 키-값 페어 형식으로 데이터를 저장한다.</p>

<p>또한 S3에 저장되는 객체는 메타데이터가 있다.<br />
객체의 생성일, 크기, 유형등의 정보를 담고있는 데이터 이다.</p>

<p>그리고 모든 객체는 고유한 URL 주소를 가지고 있다.</p>

<p><br /></p>

<h3 id="3-티어-아키텍처">3 티어 아키텍처</h3>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNdT-BlxNhiUbdv4av_8HXLA9C0nN5uxsAAk3-Qs26EWWJPkMA7rgXgpEc8lcRXoiCLRkfMKylvorlDOAMa4WHMIAehjg=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /><br />
<a href="https://docs.aws.amazon.com/ko_kr/whitepapers/latest/serverless-multi-tier-architectures-api-gateway-lambda/three-tier-architecture-overview.html">출처 - amazon 3 Tier Architecture</a></p>

<p>3 티어 아키텍처는 배포 전략중 하나로 <br />
Client, Server, Database로 나누어 서비스를 제공할 수 있다.</p>

<p>S3 서비스로 Client를 제공할 수 있다.<br />
EC2 서비스로 Sever를 제공해줄 수 있다.  <br />
RDS 서비스로 Database를 제공해줄 수 있다.</p>

<p><br /></p>

<h3 id="서버-배포">서버 배포</h3>

<p>인스턴스 생성과정은 생략하려한다. AMI는 우분투이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOOs9dXoVlxUnDghCnZt618o7m0rdY0vzDl18ChINSDbBBG7Gpl-cj3FrS4dV5hrez8sLKsR2mKROev8SUXg0OjTvRwHQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>인스턴스에 연결을 하면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gN2yvWvOOqcKCByF_cKadUZS6r1gMIDTDoH64uyFEmX7xamfZe9zoqlkICswPW6q0f5r6Xn9NN2Y-DiMKLIOg0E_fLbVA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>위와 같은 화면이 뜬다. 이제 여기서 나는 bash가 편하기때문에</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash
</code></pre></div></div>

<p>그리고 폴더 Root경로를 상단으로 변경했다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~
</code></pre></div></div>
<p>여기서 root경로를 상단에 두지않고 <code class="language-plaintext highlighter-rouge">git clone</code>과 같은 명령어를<br />
내보낼 경우 Permission denied 에러가 발생할 수 있으니 주의하자</p>

<p>본격적으로 인스턴스에 개발환경을 구축해야한다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
</code></pre></div></div>
<p>패키지 매니저가 관리하는 패키지의 정보를 최신 상태로 업데이트한다.</p>

<p><br /></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-11-jre-headless
</code></pre></div></div>
<p>그리고 jdk를 설치해준다. 확인창이나오면 “Y”를 눌러 진행</p>

<p>설치가 완료되었으면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">--version</span>
</code></pre></div></div>
<p>을 입력하여 설치가 잘되었는지 확인이 가능하다.</p>

<p>이제 우리가 배포하기위한 프로젝트를 Git에서 가져오면된다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone 레포지토리주소
</code></pre></div></div>
<p>여기서 처음 셋팅하는 경우에는<br />
SSH Key를 우분투에 발급 받아야한다.<br />
그리고 발급받은 공개키를 GitHub SSH keys에 셋팅을 해줘야<br />
우분투 서버에서 GitHub를 통해 clone을 해올 수 있다..</p>

<p>키 발급과 등록하는것은 생략하겠다.</p>

<p>이제 우리의 프로젝트를 가져왔으니<br />
해당 프로젝트를 빌드해야한다. 우선 폴더경로로 진입해서</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./gradlew build
</code></pre></div></div>
<p>파일을 빌드시켜주면 된다.</p>

<p>그리고 빌드된 .jar파일을 통해 java를 실행시켜보면</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-jar</span> build/libs/DeployServer-0.0.1-SNAPSHOT.jar
</code></pre></div></div>
<p>Jar파일의 폴더 경로를 지정한 것이다.<br />
그러면 내 인스턴스에서 만들었던 Spring 프로젝트가</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNrA5k8JSBJnGbyXfOB8y2Rm398vzC329yxq29jDQqLacYTabUWRlV00FKA9lkb88EcT00KBsWN-e9S0PV3Re4DgW9B=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>정상 적으로 실행된 모습을 볼 수 있다.</p>

<p>이제 인스턴스의 <code class="language-plaintext highlighter-rouge">퍼블릭 IPv4 DNS</code> 주소를 <code class="language-plaintext highlighter-rouge">:8080</code> 포트를 붙여<br />
웹 브라우저 상에서 접속을 시도해본다면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMEFzEzwGnFUUnCFLAnVY5C946SOyarcOzfBaUdrBE5Y1JhIJZ_JZ-Dl75VdRWuUackRT7Pgkh9b-ofsr_OIwxfgXLeaQ=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>내가 만들었던 프로젝트가 정상적으로<br />
보이는 것을 확인할 수 있다.</p>

<p><br /></p>

<hr />

<p>오늘은 이렇게 Cloud 운영환경에 대해 기초 지식과<br />
실제로 Spring 프로젝트 파일을 빌드해보았다.</p>

<p>여러가지로 신기하고 재밌었다.<br />
이렇게 가상으로 컴퓨터를 빌려 정말 간단하게 운영이 가능하다니..<br />
얼추 이제 어떻게 시스템이 구성되어있고 각자의 위치가<br />
어느정도 감이 잡히고 있다.</p>

<p>요번주도 공부하느라 고생많았다 !!!!<br />
주말에 프로젝트 대비를 위함 Spring MVC 공부를 더해야겠다.</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 김밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[날씨가 갑자기 겨울로 넘어왔다… 손발이 떨릴정도로 이제 추운 날씨가 왔다.]]></summary></entry><entry><title type="html">TIL) Spring WebFlux 구현하기</title><link href="http://localhost:4000/til/2022/12/01/til.html" rel="alternate" type="text/html" title="TIL) Spring WebFlux 구현하기" /><published>2022-12-01T00:00:00+09:00</published><updated>2022-12-01T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/12/01/til</id><content type="html" xml:base="http://localhost:4000/til/2022/12/01/til.html"><![CDATA[<p>12월이 시작되었다 !<br />
올해도 이렇게 시간이 빨리가는 구나<br />
점점 더빨리가는 시간이 조금 야속하다.</p>

<p>그래도 내가 당장할 수 있는 일에<br />
늘 집중할 수 있게 다시한번 마음을 다져보며<br />
오늘 공부를 시작해보자</p>

<hr />

<p>오늘은 WebFlux 기술을 이용한 애플리케이션을 구현해볼 생각이다.</p>

<h3 id="spring-webfulx-">Spring WebFulx ?</h3>

<p>Spring WebFlux는 전통적인 Spring MVC방식의 애플리케이션보다<br />
대량 클라이언트 요청을 좀 더 효율적으로 처리할 수 있는 현대적인<br />
애플리케이션 구현을 위한 기술이라고 한다.</p>

<p>Spring 5에 Reactive 스택이라는 기술이 새롭게 추가되었고<br />
해당 기술에서 지원하는 타입 <code class="language-plaintext highlighter-rouge">Mono</code>와 <code class="language-plaintext highlighter-rouge">Flux</code>를 사용 했던 걸<br />
이전에 <a href="https://mycatlikeschuru.github.io/til/2022/11/30/til.html">Project Reactor</a>를 공부 하면서 배웠었다.</p>

<p>한마디로 저의를 하자면, Spring WebFlux는 <br />
리액티브 웹 애플리케이션을 위한 웹 프레임워크이다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gPoDOocq2SqLuJtAX2FsfgKnh4PxlFxW5qpbRJoRuH6MuZSKYcSqpK9hsYGiSumVaYCclCg3iKyd351ISGmBJNX3xHw=w777-h753" alt="image" class="align-left" style="max-width: 100%" /><br />
<a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web-reactive.html#webflux-framework-choice">출처 - spring.io</a></p>

<p>Spring MVC와 Spring WebFlux를 벤다이어그램으로 비교한 사진이다.</p>

<p>이제 클라이언트의 요청을 적으로 받는다고 했었는데<br />
어떻게 차이가나는지 한번 비교해보자</p>

<p><br /></p>

<h3 id="spring-mvc-vs-spring-webflux">Spring MVC vs Spring WebFlux</h3>

<p>두개의 프레임워크를 사용해 어떠한 차이가 있는지 확인해보려한다.<br />
테스트 방식은 서버 2개를 띄워서 한쪽에서 다른쪽을 여러번 동시에 요청하였을 경우<br />
어떻게 처리가 진행되어지는지 비교해보자</p>

<p><br /></p>

<p><strong>1). Spring MVC 테스트 하기</strong></p>

<p>IntelliJ의 Spring Project를 두개를 만들고 각각 다른 서버로 만들 것이다.</p>
<ol>
  <li>호출하는 서버 - MAIN , PORT 8080</li>
  <li>호출받는 서버 - OUT, PORT 7070</li>
</ol>

<p>위와 같이 이름을 정해놓고 포트는</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">server</span><span class="pi">:</span>
  <span class="na">port</span><span class="pi">:</span> <span class="m">7070</span>
</code></pre></div></div>
<p>.yml 파일에 추가를 통해 변경이 가능하다.<br />
우선 MAIN 서버 부터 코드를 작성해보자</p>

<p><br /></p>

<ul>
  <li><strong>Main 서버</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/v11/coffees"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringMvcMainCoffeeController</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>

    <span class="nc">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">"http://localhost:7070/v11/coffees/1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">SpringMvcMainCoffeeController</span><span class="o">(</span><span class="nc">RestTemplateBuilder</span> <span class="n">restTemplateBuilder</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">restTemplate</span> <span class="o">=</span> <span class="n">restTemplateBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{coffee-id}"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">getCoffee</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"coffee-id"</span><span class="o">)</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# call Spring MVC Main Controller: {}"</span><span class="o">,</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
        <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">CoffeeResponseDto</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForEntity</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="nc">CoffeeResponseDto</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getBody</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>해당 Controller가 호출되었을 때, OUT서버를 호출하는 프로그램이다.<br />
log로 현재 시간을 기록해 시간을 체크할 예정이다.<br />
(Dto 코드는 간단하기 때문에 따로 올리지 않겠습니다!)</p>

<p>그리고 Spring 애플리케이션쪽에는</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringMvcMainSampleApplication</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SpringMvcMainSampleApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="nc">CommandLineRunner</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# 요청 시작 시간: {}"</span><span class="o">,</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
				<span class="nc">CoffeeResponseDto</span> <span class="n">response</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getCoffee</span><span class="o">();</span>
				<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"{}: coffee name: {}"</span><span class="o">,</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">(),</span> <span class="n">response</span><span class="o">.</span><span class="na">getKorName</span><span class="o">());</span>
			<span class="o">}</span>
		<span class="o">};</span>
	<span class="o">}</span>

	<span class="c1">// Postman처럼 아래 주소로 5번 요청</span>
	<span class="c1">// 그에따른 7070 서버에 5번 요청</span>
	<span class="kd">private</span> <span class="nc">CoffeeResponseDto</span> <span class="nf">getCoffee</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">RestTemplate</span> <span class="n">restTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RestTemplate</span><span class="o">();</span>
		<span class="nc">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">"http://localhost:8080/v11/coffees/1"</span><span class="o">;</span>
		<span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">CoffeeResponseDto</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForEntity</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="nc">CoffeeResponseDto</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

		<span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">getBody</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">CommandLineRunner</code>를 반환타입으로한 메서드로<br />
애플리케이션이 실행 시 5번 MAIN서버 API를 요청하도록 하였다.<br />
5번을 실행하면서 OUT서버에서 응답받은 Coffee 이름과 현재 시간을 기록하게 작성했다.</p>

<p><br /></p>

<p>이제 MAIN서버에서 호출받는 OUT서버를 작성해보자</p>

<ul>
  <li>OUT 서버
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/v11/coffees"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringMvcOutboundCoffeeController</span> <span class="o">{</span>
  <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{coffee-id}"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">getCoffee</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"coffee-id"</span><span class="o">)</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
      <span class="nc">CoffeeResponseDto</span> <span class="n">responseDto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CoffeeResponseDto</span><span class="o">(</span><span class="n">coffeeId</span><span class="o">,</span> <span class="s">"카페라떼"</span><span class="o">,</span> <span class="s">"CafeLattee"</span><span class="o">,</span> <span class="mi">4000</span><span class="o">);</span>

      <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
      <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">ok</span><span class="o">(</span><span class="n">responseDto</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>간단하다 MAIN서버에서 API호출 받는 서버로 Port번호는 7070으로 변경했다.<br />
쓰레드를 5초간 정지시켜놓고 응답을해주는 프로그램이다.</p>
  </li>
</ul>

<p>이제 OUT서버 애플리케이션을 먼저 실행시킨후<br />
MAIN서버 애플리케이션을 동작시키면 작성한 코드에 의해 OUT서버 API가 5번 호출 될 것이다.</p>

<p>MAIN서버에서 출력된 로그를 확인해보면</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2022-12-01 21:35:51.097  INFO 46801 --- [nio-8080-exec-1] c.c.c.c.SpringMvcMainCoffeeController    : # call Spring MVC Main Controller: 2022-12-01T21:35:51.097332
2022-12-01 21:35:56.325  INFO 46801 --- [           main] c.c.SpringMvcMainSampleApplication       : 21:35:56.325066: coffee name: 카페라떼
2022-12-01 21:35:56.330  INFO 46801 --- [nio-8080-exec-5] c.c.c.c.SpringMvcMainCoffeeController    : # call Spring MVC Main Controller: 2022-12-01T21:35:56.330589
2022-12-01 21:36:01.354  INFO 46801 --- [           main] c.c.SpringMvcMainSampleApplication       : 21:36:01.354035: coffee name: 카페라떼
2022-12-01 21:36:01.367  INFO 46801 --- [nio-8080-exec-3] c.c.c.c.SpringMvcMainCoffeeController    : # call Spring MVC Main Controller: 2022-12-01T21:36:01.367418
2022-12-01 21:36:06.388  INFO 46801 --- [           main] c.c.SpringMvcMainSampleApplication       : 21:36:06.388594: coffee name: 카페라떼
2022-12-01 21:36:06.399  INFO 46801 --- [nio-8080-exec-6] c.c.c.c.SpringMvcMainCoffeeController    : # call Spring MVC Main Controller: 2022-12-01T21:36:06.399304
2022-12-01 21:36:11.428  INFO 46801 --- [           main] c.c.SpringMvcMainSampleApplication       : 21:36:11.428414: coffee name: 카페라떼
2022-12-01 21:36:11.444  INFO 46801 --- [nio-8080-exec-2] c.c.c.c.SpringMvcMainCoffeeController    : # call Spring MVC Main Controller: 2022-12-01T21:36:11.444136
2022-12-01 21:36:16.466  INFO 46801 --- [           main] c.c.SpringMvcMainSampleApplication       : 21:36:16.466802: coffee name: 카페라떼
</code></pre></div></div>
<p>5초 간격으로 API가 호출된 것을 볼 수 있다. <br />
총 25초 정도 소요되었음을 확인할 수 있다.</p>

<p>이유는 무었일까? Spring MVC는 Blocking 처리 방식이기 때문에<br />
5번의 요청이 빠르게 들어와도 하나의 요청처리가 끝나고<br />
다음 처리를 하지못하는 모습을 볼 수 있다.</p>

<p><br /></p>

<p><strong>2). Spring WebFlux 테스트 하기</strong></p>

<p>그럼 우리가배운 Non-Blocking처리를 하는<br />
Spring WebFlux를 사용해서 한번 작성해보자.<br />
방식은 Spring MVC와 동일 방법으로 테스트를 진행해보려한다.</p>

<ul>
  <li>MAIN 서버</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/v11/coffees"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringWebFluxMainCoffeeController</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">"http://localhost:7070/v11/coffees/1"</span><span class="o">;</span>

    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">)</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{coffee-id}"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">CoffeeResponseDto</span><span class="o">&gt;</span> <span class="nf">getCoffee</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"coffee-id"</span><span class="o">)</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# call Spring WebFlux Main Controller: {}"</span><span class="o">,</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
        <span class="k">return</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
                <span class="o">.</span><span class="na">get</span><span class="o">()</span>
                <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">uri</span><span class="o">)</span>
                <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
                <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">CoffeeResponseDto</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>마찬가지로 OUT서버를 호출하는 동작이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@SpringBootApplication</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringWebFluxMainSampleApplication</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"reactor.netty.ioWorkerCount"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span>
		<span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SpringWebFluxMainSampleApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Bean</span>
	<span class="kd">public</span> <span class="nc">CommandLineRunner</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="o">(</span><span class="nc">String</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
			<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# 요청 시작 시간: {}"</span><span class="o">,</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>

			<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
				<span class="k">this</span><span class="o">.</span><span class="na">getCoffee</span><span class="o">().</span><span class="na">subscribe</span><span class="o">(</span>
                                        <span class="n">response</span> <span class="o">-&gt;</span> <span class="o">{</span>
                                            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"{}: coffee name: {}"</span><span class="o">,</span> <span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">(),</span> <span class="n">response</span><span class="o">.</span><span class="na">getKorName</span><span class="o">());</span>
                                        <span class="o">}</span>
                <span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">CoffeeResponseDto</span><span class="o">&gt;</span> <span class="nf">getCoffee</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">"http://localhost:8080/v11/coffees/1"</span><span class="o">;</span>
        <span class="k">return</span> <span class="nc">WebClient</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
                <span class="o">.</span><span class="na">get</span><span class="o">()</span>
                <span class="o">.</span><span class="na">uri</span><span class="o">(</span><span class="n">uri</span><span class="o">)</span>
                <span class="o">.</span><span class="na">retrieve</span><span class="o">()</span>
                <span class="o">.</span><span class="na">bodyToMono</span><span class="o">(</span><span class="nc">CoffeeResponseDto</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Spring MVC와 동일하게 Spring WebFlux 방식으로<br />
OUT서버를 호출하는 프로그램이다.</p>

<ul>
  <li>OUT 서버
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/v11/coffees"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringWebFluxOutboundCoffeeController</span> <span class="o">{</span>
  <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">)</span>
  <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/{coffee-id}"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">CoffeeResponseDto</span><span class="o">&gt;</span> <span class="nf">getCoffee</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"coffee-id"</span><span class="o">)</span> <span class="kt">long</span> <span class="n">coffeeId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
      <span class="nc">CoffeeResponseDto</span> <span class="n">responseDto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CoffeeResponseDto</span><span class="o">(</span><span class="n">coffeeId</span><span class="o">,</span> <span class="s">"카페라떼"</span><span class="o">,</span> <span class="s">"CafeLattee"</span><span class="o">,</span> <span class="mi">4000</span><span class="o">);</span>

      <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span>
      <span class="k">return</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="n">responseDto</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>이제 OUT 서버도 동일하게 쓰레드에 5초의 딜레이를 걸어놓고<br />
OUT서버 애플리케이션부터 실행하고 MAIN서버를 실행하게되면</p>
  </li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2022-12-01 21:41:38.540  INFO 47287 --- [ctor-http-nio-1] c.c.SpringWebFluxMainSampleApplication   : 21:41:38.540514: coffee name: 카페라떼
2022-12-01 21:41:38.541  INFO 47287 --- [ctor-http-nio-1] c.c.SpringWebFluxMainSampleApplication   : 21:41:38.541614: coffee name: 카페라떼
2022-12-01 21:41:38.543  INFO 47287 --- [ctor-http-nio-1] c.c.SpringWebFluxMainSampleApplication   : 21:41:38.543159: coffee name: 카페라떼
2022-12-01 21:41:38.544  INFO 47287 --- [ctor-http-nio-1] c.c.SpringWebFluxMainSampleApplication   : 21:41:38.544006: coffee name: 카페라떼
2022-12-01 21:41:38.544  INFO 47287 --- [ctor-http-nio-1] c.c.SpringWebFluxMainSampleApplication   : 21:41:38.544734: coffee name: 카페라떼
</code></pre></div></div>
<p>이렇게 콘솔에 로그가 발생할 것이다.<br />
우리가 요청시간을 확인하려고 남긴로그고 실제로 로그 시간을 확인해보면<br />
1초도 차이나지않게 5개의 요청이 전부처리가된 것을 볼 수 있다.</p>

<p>이 말은 즉, Non-Blocking 처리방식이다.<br />
여러번의 요청이 들어와도 밀리지 않고 동작이 동시에 처리된 모습이다.</p>

<p>이렇게 Non-Blocking으로 처리되는 것을 눈으로 보았는데<br />
실제 Spring WebFlux안에는 이렇게 처리해줄 수 있는<br />
엄청난 기술과 코드가 들어가 있을 것이다.. 실제로 Spring MVC처럼<br />
클래스를 모두 찾아보고 아키텍처를 그리고 상속관계를 파악해보고<br />
깊게 탐구해보고 싶지만… 현실적으로 지금 공부하는 단계에서는 전부 확인하는 것은<br />
무리가 있어보인다. 이렇게 사용을하면 일단.. Non-Blocking 처리가 되는구나! 하고<br />
후에 Advance한 공부를 해야할 것 같다.</p>

<p><br /></p>

<h3 id="spring-webflux-적용">Spring WebFlux 적용</h3>

<p>실제로 우리가 Controller 계층과 Service 계층에<br />
어떻게 Spring WebFlux를 적용할 수 있는지 알아보자</p>

<p>애플리케이션 컨셉은<br />
커피를 등록하면 해당 커피가 DB에 저장되는 컨셉이며<br />
H2 Database를 사용하였다.</p>

<p>우선 resources로 활용할 데이터를 저장해야한다.<br />
첫번째로 <code class="language-plaintext highlighter-rouge">.sql</code> 파일을 작성해야한다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE IF NOT EXISTS COFFEE (
    COFFEE_ID bigint NOT NULL AUTO_INCREMENT,
    KOR_NAME varchar(100) NOT NULL,
    ENG_NAME varchar(100) NOT NULL,
    PRICE number NOT NULL,
    COFFEE_CODE char(3) NOT NULL,
    COFFEE_STATUS varchar(100) NOT NULL,
    CREATED_AT datetime NOT NULL,
    LAST_MODIFIED_AT datetime NOT NULL,
    PRIMARY KEY (COFFEE_ID)
);
</code></pre></div></div>

<p>그리고 <code class="language-plaintext highlighter-rouge">.yml</code> 파일을 설정해주자</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">r2dbc</span><span class="pi">:</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">r2dbc:h2:mem:///test;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE</span>
    <span class="na">username</span><span class="pi">:</span> <span class="s">sa</span>
    <span class="na">password</span><span class="pi">:</span>
  <span class="na">sql</span><span class="pi">:</span>
    <span class="na">init</span><span class="pi">:</span>
      <span class="na">schema-locations</span><span class="pi">:</span> <span class="s">classpath*:db/h2/schema.sql</span>
<span class="na">logging</span><span class="pi">:</span>
  <span class="na">level</span><span class="pi">:</span>
    <span class="na">org</span><span class="pi">:</span>
      <span class="na">springframework</span><span class="pi">:</span>
        <span class="na">r2dbc</span><span class="pi">:</span> <span class="s">DEBUG</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">schema.sql</code>은 위에서 설정한 <code class="language-plaintext highlighter-rouge">.sql</code>파일이름이다.<br />
<code class="language-plaintext highlighter-rouge">r2dbc</code>를 설정해줘야 h2 데이터베이스를 웹으로 접근할 수 있다.<br />
후에 아래에서 접근하기 위한 코드를 작성해야한다.</p>

<p>그리고 <code class="language-plaintext highlighter-rouge">build.gradle</code> 파일의 설정이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">webflux</span><span class="err">'</span> <span class="c1">// 추가</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">validation</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">data</span><span class="o">-</span><span class="n">r2dbc</span><span class="err">'</span> <span class="c1">// 추가</span>
	<span class="n">compileOnly</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">projectlombok</span><span class="o">:</span><span class="n">lombok</span><span class="err">'</span>
	<span class="n">annotationProcessor</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">projectlombok</span><span class="o">:</span><span class="n">lombok</span><span class="err">'</span>
	<span class="n">testImplementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">boot</span><span class="o">:</span><span class="n">spring</span><span class="o">-</span><span class="n">boot</span><span class="o">-</span><span class="n">starter</span><span class="o">-</span><span class="n">test</span><span class="err">'</span>
	<span class="n">testImplementation</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">projectreactor</span><span class="o">:</span><span class="n">reactor</span><span class="o">-</span><span class="n">test</span><span class="err">'</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">mapstruct</span><span class="o">:</span><span class="nl">mapstruct:</span><span class="mf">1.5</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="na">Final</span><span class="err">'</span>
	<span class="n">annotationProcessor</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">mapstruct</span><span class="o">:</span><span class="n">mapstruct</span><span class="o">-</span><span class="nl">processor:</span><span class="mf">1.5</span><span class="o">.</span><span class="mi">1</span><span class="o">.</span><span class="na">Final</span><span class="err">'</span>
	<span class="n">runtimeOnly</span> <span class="err">'</span><span class="n">io</span><span class="o">.</span><span class="na">r2dbc</span><span class="o">:</span><span class="n">r2dbc</span><span class="o">-</span><span class="n">h2</span><span class="err">'</span> <span class="c1">// 추가</span>
	<span class="n">implementation</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">h2database</span><span class="o">:</span><span class="n">h2</span><span class="err">'</span> 
<span class="o">}</span>
</code></pre></div></div>
<p>여러가지가 있지만 우리가 WebFlux를 사용하기 위해<br />
추가한 의존라이브러리 <code class="language-plaintext highlighter-rouge">// 추가</code>라고 되어있는 부분을 꼭 추가해주자</p>

<p>처음으로는 h2 DB를 접근할 수 있는 코드를 작성해보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">H2Console</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Server</span> <span class="n">webServer</span><span class="o">;</span>

    <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">ContextRefreshedEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">sql</span><span class="o">.</span><span class="na">SQLException</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"starting h2 console at port 8078"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">webServer</span> <span class="o">=</span> <span class="n">org</span><span class="o">.</span><span class="na">h2</span><span class="o">.</span><span class="na">tools</span><span class="o">.</span><span class="na">Server</span><span class="o">.</span><span class="na">createWebServer</span><span class="o">(</span><span class="s">"-webPort"</span><span class="o">,</span> <span class="s">"8078"</span><span class="o">,</span> <span class="s">"-tcpAllowOthers"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">ContextClosedEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"stopping h2 console at port 8078"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">webServer</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Port 8078로 설정하여<br />
<code class="language-plaintext highlighter-rouge">localhost:8078</code>을 웹주소로 입력해 기존과 동일하게 접근이 가능하다.</p>

<p>이제 우리가 확인해야할 Controller가 어떻게<br />
변경되었는지 확인해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/v12/coffees"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeController</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CoffeeService</span> <span class="n">coffeeService</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CoffeeMapper</span> <span class="n">mapper</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CoffeeController</span><span class="o">(</span><span class="nc">CoffeeService</span> <span class="n">coffeeService</span><span class="o">,</span> <span class="nc">CoffeeMapper</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">coffeeService</span> <span class="o">=</span> <span class="n">coffeeService</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mapper</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PostMapping</span><span class="o">()</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span> <span class="nf">createCoffee</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">CoffeeDto</span><span class="o">.</span><span class="na">Post</span><span class="o">&gt;</span> <span class="n">requestBody</span><span class="o">){</span>

        <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">CoffeeDto</span><span class="o">.</span><span class="na">Response</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
                <span class="n">requestBody</span>
                        <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">post</span> <span class="o">-&gt;</span> <span class="n">coffeeService</span><span class="o">.</span><span class="na">createCoffee</span><span class="o">(</span><span class="n">mapper</span><span class="o">.</span><span class="na">coffeePostDtoToCoffee</span><span class="o">(</span><span class="n">post</span><span class="o">)))</span>
                        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">coffee</span> <span class="o">-&gt;</span> <span class="n">mapper</span><span class="o">.</span><span class="na">coffeeToCoffeeResponseDto</span><span class="o">(</span><span class="n">coffee</span><span class="o">));</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nf">ResponseEntity</span><span class="o">(</span><span class="n">result</span><span class="o">,</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">CREATED</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>정말 간단하게 되어있는 Controller 계층이다.<br />
Post요청하나만 존재하는 클래스이고, <code class="language-plaintext highlighter-rouge">Mono</code>를 이용했다.<br />
<code class="language-plaintext highlighter-rouge">Mono&lt;&gt;</code>로 감싼 객체를 받고, 응답을해주면 된다.</p>

<p>객체를 변환하기 위해서 <code class="language-plaintext highlighter-rouge">flatMap()</code> , <code class="language-plaintext highlighter-rouge">map()</code>을 사용했고<br />
Mono에 감싸여있는 객체 <code class="language-plaintext highlighter-rouge">CoffeeDto.Response</code>를 꺼내서<br />
우리가 만든 mapper 클래스를 이용해 <code class="language-plaintext highlighter-rouge">Coffee</code> 객체로 변환해주고 있다.</p>

<p>변환된 객체를 <code class="language-plaintext highlighter-rouge">coffeeService.createCoffee();</code>메서드에 매개변수로 넣어<br />
Service 계층을 호출하는 모습이다. 이제 Service 계층에서는 데이터를 DB에 저장하고<br />
다시 반환받은 객체를 <code class="language-plaintext highlighter-rouge">map();</code>메서드로 반환 타입에 맞는 형태로 변경하여</p>

<p><code class="language-plaintext highlighter-rouge">ResponseEntity</code> 객체를 만들어 반환해주면 끝이다.<br />
기존 Spring MVC와 달라진 점은 <code class="language-plaintext highlighter-rouge">Mono</code>를 사용한점만 변경되었다.</p>

<p>그럼 Service 계층을 살펴보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CoffeeRepository</span> <span class="n">coffeeRepository</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">R2dbcEntityTemplate</span> <span class="n">template</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CoffeeService</span><span class="o">(</span><span class="nc">CoffeeRepository</span> <span class="n">coffeeRepository</span><span class="o">,</span> <span class="nc">R2dbcEntityTemplate</span> <span class="n">template</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">coffeeRepository</span> <span class="o">=</span> <span class="n">coffeeRepository</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">template</span> <span class="o">=</span> <span class="n">template</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Coffee</span><span class="o">&gt;</span> <span class="nf">createCoffee</span><span class="o">(</span><span class="nc">Coffee</span> <span class="n">coffee</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Coffee</span><span class="o">&gt;</span> <span class="n">coffeeMono</span> <span class="o">=</span> <span class="n">findVerifiedCoffee</span><span class="o">(</span><span class="n">coffee</span><span class="o">.</span><span class="na">getCoffeeCode</span><span class="o">())</span>
                <span class="o">.</span><span class="na">then</span><span class="o">(</span><span class="n">coffeeRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">coffee</span><span class="o">));</span>

        <span class="k">return</span> <span class="n">coffeeMono</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="nf">findVerifiedCoffee</span><span class="o">(</span><span class="nc">String</span> <span class="n">coffeeCode</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">coffeeRepository</span><span class="o">.</span><span class="na">findByCoffeeCode</span><span class="o">(</span><span class="n">coffeeCode</span><span class="o">)</span>
                <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">findCoffee</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">findCoffee</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="k">new</span> <span class="nc">BusinessLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span><span class="o">.</span><span class="na">COFFEE_CODE_EXISTS</span><span class="o">));</span>
                    <span class="o">}</span>
                    <span class="k">return</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
                <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Service 계층도 기존과 동일한 코드들이고<br />
CoffeeCode를 통해 유무를 확인하는 <code class="language-plaintext highlighter-rouge">findVerifiedCoffee();</code>메서드와<br />
실제로 DB에 저장을하기위한 <code class="language-plaintext highlighter-rouge">createCoffee();</code>메서드가 존재한다.</p>

<p>여기도 안에있는 내용들이 <code class="language-plaintext highlighter-rouge">Mono</code>를 이용해 처리한점만 다르다.</p>

<p>그럼 이제 Repository 계층을 살펴보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CoffeeRepository</span> <span class="kd">extends</span> <span class="nc">R2dbcRepository</span><span class="o">&lt;</span><span class="nc">Coffee</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">Coffee</span><span class="o">&gt;</span> <span class="nf">findByCoffeeCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">coffeeCode</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>기존에 Spring MVC를 사용할 때는 JDBC,JPA를 사용했지만<br />
Spring WebFlux에서는 R2dbc를 사용하고있다.</p>

<p>형식은 기존에 설정하는 것과 비슷하다.<br />
여기서도 다른점은 <code class="language-plaintext highlighter-rouge">Mono</code>를 사용했다는 점</p>

<p>이렇게 작성을 완료하고 Postman을 통해 API를 호출해보면</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMjWMzoUG84NMNpT7pz0VgGN-ybnZKqlYSH5gZz5h8ljPVKuQeR_DO_ECGFSSbn1ZKojbxKb9qlYgRFDjO-D24JuRQaeQ=w777-h807" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Spring MVC와 동일하게 요청과 응답이 오는 것을 볼 수 있다.<br />
실제로 Postman을 통해서 여러개 요청하는 작업은 못해봤지만</p>

<p>처음에 테스트해보았던 동시에 호출하였을 경우처럼<br />
동시에 많은 요청처리가 이을 경우 확연히 다른 차이를 보일 것 같다.</p>

<p><br /></p>

<p>기타로 정상적으로 테스트하기 위해 필요한 코드인<br />
<code class="language-plaintext highlighter-rouge">Coffee</code>, <code class="language-plaintext highlighter-rouge">CoffeeDto</code>, <code class="language-plaintext highlighter-rouge">CoffeeMapper</code>, <br />
<code class="language-plaintext highlighter-rouge">BusinessLogicException</code>, <code class="language-plaintext highlighter-rouge">ExceptionCode</code>를 아래에 적어본다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NoArgsConstructor</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@Table</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Coffee</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">coffeeId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">korName</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">engName</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">price</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">coffeeCode</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">CoffeeStatus</span> <span class="n">coffeeStatus</span> <span class="o">=</span> <span class="nc">CoffeeStatus</span><span class="o">.</span><span class="na">COFFEE_FOR_SALE</span><span class="o">;</span>

    <span class="nd">@CreatedDate</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">createdAt</span><span class="o">;</span>

    <span class="nd">@LastModifiedDate</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="s">"last_modified_at"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">LocalDateTime</span> <span class="n">modifiedAt</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">enum</span> <span class="nc">CoffeeStatus</span> <span class="o">{</span>
        <span class="no">COFFEE_FOR_SALE</span><span class="o">(</span><span class="s">"판매중"</span><span class="o">),</span>
        <span class="no">COFFEE_SOLD_OUT</span><span class="o">(</span><span class="s">"판매 중지"</span><span class="o">);</span>

        <span class="nd">@Getter</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">status</span><span class="o">;</span>

        <span class="nc">CoffeeStatus</span><span class="o">(</span><span class="nc">String</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">status</span> <span class="o">=</span> <span class="n">status</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CoffeeDto</span> <span class="o">{</span>
    <span class="nd">@Getter</span>
    <span class="nd">@AllArgsConstructor</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Post</span> <span class="o">{</span>
        <span class="nd">@NotBlank</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">korName</span><span class="o">;</span>

        <span class="nd">@NotBlank</span>
        <span class="nd">@Pattern</span><span class="o">(</span><span class="n">regexp</span> <span class="o">=</span> <span class="s">"^([A-Za-z])(\\s?[A-Za-z])*$"</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"커피명(영문)은 영문이어야 합니다(단어 사이 공백 한 칸 포함). 예) Cafe Latte"</span><span class="o">)</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">engName</span><span class="o">;</span>

        <span class="nd">@Range</span><span class="o">(</span><span class="n">min</span><span class="o">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">max</span><span class="o">=</span> <span class="mi">50000</span><span class="o">)</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>

        <span class="nd">@NotBlank</span>
        <span class="nd">@Pattern</span><span class="o">(</span><span class="n">regexp</span> <span class="o">=</span> <span class="s">"^([A-Za-z]){3}$"</span><span class="o">,</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"커피 코드는 3자리 영문이어야 합니다."</span><span class="o">)</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">coffeeCode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Mapper</span><span class="o">(</span><span class="n">componentModel</span> <span class="o">=</span> <span class="s">"spring"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CoffeeMapper</span> <span class="o">{</span>
    <span class="nc">Coffee</span> <span class="nf">coffeePostDtoToCoffee</span><span class="o">(</span><span class="nc">CoffeeDto</span><span class="o">.</span><span class="na">Post</span> <span class="n">coffeePostDto</span><span class="o">);</span>
    <span class="nc">CoffeeDto</span><span class="o">.</span><span class="na">Response</span> <span class="nf">coffeeToCoffeeResponseDto</span><span class="o">(</span><span class="nc">Coffee</span> <span class="n">coffee</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BusinessLogicException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="nc">ExceptionCode</span> <span class="n">exceptionCode</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BusinessLogicException</span><span class="o">(</span><span class="nc">ExceptionCode</span> <span class="n">exceptionCode</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">exceptionCode</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="k">this</span><span class="o">.</span><span class="na">exceptionCode</span> <span class="o">=</span> <span class="n">exceptionCode</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">ExceptionCode</span> <span class="o">{</span>
    <span class="no">COFFEE_NOT_FOUND</span><span class="o">(</span><span class="mi">404</span><span class="o">,</span> <span class="s">"Coffee not found"</span><span class="o">),</span>
    <span class="no">COFFEE_CODE_EXISTS</span><span class="o">(</span><span class="mi">409</span><span class="o">,</span> <span class="s">"Coffee Code exists"</span><span class="o">);</span>

    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">status</span><span class="o">;</span>

    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">message</span><span class="o">;</span>

    <span class="nc">ExceptionCode</span><span class="o">(</span><span class="kt">int</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">status</span> <span class="o">=</span> <span class="n">code</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">message</span> <span class="o">=</span> <span class="n">message</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<hr />

<p>오늘은 이렇게 SpringWebFlux를 실제 우리가<br />
애플리케이션 계층에 적용하는 방식과 동일하게 적용해보았다.</p>

<p>확실히 Spring MVC보다 사용하기 어려운 느낌이든다.<br />
아무래도 익숙해지려면 실제 내부 프로그램도 많이 봐야할 것 같고<br />
<code class="language-plaintext highlighter-rouge">Backpressure</code>라든가 <code class="language-plaintext highlighter-rouge">Non-Blocking</code>처리 라든가<br />
정확히 어떻게 코드로 동작하는지 개념과 흐름 파악이 필요할 것 같다.<br />
또한 Operator들도 많이 알아야할 것같다..ㅠㅠ</p>

<p>우선 아직 Spring MVC도 애플리케이션 구현 경험이 거의 없다보니까<br />
눈앞에 있는 기술부터 체득과 습득을하고 이후로 나아가보려한다.</p>

<p>이렇게 수박 겉 핥기인 WebFlux는 여기서 끝 !</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 짜장밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[12월이 시작되었다 ! 올해도 이렇게 시간이 빨리가는 구나 점점 더빨리가는 시간이 조금 야속하다.]]></summary></entry><entry><title type="html">TIL) Spring WebFlux Project Reactor</title><link href="http://localhost:4000/til/2022/11/30/til.html" rel="alternate" type="text/html" title="TIL) Spring WebFlux Project Reactor" /><published>2022-11-30T00:00:00+09:00</published><updated>2022-11-30T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/30/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/30/til.html"><![CDATA[<p>어느덧 11월의 마지막이 다가왔다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gP-V3f78gzYoHWe4BsoYdT3mBXrBTI7YNQJSLWZStK3WDB2VvN0qjzA3GflB1maNYmMaDLa5a3SAqzjBTNSgMxDF3ee=w1185-h921" alt="image" class="align-left" style="max-width: 50%" /></p>

<p>코딩 공부를 시작한게 8월인데 벌써 4개월이 지났다니<br />
믿기지 않는다.. 그만큼 많이 발전도 했지만<br />
아직도 많이 부족하다고 느끼기에 시간이 더욱더 간절하게 느껴진다.</p>

<p>오늘은 어제배운 Reactive 프로그램의 스트림즈의 구현체인<br />
Project Reactor에 대해 공부해보는 시간이다.</p>

<hr />

<h2 id="project-reactor">Project Reactor</h2>

<h3 id="project-reactor-란">Project Reactor 란?</h3>

<p><a href="https://projectreactor.io/">Project Reactor</a> 줄여서 Reactor라고 부른다. 리액티브 스트림즈의 구현체 중 하나로써<br />
Reactive 기반 Spring Web Application을 만들때 사용하는 핵심기술이다.</p>

<p>리액티브 프로그래밍은 Non-Blocking통신을 지원하며, Non-Blocking이 핵심적인 특징이다. <br />
간단하게 얘기하지면 요청 쓰레드가 차단이 되지 않는다 정도로 알면될 것 같다.</p>

<p>Publisher 타입으로 Mono[0|1]와 Flux[N]이라는 두 가지 타입을 제공한다.</p>

<p><br /></p>

<h3 id="marble-diagram">Marble Diagram</h3>

<p><strong>1). Mono</strong></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNhCC3gMyVY9U2tYfXL1Ugml0_Fey_7uS4w1fYYfafR-twQzcbefQVQDrr0dAmTnmofFKkHwbcguv_pVuYEj0mmm6Hn3g=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>Marble Diagram으로 동그란것 하나를 데이터라 생각하면 쉬울 것 같다.</p>

<p>흐름 순서는 위에 다이어그램을 보면 이해가 쉬울 것 같다. <br />
Mono 시퀀스가 시작되고 데이터를 emit한다. Mono는 Mono[0|1] 즉, 0건 또는 1의<br />
데이터만 emit 하는 Reactor 타입이기 때문에 위와 같이 표현되었다.</p>

<p>그리고 Mono 시퀀스가 종료되고, Operator를 통해 데이터가 가공된다.<br />
그리고 Downstream의 타임라인으로 전달되어<br />
정의되어있는 해당 시퀀스를 실행하고 종료하게 되어진다.</p>

<p>코드로 보면 이렇게 볼 수 있을 것 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReactiveExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Mono</span>
                <span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"Hello, Reactive"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">())</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span>
                        <span class="n">message</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">),</span>
                        <span class="n">error</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">error</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()),</span>
                        <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Complete"</span><span class="o">)</span>
                <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 출력</span>
<span class="no">HELLO</span><span class="o">,</span> <span class="no">REACTIVE</span>
<span class="nc">Complete</span>
</code></pre></div></div>
<p>위에 코드를 보면 <code class="language-plaintext highlighter-rouge">.map();</code>메서드가 Operator의 역할이다.<br />
<code class="language-plaintext highlighter-rouge">just();</code>에서 데이터를 emit한 후 <code class="language-plaintext highlighter-rouge">.UpperCase();</code> 대문자로 변환시키고 있다.<br />
그리고 최종적으로 Downstream쪽에서 데이터를 전달해<br />
<code class="language-plaintext highlighter-rouge">.subscribe();</code> 메서드로 전달받은 데이터를 처리해준 모습을 볼 수 있다.<br />
해당 상황은 우선 Error가 발생하지 않은 경우를 테스트 해보았다.</p>

<p>이제 만약 Downstream에서 Error가 발생했을 경우<br />
비정상적인 종료를 한번 확인해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReactiveExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Mono</span>
                <span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"Hello, Reactive"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span>
                        <span class="n">message</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">[</span><span class="mi">3</span><span class="o">]),</span>
                        <span class="n">error</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"! Error : "</span><span class="o">+</span> <span class="n">error</span><span class="o">.</span><span class="na">getMessage</span><span class="o">()),</span>
                        <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Complete"</span><span class="o">)</span>
                <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 출력</span>
<span class="o">!</span> <span class="nc">Error</span> <span class="o">:</span> <span class="nc">Index</span> <span class="mi">3</span> <span class="n">out</span> <span class="n">of</span> <span class="n">bounds</span> <span class="k">for</span> <span class="n">length</span> <span class="mi">2</span>
<span class="nc">Complete</span>
</code></pre></div></div>
<p>위에 예제 코드를 보면 단순히 String을 배열로 쪼개서<br />
Downstream으로 넘겨주는 코드이다.<br />
받았을때 공백기준으로 나눴기때문에 배열방에는 2개만 존재하고<br />
범위를 벗어나는 데이터를 조회하려고 명령을 내렸을 경우<br />
error를 처리해주는 메서드를 만들어 표현할 수 있다.</p>

<p><br /></p>

<p><strong>2). Flux</strong></p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gNa2bYw_449zSbZ1QB7bHvPkp-iEamCVUmFSVFMs6xh0U2LZ9zmFCflb1hwKNBcdZqL4xl-pGtpMAa8KWzt3xKEWHHZHA=w1920-h921" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>기본 적인 흐름은 Mono와 전부 동일하다.<br />
다른 점은 처리해야할 데이터가 Flux[N]개로<br />
여러개의 데이터를 emit할 수 있는 모습을 다이어그램에서 볼 수 있다.</p>

<p><br /></p>

<h3 id="scheduler">Scheduler</h3>

<p>Reactor에서 Scheduler는 쓰레드를 관리하는 관리자 역할이다.<br />
즉, Reactor Sequence 상에서 처리되는 동작들을 하나 이상의 쓰레드에서<br />
동작하도록 별도의 쓰레드를 제공해준다고 생각하면 쉬울 것 같다.</p>

<p>Reactor는 기본적으로 Non-Blocking 통신을 위한 비동프로그래밍을 위해<br />
탄생했기 때문에 여러 쓰레드를 손쉽게 관리해주는 Scheduler의 역할이 중요하다 할 수 있다.</p>

<p>간단한 코드로 비교예제를 살펴보자
먼저 Scheduler를 추가하지 않았을 경우를 살펴보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scheduler를 추가하지 않았을 경우</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SchedulersExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Flux</span>
            <span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# onNext: {}"</span><span class="o">,</span> <span class="n">data</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20:51:36.461 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework
20:51:36.481 [main] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 4
20:51:36.483 [main] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 8
20:51:36.483 [main] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 12
20:51:36.483 [main] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 16
20:51:36.483 [main] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 20
</code></pre></div></div>
<p>해당 프로그램을 실행시켰을때 콘솔에서 확인할 수 있는 로그이다.<br />
Scheduler를 추가하지 않고 기존과 동일하게 사용하였고<br />
여기서 알 수 있는 점은 <code class="language-plaintext highlighter-rouge">[main]</code>쓰레드를 사용하고 있다는 점이다.</p>

<p><br /></p>

<p>Scheduler를 적용한 코드를 확인해보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scheduler를 사용하였을 경우</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SchedulersExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Flux</span>
                <span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
                <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="nc">Schedulers</span><span class="o">.</span><span class="na">boundedElastic</span><span class="o">())</span>
                <span class="o">.</span><span class="na">doOnSubscribe</span><span class="o">(</span><span class="n">subscription</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# doOnSubscribe"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
                <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# onNext: {}"</span><span class="o">,</span> <span class="n">data</span><span class="o">));</span>

        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100L</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20:53:19.592 [main] DEBUG reactor.util.Loggers - Using Slf4j logging framework
20:53:19.623 [main] INFO com.codestates.example.schedulers.SchedulersExample02 - # doOnSubscribe
20:53:19.630 [boundedElastic-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 4
20:53:19.631 [boundedElastic-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 8
20:53:19.631 [boundedElastic-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 12
20:53:19.631 [boundedElastic-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 16
20:53:19.631 [boundedElastic-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 20
</code></pre></div></div>

<p>위에 코드는 Scheduler를 사용하였을때의 코드이다.<br />
첫번째 코드와 차이점은 <code class="language-plaintext highlighter-rouge">subscribeOn();</code>, <code class="language-plaintext highlighter-rouge">doOnSubscribe();</code>  <br />
Operator를 추가해서 사용을 하고 있다는 점이다.</p>

<p><code class="language-plaintext highlighter-rouge">subscribeOn();</code> Operator는 <code class="language-plaintext highlighter-rouge">Schedulers.boundedElastic()</code>와 같은<br />
Scheduler를 지정하면 구독 직후에 실행되는 쓰레드가 main 쓰레드에서 해당 쓰레드로 변경된다.</p>

<p><code class="language-plaintext highlighter-rouge">doOnSubscribe();</code>Operator는 구독 발생 직후에 Trigger되는 Operator로<br />
구독 직후에 어떤 동작을 수행하고 싶을때 사용하는 Operator이다.</p>

<p>출력 결과를 보면 알 수 있듯이 <code class="language-plaintext highlighter-rouge">[main]</code>쓰레드에서 진행 중이던 흐름이<br />
<code class="language-plaintext highlighter-rouge">[boundedElastic-1]</code> 쓰레드로 변경된 모습을 로그로 확인해 볼 수 있다.</p>

<p><br /></p>

<p>마지막으로 예제하나만 더보고 넘어가자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SchedulersExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Flux</span>
            <span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
            <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="nc">Schedulers</span><span class="o">.</span><span class="na">boundedElastic</span><span class="o">())</span>
            <span class="o">.</span><span class="na">doOnSubscribe</span><span class="o">(</span><span class="n">subscription</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# doOnSubscribe"</span><span class="o">))</span>

            <span class="o">.</span><span class="na">publishOn</span><span class="o">(</span><span class="nc">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">())</span>  <span class="c1">// (1)</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# filter doOnNext"</span><span class="o">))</span>  <span class="c1">// (2)</span>

            <span class="o">.</span><span class="na">publishOn</span><span class="o">(</span><span class="nc">Schedulers</span><span class="o">.</span><span class="na">parallel</span><span class="o">())</span>    <span class="c1">// (3)</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
            <span class="o">.</span><span class="na">doOnNext</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# map doOnNext"</span><span class="o">))</span> <span class="c1">// (4)</span>

            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">data</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"# onNext: {}"</span><span class="o">,</span> <span class="n">data</span><span class="o">));</span>

        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100L</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>21:03:32.441 [main] INFO com.codestates.example.schedulers.SchedulersExample - # doOnSubscribe
21:03:32.448 [parallel-2] INFO com.codestates.example.schedulers.SchedulersExample - # filter doOnNext
21:03:32.448 [parallel-2] INFO com.codestates.example.schedulers.SchedulersExample - # filter doOnNext
21:03:32.448 [parallel-2] INFO com.codestates.example.schedulers.SchedulersExample - # filter doOnNext
21:03:32.448 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # map doOnNext
21:03:32.448 [parallel-2] INFO com.codestates.example.schedulers.SchedulersExample - # filter doOnNext
21:03:32.448 [parallel-2] INFO com.codestates.example.schedulers.SchedulersExample - # filter doOnNext
21:03:32.448 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 4
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # map doOnNext
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 8
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # map doOnNext
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 12
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # map doOnNext
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 16
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # map doOnNext
21:03:32.451 [parallel-1] INFO com.codestates.example.schedulers.SchedulersExample - # onNext: 20
</code></pre></div></div>
<p>해당코드가 이전과 다른점은 <code class="language-plaintext highlighter-rouge">publishOn();</code>이라는 Operator가 추가된 예제이다.<br />
<code class="language-plaintext highlighter-rouge">publishOn();</code>은 <code class="language-plaintext highlighter-rouge">publishOn();</code> 기준으로 Downstream쪽 쓰레드가<br />
<code class="language-plaintext highlighter-rouge">publishOn();</code>에서 Scheduler로 지정한 쓰레드로 변경이된다. (Schedulers.parallel())</p>

<p><code class="language-plaintext highlighter-rouge">doOnNext();</code> Operator는 바로앞에 위치한 Operaotr가 실행될 때<br />
Trigger되는 Operator이다. 위에선 filter와 map을 구분짓기위해 사용했다.</p>

<p>콘솔로그에서 볼 수 있듯이 <code class="language-plaintext highlighter-rouge">[main]</code>쓰레드에서 <code class="language-plaintext highlighter-rouge">[parallel-2]</code>로 쓰레드가 변경되었고<br />
<code class="language-plaintext highlighter-rouge">[parallel-1]</code>로 변경된 모습을 볼 수 있다. 내부적으로 <code class="language-plaintext highlighter-rouge">[parallel]</code> 쓰레드의 순서는 보장되지 않는다.</p>

<p><br /></p>

<h3 id="operator">Operator</h3>

<p>이전부터 계속 Operator를 사용한는 코드들을 보았다.<br />
그만큼 Reactor와 Operator를 뗄래야 뗄 수 없는 관계이다.</p>

<p>Operator 관련해서는 사실 지원하는 종류가 너무 많기 때문에<br />
부가적인 Advance 공부는 추후에 해봐야할 것 같고<br />
목록만 우선 정리 해놓으려고 한다.</p>

<p>그 중에서 자주사용하고 중요한 것 들을 <span style="color:#CC00CC"><strong>보라색</strong></span>으로 표시해둔다.</p>

<p>✅ <strong>새로운 Sequence를 생성하고자 할 경우 (Creating)</strong></p>
<ul>
  <li>just()</li>
  <li><span style="color:#CC00CC"><strong>fromStream()</strong></span></li>
  <li><span style="color:#CC00CC"><strong>fromIterable()</strong></span></li>
  <li>fromArray()</li>
  <li>range()</li>
  <li>interval()</li>
  <li>empty()</li>
  <li>never</li>
  <li>defer()</li>
  <li>using()</li>
  <li>generate()</li>
  <li><span style="color:#CC00CC"><strong>create()</strong></span></li>
</ul>

<p>✅ <strong>기존 Sequence에서 변환작업이 필요한 경우 (Transforming)</strong></p>
<ul>
  <li><span style="color:#CC00CC"><strong>map()</strong></span></li>
  <li><span style="color:#CC00CC"><strong>flatMap()</strong></span></li>
  <li><span style="color:#CC00CC"><strong>concat()</strong></span></li>
  <li>collectList()</li>
  <li>collectMap()</li>
  <li>merge()</li>
  <li><span style="color:#CC00CC"><strong>zip()</strong></span></li>
  <li>the()</li>
  <li>switchIfEmpty</li>
  <li>and()</li>
  <li>when()</li>
</ul>

<p>✅ <strong>Sequence에서 내부의 동작을 확인하고자 할 경우 (Peeking)</strong></p>
<ul>
  <li>doOnSubscribe</li>
  <li><span style="color:#CC00CC"><strong>doOnNext()</strong></span></li>
  <li>doOnError()</li>
  <li>doOnCancel()</li>
  <li>doFirst()</li>
  <li>doOnRequest()</li>
  <li>doOnTerminate()</li>
  <li>doAfterTerminate()</li>
  <li>doOnEach()</li>
  <li>doFinally()</li>
  <li><span style="color:#CC00CC"><strong>log()</strong></span></li>
</ul>

<p>✅ <strong>Sequence에서 데이터를 걸러야할 경우 (Filtering)</strong></p>
<ul>
  <li><span style="color:#CC00CC"><strong>filter()</strong></span></li>
  <li>ignoreElements()</li>
  <li>distinct()</li>
  <li><span style="color:#CC00CC"><strong>take()</strong></span></li>
  <li>next()</li>
  <li>skip()</li>
  <li>sample()</li>
  <li>single()</li>
</ul>

<p>✅ <strong>에러를 처리하고자할 경우 (Handling errors)</strong></p>
<ul>
  <li><span style="color:#CC00CC"><strong>error()</strong></span></li>
  <li><span style="color:#CC00CC"><strong>timeout()</strong></span></li>
  <li>onErrorReturn()</li>
  <li>onErrorResume()</li>
  <li>onErrorMap()</li>
  <li>doFinally()</li>
  <li><span style="color:#CC00CC"><strong>retry()</strong></span></li>
</ul>

<p><br /></p>

<hr />

<p>오늘은 어제보다 조금더 Spring WebFlux에 대해 알아보았고<br />
사실 아직 Spring MVC 어떻게 대체해서 사용해야할지 크게<br />
감이 잡히지는 않는다. 뭔가 Stream API와 비슷한 느낌이 들어 친숙하긴하지만<br />
개념들이 많이 다른 것 처럼 느껴져서 어렵고 생소했다.</p>

<p>내일 우리가 구현했던 Spring MVC 대신<br />
Spring WebFlux 기술을 활용해서 한번 적용해보자</p>

<p>오늘 공부는 여기서 끝 !!</p>

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 제육볶음, 김치찌개, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[어느덧 11월의 마지막이 다가왔다.]]></summary></entry><entry><title type="html">TIL) Spring WebFlux Reactive 프로그래밍</title><link href="http://localhost:4000/til/2022/11/29/til.html" rel="alternate" type="text/html" title="TIL) Spring WebFlux Reactive 프로그래밍" /><published>2022-11-29T00:00:00+09:00</published><updated>2022-11-29T00:00:00+09:00</updated><id>http://localhost:4000/til/2022/11/29/til</id><content type="html" xml:base="http://localhost:4000/til/2022/11/29/til.html"><![CDATA[<p>오늘은 리액티브 프로그래밍에 대해 공부해보는 날이다.<br />
아마 깊은 내용은 다루지 않고, 간단한 지식들만 공부 할 것 같다.</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gOLvm3Tcr7jOo11hO8F_VEjXkI7bN97rGtSVrf1Ti3xqf3ZQe4jQOr1kpMnycZ3ZuOxgeCDU8X3g9guLl8uMN_t1zRm8Q=w1185-h864" alt="image" class="align-left" style="max-width: 30%" /></p>

<p>우리는 Spring MVC 기반의 애플리케이션을 사용하고있는데<br />
최신 기술로 Spring Reactive가 나와서 후에 어떻게<br />
바뀔지는 아무도 모르니 Spring MVC 이해를 마친 후<br />
해당 기술에 대해 깊게 공부해볼 필요가 있을 것 같다.</p>

<hr />

<h3 id="리액티브-프로그래밍이란">리액티브 프로그래밍이란?</h3>

<p>기존의 명령형 프로그래밍 방식과 달리 선언형 프로그래밍 방식을 사용한다.<br />
클라이언트의 요청에 반응을 잘하는 시스템을 의미한다.<br />
리액티브 시스템 관점에서의 반응은 쓰레드의 Non-Blocking과 관련이 있다.<br />
클라이언트의 요청에 대한 대기 시간을 최소화 할 수 있도록<br />
요청 쓰레드가 차단되지 않게 함으로써, 클라이언트에게 즉각적으로<br />
반응하도록 구성된 시스템이라고 볼 수 있다.</p>

<p>리액티브 시스템의 특징을 알아보자</p>

<p><img src="https://lh3.googleusercontent.com/u/0/drive-viewer/AFDK6gMC17N9996c0CAWJ2CXGoDaByldzZ7UTKzUtpNVQbGGwNbemzqeKFNeAeqE8q_mHlA_5DEs1EUS4hO70psikE0WUvyOhg=w1554-h1728" alt="image" class="align-left" style="max-width: 100%" /></p>

<p>1). MEANS<br />
-. 리액티브 시스템에서 사용하는 커뮤니케이션 수단</p>
<ul>
  <li>Message Driven  <br />
-. 리액티브 시스템에서는 메세지 기반 통신을 통해 여러 시스템 간에 느슨한 결합을 유지한다.</li>
</ul>

<p>2). FORM<br />
-. 메세지 기반 통신을 통해 리액티브 시스템이 어떤 특성을 가지는 구조로 형성되는지를 의미</p>
<ul>
  <li>Elastic<br />
-. 시스템으로 들어오는 요청량이 적거나 많거나에 상관없이 일정한 응답성을 유지하는 것</li>
  <li>Resillient<br />
-. 시스템의 일부분에 장애가 발생하더라도 응답성을 유지하는 것</li>
</ul>

<p>3). VALUE<br />
-. 리액티브 시스템의 핵심 가치가 무엇인지를 표현하는 영역</p>
<ul>
  <li>Responsive<br />
-. 리액티브 시스템은 클라이언트의 요청에 즉각적으로 응답할 수 있어야함을 의미</li>
  <li>Maintainable<br />
-. 클라이언트의 요청에 대한 즉각적인 응답이 지속가능해야함을 의미</li>
  <li>Extensible<br />
-. 클라이언트의 요청에 대한 처리량을 자동으로 확장하고 축소할 수 있어야함을 의미</li>
</ul>

<p><br /></p>

<h3 id="리액티브-스트림즈란">리액티브 스트림즈란?</h3>
<p>리액티브 프로그래밍을 위한 표준사양이다.<br />
리액티브 스트림즈에서 사양으로 정의된 구성요소를 알아보자</p>

<p><strong>1). Publisher 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Publisher</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="nc">Subscriber</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>-. 데이터 소스로 부터 데이터를 내보내는(emit) 역할을 한다. <br />
-. <code class="language-plaintext highlighter-rouge">subscribe();</code>추상 메서드를 포함하고 있고, 매개변수로 전달되는 Subscriberrk<br />
Publisher로부터 내보내진 데이터를 소비하는 역할을 한다.</p>

<p><br /></p>

<p><strong>2). Subscriber 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Subscriber</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="nc">Subscription</span> <span class="n">s</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">t</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>-. Publisher로 부터 내보내진 데이터를 소비하는 역할을 한다.</p>

<p>-. <code class="language-plaintext highlighter-rouge">onSubscribe(Subscription s);</code></p>
<ul>
  <li>구독이 시작되는 시점에 호출됨.</li>
  <li>Pusblisher에게 요청할 데이터의 개수를 지정하거나 구독해지 처리가 가능</li>
</ul>

<p>-. <code class="language-plaintext highlighter-rouge">onNext(T t)</code></p>
<ul>
  <li>Publisher가 데이터를 emit할 때 호출됨</li>
  <li>emti된 데이터를 전달 받아서 소비할 수 있다.</li>
</ul>

<p>-. <code class="language-plaintext highlighter-rouge">onError(Throwable t)</code></p>
<ul>
  <li>Publisher로부터 emit된 데이터가 Subscriber에게 전달되는 과정에서<br />
에러가 발생할 경우에 호출된다.</li>
</ul>

<p>-. <code class="language-plaintext highlighter-rouge">onComplete()</code></p>
<ul>
  <li>Publisher가 데이터를 emit하는 과정이 종료될 경우 호출됨</li>
  <li>emit이 정상적으로 완료된 후, 처리해야 될 작업이 있다면 해당 메서드 내에서 수행할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>3). Subscription 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Subscription</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>-. Subscriber의 구독 자체를 표현한 인터페이스이다.
-. <code class="language-plaintext highlighter-rouge">request(long n)</code></p>
<ul>
  <li>Publisher가 emit하는 데이터의 개수를 요청</li>
</ul>

<p>-. <code class="language-plaintext highlighter-rouge">cancel()</code></p>
<ul>
  <li>구독을 해지하는 역할을한다. 구독해지가 발생하면 Publisher는 더이상 데이터를 Emit하지 않는다.</li>
</ul>

<p><br /></p>

<p><strong>4). Processor 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Processor</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Subscriber</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;,</span> <span class="nc">Publisher</span><span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>
<p>-. 별도로 구현해야 되는 추상메서드는 없다.<br />
-. Publisher와 Subscriber의 역할을 동시에 할 수 있는 특징을 가지고 있다.</p>

<p><br /></p>

<p><strong>5). 구현체들</strong></p>
<ul>
  <li>Project Reactor</li>
  <li>RxJava</li>
  <li>Java Flow API</li>
</ul>

<p>코드로 알아보기</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReactiveExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Publisher의 역할</span>
        <span class="nc">Mono</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">mono</span> <span class="o">=</span> <span class="nc">Mono</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"Hello, Reactive"</span><span class="o">);</span>

        <span class="c1">// Subscriber의 역할</span>
        <span class="n">mono</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">message</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 출력</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="nc">Reactive</span>
</code></pre></div></div>
<p>리액티브 스트림즈 구현체인 Project Reactor을 통해 출력하고 있는 모습이다.<br />
<code class="language-plaintext highlighter-rouge">Mono</code>의 역할이 Publisher의 역할이고<br />
Subscriber는 Publisher가 emit한 데이터를 전달 받아서<br />
소비하는 역할이라고 위에서 공부했었다.</p>

<p>Subscriber 역할을 하는 것은 <code class="language-plaintext highlighter-rouge">mono.subscribe();</code> 메서드이고<br />
내부에 정의된 람다 표현식을 사용하고 있다.</p>

<p>기존에 우리가 사용했던 Stream과 동일하게 메서드 체인형식으로 구성도 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReactiveExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Mono</span>
            <span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"Hello, Reactive"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">message</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">message</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 출력</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="nc">Reactive</span>
</code></pre></div></div>

<p>다른 형식의 예제를 알아보자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReactiveGlossaryExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Flux</span>
            <span class="o">.</span><span class="na">fromIterable</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">11</span><span class="o">))</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">number</span> <span class="o">-&gt;</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span>
            <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="o">)</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 출력</span>
<span class="mi">14</span>
</code></pre></div></div>
<p><strong>Publisher -&gt;</strong> <code class="language-plaintext highlighter-rouge">Flux</code>가 Pusblisher 이다.</p>

<p><strong>Emit -&gt;</strong> <code class="language-plaintext highlighter-rouge">Flux</code>가 데이터를 내보내는 것을 가르킴</p>

<p><strong>Subscriber -&gt;</strong> <code class="language-plaintext highlighter-rouge">Flux</code>가 emit한 데이터를 전달 받아서 소비하는 주체 <br />
즉, <code class="language-plaintext highlighter-rouge">System.out::println</code> 부분이 Subscriber에 해당한다.</p>

<p><strong>Subscribe -&gt;</strong> <code class="language-plaintext highlighter-rouge">subscribe</code> 메서드를 호출하면 구독을 하는 것이다.</p>

<p><strong>Signal -&gt;</strong> Publisher가 발생시키는 이벤트를 의미한다.</p>

<p><strong>Operator -&gt;</strong> 어떤 동작을 수행하는 메서드를 의미한다.<br />
<code class="language-plaintext highlighter-rouge">fromIterable()</code>, <code class="language-plaintext highlighter-rouge">filter()</code>, <code class="language-plaintext highlighter-rouge">reduce()</code>등 하나하나들 Operator이라 한다.</p>

<p><strong>Sequence -&gt;</strong> Operator 체인으로 표현되는 데이터의 흐름을 의미한다.<br />
해당 코드에선 코드자체를 하나의 Sequence라고 보면된다.</p>

<p><strong>Upstream -&gt;</strong> Operator 기준으로 위쪽 Sequence 일부를 Upstream이라함<br />
<strong>Downstream -&gt;</strong> Operator 기준으로 아래쪽 Sequence 일부를 Downstream이라함</p>

<p><br /></p>

<hr />

<p><br /></p>

<p><span style="color:#994C00"><strong>오늘의 커피량</strong></span>: ☕️ ☕️<br />
<strong>오늘의 점심</strong>: 제육볶음, 김치찌개, 밥</p>]]></content><author><name>LEE JAEHYEOK</name></author><category term="TIL" /><category term="TIL" /><category term="부트캠프" /><category term="코드스테이츠" /><summary type="html"><![CDATA[오늘은 리액티브 프로그래밍에 대해 공부해보는 날이다. 아마 깊은 내용은 다루지 않고, 간단한 지식들만 공부 할 것 같다.]]></summary></entry></feed>